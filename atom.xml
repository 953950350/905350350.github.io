<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LCW blog</title>
  
  <subtitle>hello world</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-13T11:22:27.951Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李成文</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构基础</title>
    <link href="http://yoursite.com/2018/08/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/08/11/数据结构/</id>
    <published>2018-08-10T16:00:00.000Z</published>
    <updated>2018-08-13T11:22:27.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种遵从先进后出原则的有序集合。新添加的或待删除的元素都保存在栈的同一端，称为栈顶，另一端叫做栈底。新元素都靠近栈顶，旧元素都接近栈底。</p><p>创建一个栈，并且让这个栈有一些基本的方法</p><ul><li>push()：添加一个(或多个)新元素到栈顶。</li><li>pop()：移除栈顶的元素，同时返回被移除的元素。</li><li>peek()：返回栈顶的元素，不修改栈。</li><li>isEmpty()：如果栈里没有任何元素返回true，否则返回false</li><li>clear()：移除栈里所有的元素</li><li>size()：返回栈里的元素个数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> items = []</span><br><span class="line">  <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = <span class="built_in">arguments</span>[i]</span><br><span class="line">      <span class="keyword">if</span> (item !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        items.push(item)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> items</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.pop()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.peek = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items[items.length - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.length === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    items = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.length</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(items.toString())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用什么的类来创建一个进制转换的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseConverter</span>(<span class="params">decNumber, base</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> remStack = <span class="keyword">new</span> Stack(),</span><br><span class="line">    rem,</span><br><span class="line">    remString = <span class="string">''</span>,</span><br><span class="line">    digits = <span class="string">'0123456789ABCDEF'</span></span><br><span class="line">  <span class="keyword">while</span> (decNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    rem = <span class="built_in">Math</span>.floor(decNumber % base)</span><br><span class="line">    remStack.push(rem)</span><br><span class="line">    decNumber = <span class="built_in">Math</span>.floor(decNumber / base)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!remStack.isEmpty()) &#123;</span><br><span class="line">    remString += digits[remStack.pop()]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> remString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是遵循先进先出的的原则的一组有序的项，队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。</p><p>使用es6语法来实现Queue类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Queue = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      items.set(<span class="keyword">this</span>, [])</span><br><span class="line">    &#125;</span><br><span class="line">    enqueue() &#123;</span><br><span class="line">      <span class="keyword">let</span> s = items.get(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> item = <span class="built_in">arguments</span>[i]</span><br><span class="line">        s.push(item)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dequeue() &#123;</span><br><span class="line">      <span class="keyword">let</span> s = items.get(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> s.shift()</span><br><span class="line">    &#125;</span><br><span class="line">    front() &#123;</span><br><span class="line">      <span class="keyword">let</span> s = items.get(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> s[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">      <span class="keyword">let</span> s = items.get(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> s.length === <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    size() &#123;</span><br><span class="line">      <span class="keyword">let</span> s = items.get(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> s.length</span><br><span class="line">    &#125;</span><br><span class="line">    print() &#123;</span><br><span class="line">      <span class="keyword">let</span> s = items.get(<span class="keyword">this</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(s.toString())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Queue</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>上面使用了es6的class语法创建了一个Queue类，具备了队列基本的一些功能。</p><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>为队列中每个元素添加一个优先级，元素的添加和移除都基于优先级，我们只需修改一下添加元素如队列的规则即可，在添加元素之前判断当前元素的优先级是否高于目前队列中的其它元素的优先级，从队列的开始进行寻找，如果找到当前元素高于队列中某个元素的优先级，将当前元素插入到该元素的前面。如果要添加的元素的优先级小于队列中所有的元素，或者队列中还没有元素，就执行简单的入列操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只需在原来的基础上修改这两个方法即可</span></span><br><span class="line">enqueue(element, priority) &#123;</span><br><span class="line">  <span class="keyword">let</span> s = items.get(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">let</span> queueElement = <span class="keyword">new</span> QueueElement(element, priority)</span><br><span class="line">  <span class="keyword">let</span> added = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = s[i]</span><br><span class="line">    <span class="keyword">if</span> (queueElement.priority &lt; item.priority) &#123;</span><br><span class="line">      s.splice(i, <span class="number">0</span>, queueElement)</span><br><span class="line">      added = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!added) &#123;</span><br><span class="line">    s.push(queueElement)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;，</span><br><span class="line">print() &#123;</span><br><span class="line">  <span class="keyword">let</span> s = items.get(<span class="keyword">this</span>)</span><br><span class="line">  s.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;item.element&#125;</span>-<span class="subst">$&#123;item.priority&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表储存有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置。每个元素由一个储存元素本身的节点和一个指向下一个元素的引用组成。</p><p>相对于传统的数组，链表的一个好处在于，添加或移除元素时不需要移动其他元素。由于链表需要使用指针，所以要想访问链表中间的一个元素，需要从起点开始迭代列表直到找到所需的元素。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h2&gt;&lt;p&gt;栈是一种遵从先进后出原则的有序集合。新添加的或待删除的元素都保存在栈的同一端，称为栈顶，另一端叫做栈底。新元素都靠近栈顶，旧元素都接近栈底。&lt;/p&gt;
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构基础</title>
    <link href="http://yoursite.com/2018/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)/"/>
    <id>http://yoursite.com/2018/08/09/数据结构(一)/</id>
    <published>2018-08-08T16:00:00.000Z</published>
    <updated>2018-08-10T11:16:34.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="什么是数据结构？"><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a>什么是数据结构？</h2><p>数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各自种联系。这些联系可以通过定义相关的函数来给出。</p><ul><li><p>数据对象在计算机中的组织方式</p><ul><li>逻辑结构</li><li>物理存储结构</li></ul></li><li><p>数据对象必定与一系列加在其上的操作相关联</p></li><li>完成这些操作所用的方法就是算法</li></ul><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><ul><li><p>数据类型</p><ul><li>数据对象集</li><li>数据集合相关联的操作集</li></ul></li><li><p>抽象：描述数据类型的方法不依赖于具体实现</p><ul><li>与存放数据的机器无关</li><li>与数据存储的物理结构无关</li></ul></li></ul><h2 id="什么是算法？"><a href="#什么是算法？" class="headerlink" title="什么是算法？"></a>什么是算法？</h2><ul><li>一个有限的指令集</li><li>接受一些输入</li><li>产生输出</li><li>一定在有限的步骤之后终止</li><li><p>每一条指令必须：</p><ul><li>有充分的目标，不能有歧义</li><li>在计算机能处理的范围之内</li><li>描述时应不依赖与任何一种计算机语言以及具体的实现手段</li></ul></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一种基本的数据结构，用于按顺序储存元素的集合。但是元素可以随机存取，因为数组中每个元素都可以通过数值索引来识别。</p><ul><li>动态数组</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构与算法&quot;&gt;&lt;a href=&quot;#数据结构与算法&quot; class=&quot;headerlink&quot; title=&quot;数据结构与算法&quot;&gt;&lt;/a&gt;数据结构与算法&lt;/h1&gt;&lt;h2 id=&quot;什么是数据结构？&quot;&gt;&lt;a href=&quot;#什么是数据结构？&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>播放器内核</title>
    <link href="http://yoursite.com/2018/08/09/%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E5%86%85%E6%A0%B8/"/>
    <id>http://yoursite.com/2018/08/09/音乐播放器内核/</id>
    <published>2018-08-08T16:00:00.000Z</published>
    <updated>2018-08-15T08:37:59.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="音乐播放器内核"><a href="#音乐播放器内核" class="headerlink" title="音乐播放器内核"></a>音乐播放器内核</h1><p>播放器组件是本次项目中的重点和难点，逻辑复杂，基本实现音乐播放器的播放功能。</p><h2 id="播放器组件的显示和隐藏"><a href="#播放器组件的显示和隐藏" class="headerlink" title="播放器组件的显示和隐藏"></a>播放器组件的显示和隐藏</h2><p>由于只要播放列表中有歌曲，播放器组件就会显示出来，所以将播放器组件挂载到app.vue中，播放器组件设计为有两个部分，一个是全屏的播放器，另一个是mini播放器。在两个播放器切换的时候会设计一个动画来提升用户体验。<br>由于动画相对复杂，所以使用transition的钩子函数来实现，由于需要在js中设置animation动画所以使用<code>create-keyframe-animation</code>插件来简化操作。</p><h3 id="动画设置的原理"><a href="#动画设置的原理" class="headerlink" title="动画设置的原理"></a>动画设置的原理</h3><p>本动画的效果是：在打开大播放器时大播放器中的专辑图片从小播放器的专辑图片位置处飞入。</p><ol><li>获取到小播放器中专辑图片的位置，与应该设置的所发比例。由于小播放器与大播放器的位置是相对固定的所以在获取位置时可以直接通过计算来获取到。但是由于位置获取需要一些计算，所以将计算位置单独封装成一个函数，增强代码的可读性。</li><li>设置入场动画，动画就是一个简单的animation动画，不过是在js中设置的，了解插件方法即可</li><li>入场之后移除动画。</li><li>出场动画相对简单，不涉及到多段变化，直接使用transition和transform即可。这里需要注意的一点就是我们在style中写的样式由于有postcss所以并不需要做兼容，但是如果是在js中写的样式就是需要加上浏览器前缀做兼容的了，为了简化代码量我们也可以将这个封装成一个方法。</li><li><p>封装设置浏览器前缀的方法，由于该方法与dom操作有关，所以将其写在dom.js文件之中。这方法使用浏览器检测来确定需要加的前缀名称。</p><ul><li>首先创建一个div并获取到它的style属性对象。</li><li>然后检测该对象中是否有特定浏览器前缀的属性。</li><li>将根据检测到的浏览器，封装一个给样式添加前缀的方法，这个方法返回添加前缀之后的字符串。</li></ul></li><li><p>离开动画之后移除设置的样式。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动画的钩子函数</span></span><br><span class="line">enter(el, done) &#123;</span><br><span class="line">  <span class="comment">// 获取开始的位置和所发比例</span></span><br><span class="line">  <span class="keyword">const</span> &#123; x, y, scale &#125; = <span class="keyword">this</span>._getPosAndScale()</span><br><span class="line">  <span class="keyword">let</span> animation = &#123;</span><br><span class="line">    <span class="number">0</span>: &#123;</span><br><span class="line">      transform: <span class="string">`translate3d(<span class="subst">$&#123;x&#125;</span>px,<span class="subst">$&#123;y&#125;</span>px,0) scale(<span class="subst">$&#123;scale&#125;</span>)`</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">60</span>: &#123;</span><br><span class="line">      transform: <span class="string">'translate3d(0,0,0) scale(1.1)'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">100</span>: &#123;</span><br><span class="line">      transform: <span class="string">'scale(1)'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用create-keyframe-animation插件来设置animation动画</span></span><br><span class="line">  animations.registerAnimation(&#123;</span><br><span class="line">    name: <span class="string">'move'</span>,</span><br><span class="line">    animation,</span><br><span class="line">    presets: &#123;</span><br><span class="line">      duration: <span class="number">400</span>,</span><br><span class="line">      easing: <span class="string">'linear'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 将注册的动画绑定到dom元素上</span></span><br><span class="line">  animations.runAnimation(<span class="keyword">this</span>.$refs.cdWrapper, <span class="string">'move'</span>, done)</span><br><span class="line">&#125;,</span><br><span class="line">afterEnter(el) &#123;</span><br><span class="line">  <span class="comment">// 移除动画</span></span><br><span class="line">  animations.unregisterAnimation(<span class="string">'move'</span>)</span><br><span class="line">  <span class="keyword">this</span>.$refs.cdWrapper.style.animation = <span class="string">''</span></span><br><span class="line">&#125;,</span><br><span class="line">leave(el, done) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; x, y, scale &#125; = <span class="keyword">this</span>._getPosAndScale()</span><br><span class="line">  <span class="keyword">this</span>.$refs.cdWrapper.style[transform] = <span class="string">`translate3d(<span class="subst">$&#123;x&#125;</span>px,<span class="subst">$&#123;y&#125;</span>px,0) scale(<span class="subst">$&#123;scale&#125;</span>)`</span></span><br><span class="line">  <span class="keyword">this</span>.$refs.cdWrapper.style.transition = <span class="string">'all 0.4s'</span></span><br><span class="line">  <span class="keyword">this</span>.$refs.cdWrapper.addEventListener(<span class="string">'transitionend'</span>, done)</span><br><span class="line">&#125;,</span><br><span class="line">afterLeave(el) &#123;</span><br><span class="line">  <span class="keyword">this</span>.$refs.cdWrapper.style[transform] = <span class="string">''</span></span><br><span class="line">  <span class="keyword">this</span>.$refs.cdWrapper.style[<span class="string">'transition'</span>] = <span class="string">''</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 位置计算函数。</span></span><br><span class="line">_getPosAndScale() &#123;</span><br><span class="line">  <span class="comment">// 计算位置和缩放比例</span></span><br><span class="line">  <span class="keyword">const</span> targetWidth = <span class="number">40</span></span><br><span class="line">  <span class="keyword">const</span> paddingLeft = <span class="number">40</span></span><br><span class="line">  <span class="keyword">const</span> paddingBottom = <span class="number">30</span></span><br><span class="line">  <span class="keyword">const</span> paddingTop = <span class="number">80</span></span><br><span class="line">  <span class="keyword">const</span> width = <span class="built_in">window</span>.innerWidth * <span class="number">0.8</span></span><br><span class="line">  <span class="keyword">const</span> scale = targetWidth / width</span><br><span class="line">  <span class="keyword">const</span> x = -(width / <span class="number">2</span> - paddingLeft)</span><br><span class="line">  <span class="keyword">const</span> y = <span class="built_in">window</span>.innerHeight - paddingTop - paddingBottom - width / <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    x,</span><br><span class="line">    y,</span><br><span class="line">    scale</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 添加浏览器前缀的方法</span></span><br><span class="line"><span class="keyword">let</span> elementStyle = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>).style</span><br><span class="line"><span class="keyword">let</span> prefix = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> transformNames = &#123;</span><br><span class="line">    webkit: <span class="string">'webkitTransform'</span>,</span><br><span class="line">    moz: <span class="string">'mozTransform'</span>,</span><br><span class="line">    O: <span class="string">'OTransform'</span>,</span><br><span class="line">    ms: <span class="string">'msTransform'</span>,</span><br><span class="line">    standard: <span class="string">'transform'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> transformNames) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = transformNames[k]</span><br><span class="line">    <span class="keyword">if</span> (elementStyle[value] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> k</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">prefixStyle</span>(<span class="params">style</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prefix === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">if</span> (prefix === <span class="string">'transform'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> style</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prefix + style.charAt(<span class="number">0</span>).toUpperCase() + style.substr(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="专辑图片旋转动画"><a href="#专辑图片旋转动画" class="headerlink" title="专辑图片旋转动画"></a>专辑图片旋转动画</h2><p>专辑图片动画就是在歌曲播放时专辑图片会自动旋转，本来这个动画应该是比较简单，使用一个animation动画然后用js控制类名即可，但是由于ios的<code>animation-play-state: paused</code>失效，所以无法使用这个方法来控制动画的暂停。</p><h3 id="使用js来实现旋转动画"><a href="#使用js来实现旋转动画" class="headerlink" title="使用js来实现旋转动画"></a>使用js来实现旋转动画</h3><p>如果只是单纯的在歌曲停止时移除animation动画的话会导致再次播放的时候专辑图片的旋转角度跳转回最开始，这样子用户体验极差，所以为了解决这个问题，可以在图片的外部添加一个盒子用来记录暂停时图片旋转的位置。</p><ol><li>依然是通过类名来控制图片的转动。</li><li>当歌曲处于时播放状态时给图片添加animation动画来让图片旋转。</li><li>当歌曲处于停止状态时移除类名，但是在此之前先将img的旋转位置记录下来然后，然图片外面的盒子旋转到这个位置，再移除类名使旋转停止，这样在下一次开始旋转时就不会跳转到开始的位置去了。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cdCls() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.playing &amp;&amp; <span class="keyword">this</span>.$refs.cd) &#123;</span><br><span class="line">    <span class="keyword">let</span> cd = <span class="keyword">this</span>.$refs.cd</span><br><span class="line">    <span class="keyword">let</span> Img = <span class="keyword">this</span>.$refs.cdImg</span><br><span class="line">    <span class="keyword">let</span> cdTransform = getComputedStyle(cd).transform</span><br><span class="line">    <span class="keyword">let</span> ImgTransform = getComputedStyle(Img).transform</span><br><span class="line">    cd.style.transform = cdTransform === <span class="string">'none'</span> ? ImgTransform : cdTransform.concat(<span class="string">' '</span>, ImgTransform)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'play'</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="歌曲播放"><a href="#歌曲播放" class="headerlink" title="歌曲播放"></a>歌曲播放</h2><p>当currentSong改变时就执行播放歌曲的操作，由于qq音乐接口的限制，在获取歌曲列表时获取不到歌曲的播发源，需要通过歌曲的id发送请求获取到每个歌曲的vkey然后进行拼接才能得到歌曲的播放地址。</p><p>在获取播放列表时我一开始是在获取到播放列表之后立即通过循环发送请求获取到列表中每一个歌曲的url，但是后面发现这样做不仅会使用户消耗过多的流量，也会延长歌曲列表的渲染时间。</p><p>后面使用的方案是将获取播放地址的方法定义到每个歌曲对象之中，每个歌曲播放时再去发送请求获取播放地址，并且将播放地址挂载到歌曲对象中，如果歌曲对象已经有了播放地址就不再发送请求，然后将地址设置到audio中。</p><p>在播放歌曲前进行拦截判断和必要的数据初始化，然后再获取播放所需的歌曲url和歌曲的歌词。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">currentSong(newSong, oldSong) &#123;</span><br><span class="line">  <span class="comment">// 检查是否有id</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.currentSong.id) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 检查新的歌曲旧歌曲是否是同一首，如果是就不执行操作</span></span><br><span class="line">  <span class="keyword">if</span> (newSong.id === oldSong.id) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 切换时如果存在歌词，那么先停止歌词的滚动</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.currentLyric) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentLyric.stop()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化歌曲播放时间和当前正在播放歌词</span></span><br><span class="line">  <span class="keyword">this</span>.currentTime = <span class="number">0</span></span><br><span class="line">  <span class="keyword">this</span>.playingLyric = <span class="string">''</span></span><br><span class="line">  clearTimeout(<span class="keyword">this</span>.timer)</span><br><span class="line">  <span class="keyword">this</span>.timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.getCurrentUrl()</span><br><span class="line">    <span class="keyword">this</span>.getCurrentLyric()</span><br><span class="line">  &#125;, <span class="number">20</span>)</span><br><span class="line">&#125;,</span><br><span class="line">getCurrentUrl() &#123;</span><br><span class="line">  <span class="keyword">this</span>.currentSong.getMusicUrl().then(<span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.$refs.audio.setAttribute(<span class="string">'src'</span>, url)</span><br><span class="line">    <span class="keyword">this</span>.$refs.audio.play()</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.songReady = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.setPlayingState(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">this</span>.$refs.noMusic.show()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">getCurrentLyric() &#123;</span><br><span class="line">  <span class="keyword">this</span>.currentSong.getLyric().then(<span class="function"><span class="params">lyric</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentSong.lyric !== lyric) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.currentLyric = <span class="keyword">new</span> Lyric(lyric, <span class="keyword">this</span>.handler)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.playing) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentLyric.play()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentLyric = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.playingLyric = <span class="string">''</span></span><br><span class="line">    <span class="keyword">this</span>.currentNumber = <span class="number">0</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这里对歌词的处理使用的是<code>lyric-parser</code>插件，能够实现歌词的自动轮播功能。</p><p>歌曲的播放和暂停使用playing属性来控制，之后操作歌曲的播放和暂停时就只需要控制playing属性即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">playing(newVal) &#123;</span><br><span class="line">  <span class="keyword">let</span> audio = <span class="keyword">this</span>.$refs.audio</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    newVal ? audio.play() : audio.pause()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">togglePlaying() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.songReady) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.setPlayingState(!<span class="keyword">this</span>.playing)</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.currentLyric) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentLyric.togglePlay()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="歌曲的切换与模式的变化"><a href="#歌曲的切换与模式的变化" class="headerlink" title="歌曲的切换与模式的变化"></a>歌曲的切换与模式的变化</h3><p>歌曲切换一个是由两个操作上一首和下一首，这里为了避免用户切换歌曲过块可以使用一个开关来阻止用户的这个行为，当用户切换歌曲之后将开关关闭，阻止用户进行切换操作，只有当歌曲加载完成能够播放的时候才打开开关允许用户进行切换歌曲的操作，在请求歌曲时或者是播放歌曲时出现错误则弹出信息框提示用户切换歌曲。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">prev() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.songReady) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果歌曲列表只有一首歌调用loop方法，循环播放这一首歌即可</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.playList.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.loop()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断当前播放歌曲是否是第一首歌，如果是就把歌曲切换到最后一首歌，如果不是就切换到第一首歌</span></span><br><span class="line">  <span class="keyword">let</span> nextIndex = <span class="keyword">this</span>.currentIndex &lt;= <span class="number">0</span> ? <span class="keyword">this</span>.playList.length - <span class="number">1</span> : <span class="keyword">this</span>.currentIndex - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 修改当前播放歌曲的</span></span><br><span class="line">  <span class="keyword">this</span>.setCurrentIndex(nextIndex)</span><br><span class="line">  <span class="comment">// 如果播放状态为暂停就修改为播放</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.playing) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setPlayingState(<span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.songReady = <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line">next() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.songReady) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.playList.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.loop()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断当前歌曲是否是最后一首，如果是就切换到第一首，如果不是就切换到下一首</span></span><br><span class="line">  <span class="keyword">let</span> nextIndex = <span class="keyword">this</span>.currentIndex &gt;= <span class="keyword">this</span>.playList.length - <span class="number">1</span> ? <span class="number">0</span> : <span class="keyword">this</span>.currentIndex + <span class="number">1</span></span><br><span class="line">  <span class="keyword">this</span>.setCurrentIndex(nextIndex)</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.playing) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setPlayingState(<span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.songReady = <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line">ready() &#123;</span><br><span class="line">  <span class="keyword">this</span>.songReady = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.playing) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$refs.audio.play()</span><br><span class="line">    <span class="comment">// 添加播放的歌曲到播放历史</span></span><br><span class="line">    <span class="keyword">this</span>.playHistory(<span class="keyword">this</span>.currentSong)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.removeEventListener(<span class="string">'touchstart'</span>, <span class="keyword">this</span>.firstPlay, <span class="literal">false</span>)</span><br><span class="line">&#125;,</span><br><span class="line">error() &#123;</span><br><span class="line">  <span class="keyword">this</span>.songReady = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">this</span>.setPlayingState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">this</span>.$refs.noMusic.show()</span><br><span class="line">&#125;,</span><br><span class="line">ended() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.mode === playMode.loop) &#123;</span><br><span class="line">    <span class="keyword">this</span>.loop()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">loop() &#123;</span><br><span class="line">  <span class="keyword">let</span> audio = <span class="keyword">this</span>.$refs.audio</span><br><span class="line">  audio.currentTime = <span class="number">0</span></span><br><span class="line">  <span class="comment">// chrome50 版本之后不允许pause之后立即调用play，所以需要设置一个延时</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    audio.play()</span><br><span class="line">    <span class="keyword">this</span>.setPlayingState(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentLyric) &#123;</span><br><span class="line">    <span class="comment">// 将歌词跳转到开始</span></span><br><span class="line">      <span class="keyword">this</span>.currentLyric.seek(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">150</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>在实现播放功能时发现一个问题，那就是在ios设备上不允许自动播放音频的，必须通过用户的行为才能触发音频的播放功能，为了解决这个问题可以在vue的created钩子函数中监听一个touchstart事件，在这个事件中触发播放操作，在第一首歌能够播放之后再将这个事件移除，即可实现自动播放功能。</p><p>模式的切换，播放器一共支持3种模式的播放，顺序播放、乱序播放、单曲循环。可以使用changeMode函数来实现mode的改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">changeMode() &#123;</span><br><span class="line">  <span class="comment">// 计算出mode改变后的值</span></span><br><span class="line">  <span class="keyword">let</span> mode = (<span class="keyword">this</span>.mode + <span class="number">1</span>) % <span class="number">3</span></span><br><span class="line">  <span class="comment">// 改变mode的值</span></span><br><span class="line">  <span class="keyword">this</span>.setPlayMode(mode)</span><br><span class="line">  <span class="keyword">let</span> list = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.mode === playMode.random) &#123;</span><br><span class="line">    <span class="comment">// 如果mode是乱序播放，则调用shuffle函数打乱当前播放列表</span></span><br><span class="line">    <span class="comment">// 这个函数是一个工具函数定义在util.js中</span></span><br><span class="line">    list = shuffle(<span class="keyword">this</span>.sequenceList)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是乱序播放则将播放列表变成顺序播放的列表</span></span><br><span class="line">    list = <span class="keyword">this</span>.sequenceList</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当播放列表改变时当前歌曲的index也会改变，</span></span><br><span class="line">  <span class="comment">// 所以需要修改一下currentIndex让它和当前歌曲的index保持一致</span></span><br><span class="line">  <span class="keyword">this</span>.resetCurrentIndex(list)</span><br><span class="line">  <span class="comment">// 修改播放列表</span></span><br><span class="line">  <span class="keyword">this</span>.setPlayList(list)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 乱序函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomInt</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//获取一个从最小值到最大值的随机整数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>) + min)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _arr = arr.slice()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; _arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = getRandomInt(<span class="number">0</span>, i)</span><br><span class="line">    <span class="keyword">let</span> k = _arr[j]</span><br><span class="line">    _arr[j] = _arr[i]</span><br><span class="line">    _arr[i] = k </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进度条控制歌曲播放功能"><a href="#进度条控制歌曲播放功能" class="headerlink" title="进度条控制歌曲播放功能"></a>进度条控制歌曲播放功能</h3><p>这一部分实现的是进度条控制歌曲进度的功能，分别有拖拽进度条btn歌曲进度跳转到相应的位置播放歌曲，点击进度条改变歌曲播放进度，使用进度条显示歌曲播放的时间和进度。由于这里功能比较多，所以将进度条组件单独抽离出来封装成一个基础的组件。</p><h4 id="进度条的进度展示"><a href="#进度条的进度展示" class="headerlink" title="进度条的进度展示"></a>进度条的进度展示</h4><p>由于进度条组件是一个基础的组件，所以进度应该是由使用它的组件来提供的，这里使用进度条的组件就就是播放器组件，所以歌曲播放进度需要在播放器组件中计算出来并传到进度条组件中。计算进度的方法非常的简单，使用当前播放时间除以播放从时间即可。</p><p>获取到歌曲播放进度之后就可以在进度条组件中，监视进度数据的变化，以此来改变进度条的长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在player组件中计算出当前播发百分比，并传递给进度条组件</span></span><br><span class="line">percent() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.currentTime / <span class="keyword">this</span>.currentSong.duration</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在进度条组件中使用percent来展示进度条</span></span><br><span class="line">watch: &#123;</span><br><span class="line">  percent(newVal) &#123;</span><br><span class="line">    <span class="comment">// 传入的歌曲播放进度必须大于0，当用户在修改歌曲播放进度时不改变进度条，进度条外部盒子的宽度必须大于0</span></span><br><span class="line">    <span class="keyword">if</span> (newVal &gt; <span class="number">0</span> &amp;&amp; !<span class="keyword">this</span>.touch.initiated &amp;&amp; <span class="keyword">this</span>.$refs.progressBar.clientWidth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 进度条的从长度应该是进度条外部盒子的长度减去进度条最前面圆形的按钮的长度。</span></span><br><span class="line">      <span class="keyword">const</span> barWidth = <span class="keyword">this</span>.$refs.progressBar.clientWidth - progressBtnWidth</span><br><span class="line">      <span class="comment">// 计算出进度条的长度，这里Math.min()的作用是，</span></span><br><span class="line">      <span class="comment">//当歌曲切换之后而歌曲总时长变化了，而当前歌曲的播放时间还没有变化，</span></span><br><span class="line">      <span class="comment">// 就会出现percent大于1的情况，所以使用这个函数避免offsetWidth大于barWidth的情况</span></span><br><span class="line">      <span class="keyword">let</span> offsetWidth = barWidth * <span class="built_in">Math</span>.min(newVal, <span class="number">1</span>)</span><br><span class="line">      <span class="comment">// 修改进度条长度，并且设置btn的偏移量</span></span><br><span class="line">      <span class="keyword">this</span>._offset(offsetWidth)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">_offset(offsetWidth) &#123;</span><br><span class="line">  <span class="keyword">this</span>.$refs.progress.style.width = offsetWidth + <span class="string">'px'</span></span><br><span class="line">  <span class="keyword">this</span>.$refs.btn.style[transform] = <span class="string">`translate3d(<span class="subst">$&#123;offsetWidth&#125;</span>px,0,0)`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="滑动进度条btn控制歌曲播放时间"><a href="#滑动进度条btn控制歌曲播放时间" class="headerlink" title="滑动进度条btn控制歌曲播放时间"></a>滑动进度条btn控制歌曲播放时间</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用滑动事件来计算出新的播放进度,并传递给外部</span></span><br><span class="line">progressTouchStart(e) &#123;</span><br><span class="line">  <span class="comment">// 滑动开始时建立一个滑动开始的标识符</span></span><br><span class="line">  <span class="keyword">this</span>.touch.initiated = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 记录滑动开始时手指的位置</span></span><br><span class="line">  <span class="keyword">this</span>.touch.startX = e.touches[<span class="number">0</span>].pageX</span><br><span class="line">  <span class="comment">// 记录滑动开始时进度条的长度</span></span><br><span class="line">  <span class="keyword">this</span>.touch.left = <span class="keyword">this</span>.$refs.progress.clientWidth</span><br><span class="line">&#125;,</span><br><span class="line">progressTouchMove(e) &#123;</span><br><span class="line">  <span class="comment">// 判断是否触发过touchstart事件。</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.touch.initiated) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算出手指移动的距离</span></span><br><span class="line">  <span class="keyword">const</span> deltaX = e.touches[<span class="number">0</span>].pageX - <span class="keyword">this</span>.touch.startX</span><br><span class="line">  <span class="comment">// 获取进度条应该修改的长度，首先这里必须保证这个长度是大于等于0的所以使用Math.max函数，之后必须保证长度必须小于等于进度条盒子的长度</span></span><br><span class="line">  <span class="keyword">let</span> offsetWidth = <span class="built_in">Math</span>.min(<span class="keyword">this</span>.$refs.progressBar.clientWidth - progressBtnWidth, <span class="built_in">Math</span>.max(<span class="number">0</span>, deltaX + <span class="keyword">this</span>.touch.left))</span><br><span class="line">  <span class="comment">// 修改进度条和btn的偏移</span></span><br><span class="line">  <span class="keyword">this</span>._offset(offsetWidth)</span><br><span class="line">  <span class="comment">// 将进度条改变这个传递到外部的函数，由于在移动滑动进度条时只需要修改歌曲的时间，而不需要修改歌曲的播放的位置，所以使用一个标识符来区分这两个事件</span></span><br><span class="line">  <span class="keyword">this</span>._triggerPercent(<span class="literal">true</span>)</span><br><span class="line">&#125;,</span><br><span class="line">progressEnd(e) &#123;</span><br><span class="line">  <span class="comment">// 拖拽完成之后修改正在滑动标识符让进度条正常运行</span></span><br><span class="line">  <span class="keyword">this</span>.touch.initiated = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 将进度改变传递给外部</span></span><br><span class="line">  <span class="keyword">this</span>._triggerPercent()</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// player组件接受到新的播放进度并进行相应的处理</span></span><br><span class="line">precentBarChange(percent) &#123;</span><br><span class="line">  <span class="comment">// 接受新的歌曲进度，并计算出歌曲播放的时间</span></span><br><span class="line">  <span class="keyword">const</span> currentTime = <span class="keyword">this</span>.currentSong.duration * percent</span><br><span class="line">  <span class="comment">// 修改当前歌曲的播放时间</span></span><br><span class="line">  <span class="keyword">this</span>.$refs.audio.currentTime = currentTime</span><br><span class="line">  <span class="comment">// 如果歌曲处于暂停状态，就播放歌曲</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.playing) &#123;</span><br><span class="line">    <span class="keyword">this</span>.togglePlaying()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 让自动更新播放时间的update函数正常工作</span></span><br><span class="line">  <span class="keyword">this</span>.progressMove = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 修改歌词展示位置</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.currentLyric) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentLyric.seek(currentTime * <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">currentTimeChange(percent) &#123;</span><br><span class="line">  <span class="comment">// 拖动进度条时同步当前播放时间</span></span><br><span class="line">  <span class="keyword">this</span>.currentTime = <span class="keyword">this</span>.currentSong.duration * percent</span><br><span class="line">  <span class="comment">// 阻止自动更新当前播放时间</span></span><br><span class="line">  <span class="keyword">this</span>.progressMove = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 修改歌词展示位置</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.currentLyric) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentLyric.seek(<span class="keyword">this</span>.currentTime * <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 在歌曲播放的时候自动获取当前播放时间，并使用一个变量将其展示出来</span></span><br><span class="line">update(e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.progressMove) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.playing) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setPlayingState(<span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.currentTime = e.target.currentTime</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>点击进度条修改歌曲播放位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">progressClick(e) &#123;</span><br><span class="line">  <span class="comment">// 点击进度条时获取到点击时的位置然后计算出应该偏移的长度</span></span><br><span class="line">  <span class="keyword">const</span> rect = <span class="keyword">this</span>.$refs.progressBar.getBoundingClientRect()</span><br><span class="line">  <span class="keyword">const</span> offsetWidth = e.pageX - rect.left</span><br><span class="line">  <span class="comment">// 当点击到小方块时e.offsetX的值是不对的，所以不能用这个</span></span><br><span class="line">  <span class="comment">// this._offset(e.offsetX)</span></span><br><span class="line">  <span class="keyword">this</span>._offset(offsetWidth)</span><br><span class="line">  <span class="keyword">this</span>._triggerPercent()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="歌曲专辑图片和歌曲歌词显示的切换"><a href="#歌曲专辑图片和歌曲歌词显示的切换" class="headerlink" title="歌曲专辑图片和歌曲歌词显示的切换"></a>歌曲专辑图片和歌曲歌词显示的切换</h2><p>这一部分的效果依然是使用touch事件来实现的，通过计算滑动的距离与比例来设置歌词部分的偏移与歌曲专辑图片的透明度来实现切换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">middleTouchStart(e) &#123;</span><br><span class="line">  <span class="comment">// 设置一个滑动开始的标识符</span></span><br><span class="line">  <span class="keyword">this</span>.initiated = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 记录滑动开始时手指的位置</span></span><br><span class="line">  <span class="keyword">let</span> touch = e.touches[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">this</span>.touch.startX = touch.pageX</span><br><span class="line">  <span class="keyword">this</span>.touch.startY = touch.pageY</span><br><span class="line">  <span class="comment">// 用来判断是否是移动</span></span><br><span class="line">  <span class="keyword">this</span>.touch.move = <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line">middleTouchMove(e) &#123;</span><br><span class="line">  <span class="comment">// 判断是否触发过touchStart事件</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.initiated) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 计算出滑动的距离</span></span><br><span class="line">  <span class="keyword">const</span> touch = e.touches[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> deltaX = touch.pageX - <span class="keyword">this</span>.touch.startX</span><br><span class="line">  <span class="keyword">const</span> deltaY = touch.pageY - <span class="keyword">this</span>.touch.startY</span><br><span class="line">  <span class="comment">// 当竖直方向上的滑动距离大于水平方向上的滑动距离时，可能是用户在滑动歌词，就直接退</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(deltaX) &lt; <span class="built_in">Math</span>.abs(deltaY)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修改移动标识符</span></span><br><span class="line">  <span class="keyword">this</span>.touch.move = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 当当前所处位置在cd时，那么位置偏移为0.如果不是那就是在歌词部分，位置偏移就是-win</span></span><br><span class="line">  <span class="keyword">const</span> innerWidth = -<span class="built_in">window</span>.innerWidth</span><br><span class="line">  <span class="comment">// 获取到当前的位置</span></span><br><span class="line">  <span class="keyword">const</span> left = <span class="keyword">this</span>.currentShow === <span class="string">'cd'</span> ? <span class="number">0</span> : innerWidth</span><br><span class="line">  <span class="comment">// 由于只能向左偏移所以偏移量一定是负的小于0，而偏移的位置最多就只能是innerWidth</span></span><br><span class="line">  <span class="keyword">const</span> offsetWidth = <span class="built_in">Math</span>.min(<span class="number">0</span>, <span class="built_in">Math</span>.max(innerWidth, left + deltaX))</span><br><span class="line">  <span class="comment">// 计算出偏移的比例</span></span><br><span class="line">  <span class="keyword">this</span>.touch.precent = <span class="built_in">Math</span>.abs(offsetWidth / innerWidth)</span><br><span class="line">  <span class="comment">// 设置lyricList的偏移</span></span><br><span class="line">  <span class="keyword">this</span>.$refs.lyricList.$el.style[transform] = <span class="string">`translate3d(<span class="subst">$&#123;offsetWidth&#125;</span>px,0,0)`</span></span><br><span class="line">  <span class="keyword">this</span>.$refs.lyricList.$el.style[transitionDuration] = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 设置专辑图片的透明度，偏移比例越大就越透明</span></span><br><span class="line">  <span class="keyword">this</span>.$refs.middleL.style.opacity = <span class="number">1</span> - <span class="keyword">this</span>.touch.precent</span><br><span class="line">&#125;,</span><br><span class="line">middleTouchEnd() &#123;</span><br><span class="line">  <span class="comment">// 判断是否有移动</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.touch.move) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> offsetWidth</span><br><span class="line">  <span class="keyword">let</span> opacity</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.currentShow === <span class="string">'cd'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果当前显示的是cd，判断偏移比例是否大于0.1</span></span><br><span class="line">    <span class="comment">// 如果大于0.1需要将cd隐藏显示lyric</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.touch.precent &gt; <span class="number">0.1</span>) &#123;</span><br><span class="line">      <span class="comment">// offsetWidth变量是用来控制lyric的偏移量来控制lyric的显示和隐藏</span></span><br><span class="line">      offsetWidth = -<span class="built_in">window</span>.innerWidth</span><br><span class="line">      <span class="keyword">this</span>.currentShow = <span class="string">'lyric'</span></span><br><span class="line">      <span class="comment">// opactiy是设置cd的透明度来控制cd的显示和隐藏</span></span><br><span class="line">      opacity = <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      offsetWidth = <span class="number">0</span></span><br><span class="line">      opacity = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前处于lyric部分，那么precent&lt;0.9实际上就是偏移量大于0.1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.touch.precent &lt; <span class="number">0.9</span>) &#123;</span><br><span class="line">      offsetWidth = <span class="number">0</span></span><br><span class="line">      <span class="keyword">this</span>.currentShow = <span class="string">'cd'</span></span><br><span class="line">      opacity = <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      offsetWidth = -<span class="built_in">window</span>.innerWidth</span><br><span class="line">      opacity = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> time = <span class="number">300</span></span><br><span class="line">  <span class="comment">// 将样式设置到相应的元素上去</span></span><br><span class="line">  <span class="keyword">this</span>.$refs.lyricList.$el.style[transform] = <span class="string">`translate3d(<span class="subst">$&#123;offsetWidth&#125;</span>px,0,0)`</span></span><br><span class="line">  <span class="keyword">this</span>.$refs.lyricList.$el.style[transitionDuration] = <span class="string">`<span class="subst">$&#123;time&#125;</span>ms`</span></span><br><span class="line">  <span class="keyword">this</span>.$refs.middleL.style.opacity = opacity</span><br><span class="line">  <span class="keyword">this</span>.$refs.middleL.style[transitionDuration] = <span class="string">`<span class="subst">$&#123;time&#125;</span>ms`</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;音乐播放器内核&quot;&gt;&lt;a href=&quot;#音乐播放器内核&quot; class=&quot;headerlink&quot; title=&quot;音乐播放器内核&quot;&gt;&lt;/a&gt;音乐播放器内核&lt;/h1&gt;&lt;p&gt;播放器组件是本次项目中的重点和难点，逻辑复杂，基本实现音乐播放器的播放功能。&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
      <category term="vue.js学习笔记" scheme="http://yoursite.com/categories/vue-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>vue音乐播放器项目</title>
    <link href="http://yoursite.com/2018/07/25/vue-music/"/>
    <id>http://yoursite.com/2018/07/25/vue-music/</id>
    <published>2018-07-24T16:00:00.000Z</published>
    <updated>2018-08-14T04:57:03.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><p>该项目是一个具备完善功能的音乐app，所有数据都通过抓取接口数据动态获取，希望能够通过这一个项目能够更深的体会模块化编程，以及更加熟练的使用vue。</p><h2 id="数据的获取"><a href="#数据的获取" class="headerlink" title="数据的获取"></a>数据的获取</h2><p>由于这一次的数据不再是本地的假数据了，那么第一个需要解决的问题就是获取项目中所需要的数据，本项目的数据全部抓取自qq音乐，那么接下来就让我们来看看如何获取接口的数据。</p><p>首先一般接口数据的获取方法分为<code>jsonp</code>和后端代理获取数据，我们可以通过查看网站自身是如何获取数据的，一般<code>jsonp</code>获取数据的请求可以在Network中的JS选项中查看，而一般需要后端代理获取数据的就是XHR请求。</p><h3 id="jsonp数据获取"><a href="#jsonp数据获取" class="headerlink" title="jsonp数据获取"></a>jsonp数据获取</h3><p>jsonp是获取跨域数据最常见的一种方法，它的原理也是非常的简单，由于同源（“协议+域名+端口”相同才为同源）策略会阻止来自不同的域的ajax请求，所以为了解决这个问题我们就需要找到一个不受限制的请求来获取资源，而在网页中<code>&lt;script&gt;</code>标签在获取资源时是不受到同源策略的影响的，而<code>jsonp</code>就是利用这个特点来获取数据的，下面是jsonp实现的一个基本步骤：</p><ol><li>在代码中动态创建一个script标签。</li><li>然后把标签的src属性设置为接口的名字。</li><li>在src中还要应该传入一个callback函数名，并且创建这个callback函数。</li><li>把创建的script标签添加到页面中，这个时候就会对接口发起请求了。</li><li>而服务端会返回的是一段js代码，当请求到页面之后会自动执行这些代码。</li><li>由于我们在src中传入了一个callback函数名，只要后端返回的代码中调用了callback函数，并且将我们需要的数据进行以参数的形式传递给这个函数，那么我们也就可以拿到数据了。</li></ol><p>原生实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传参并指定回调执行函数为onBack</span></span><br><span class="line">    script.src = <span class="string">'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack'</span>;</span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调执行函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onBack</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">    &#125;</span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"> /</span><span class="regexp">/ 服务端返回如下（返回时就会执行这个函数）</span></span><br><span class="line"><span class="regexp"> onBack(&#123;"status": true, "user": "admin"&#125;)</span></span><br></pre></td></tr></table></figure><h4 id="使用jsonp"><a href="#使用jsonp" class="headerlink" title="使用jsonp"></a>使用jsonp</h4><p>前面介绍了jsonp的基本实现原理，但是当然我在项目中并不会直接使用原生的jsonp来进行操作，这里我使用一个名叫<code>jsonp</code>的第三方库，但是由于这个库并没有实现promise，所以可以对他进行一些改造。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> originJSONP <span class="keyword">from</span> <span class="string">'jsonp'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, data, option</span>) </span>&#123;</span><br><span class="line">  url += (url.indexOf(<span class="string">'?'</span>) &lt; <span class="number">0</span> ? <span class="string">'?'</span> : <span class="string">'&amp;'</span>) + param(data)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    originJSONP(url, option, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        resolve(data)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">param</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="string">''</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = data[k] === <span class="literal">undefined</span> ? <span class="string">''</span> : data[k]</span><br><span class="line">    url += <span class="string">`&amp;<span class="subst">$&#123;k&#125;</span>=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(value)&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> url ? url.substring(<span class="number">1</span>) : <span class="string">''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先引入json的库，然后在他原来的基础上进行进一步封装。</p><p>原来的<code>originJSONP</code>函数接受三个参数，url， option，callback，传给后端的数据需要手动拼接到url后面，为了使用方便新的jsonp函数我让他的url和数据分离开来，在jsonp函数内部进行拼接。在这里我定义了一个拼接数据的方法，这个方法只在内部使用所以不需要传递出去，这个方法接受一个对象，然后对这个对象进行遍历，首先检查每一项的值是否为undefined，如果是就把它变成空字符串，然后将数据通过<code>&amp;键=值</code>的格式拼接到我们的临时变量之中，最后检查临时变量中是否有值，如果有就把它的第一个<code>&amp;</code>符号去掉然后返回找个值，如果没有值返回空字符串。然后到jsonp函数中调用这个函数，将传递过来的data拼接到url的后面，这里要注意在拼接的时候的<code>?</code>和<code>&amp;</code>。</p><h3 id="后端代理获取数据"><a href="#后端代理获取数据" class="headerlink" title="后端代理获取数据"></a>后端代理获取数据</h3><p>如果网站在请求数据时要验证请求头中的<code>referer</code>和<code>host</code>的时候前端无法获取到数据了，因为我们在前端是无法修改请求头中的信息的，这个时候就需要利用本地的后端服务器去获取数据，然后通过接口传递给前端。后端代理的原理就是把请求头中的<code>referer</code>和<code>host</code>设置成源网站一样的就可以获取到数据了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/api/getDiscList'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">'https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg'</span></span><br><span class="line">  axios.get(url, &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">      referer: <span class="string">'https://c.y.qq.com/'</span>,</span><br><span class="line">      host: <span class="string">'c.y.qq.com'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    params: req.query</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    res.json(response.data)</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="轮播图组件的封装"><a href="#轮播图组件的封装" class="headerlink" title="轮播图组件的封装"></a>轮播图组件的封装</h2><p>轮播图在项目中是非常常见的，为了在项目中能够多次复用，可以把轮播图作为一个单独的组件抽离出。本项目使用<code>better-scroll</code>来实现区域滑动的操作，所以轮播图组件也是基于<code>better-scroll</code>来实现。</p><h3 id="基本的布局"><a href="#基本的布局" class="headerlink" title="基本的布局"></a>基本的布局</h3><p>在轮播图组件中利用vue提供的<code>&lt;slot&gt;</code>标签来实现在调用时再来填充轮播图内部的内容，轮播图的宽度也应该在调用时决定。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"slider"</span> <span class="attr">ref</span>=<span class="string">"slider"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"slider-group"</span> <span class="attr">ref</span>=<span class="string">"sliderGroup"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dots"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in dots"</span> <span class="attr">:key</span>=<span class="string">"index"</span> <span class="attr">class</span>=<span class="string">"dot"</span> <span class="attr">:class</span>=<span class="string">"&#123;'active': currentPageIndex === index&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">@import url("../../common/less/variable.less");</span></span><br><span class="line"><span class="undefined">.slider &#123;</span></span><br><span class="line"><span class="undefined">  min-height: 1px;</span></span><br><span class="line"><span class="undefined">  .slider-group &#123;</span></span><br><span class="line"><span class="undefined">    position: relative;</span></span><br><span class="line"><span class="undefined">    overflow: hidden;</span></span><br><span class="line"><span class="undefined">    white-space: nowrap;</span></span><br><span class="line"><span class="undefined">    .slider-item &#123;</span></span><br><span class="line"><span class="undefined">      float: left;</span></span><br><span class="line"><span class="undefined">      text-align: center;</span></span><br><span class="line"><span class="undefined">      box-sizing: border-box;</span></span><br><span class="line"><span class="undefined">      overflow: hidden;</span></span><br><span class="line"><span class="undefined">      a &#123;</span></span><br><span class="line"><span class="undefined">        display: block;</span></span><br><span class="line"><span class="undefined">        width: 100%;</span></span><br><span class="line"><span class="undefined">        overflow: hidden;</span></span><br><span class="line"><span class="undefined">        text-decoration: none;</span></span><br><span class="line"><span class="undefined">        img &#123;</span></span><br><span class="line"><span class="undefined">          display: block;</span></span><br><span class="line"><span class="undefined">          width: 100%;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  .dots &#123;</span></span><br><span class="line"><span class="undefined">    position: absolute;</span></span><br><span class="line"><span class="undefined">    bottom: 12px;</span></span><br><span class="line"><span class="undefined">    right: 0;</span></span><br><span class="line"><span class="undefined">    left: 0;</span></span><br><span class="line"><span class="undefined">    text-align: center;</span></span><br><span class="line"><span class="undefined">    font-size: 0;</span></span><br><span class="line"><span class="undefined">    .dot &#123;</span></span><br><span class="line"><span class="undefined">      width: 8px;</span></span><br><span class="line"><span class="undefined">      display: inline-block;</span></span><br><span class="line"><span class="undefined">      height: 8px;</span></span><br><span class="line"><span class="undefined">      border-radius: 50%;</span></span><br><span class="line"><span class="undefined">      background-color: @color-text-l;</span></span><br><span class="line"><span class="undefined">      margin: 0 4px;</span></span><br><span class="line"><span class="undefined">      &amp;.active &#123;</span></span><br><span class="line"><span class="undefined">        width: 20px;</span></span><br><span class="line"><span class="undefined">        border-radius: 5px;</span></span><br><span class="line"><span class="undefined">        background-color: @color-text-ll;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件的业务逻辑"><a href="#组件的业务逻辑" class="headerlink" title="组件的业务逻辑"></a>组件的业务逻辑</h3><h4 id="轮播图功能的控制"><a href="#轮播图功能的控制" class="headerlink" title="轮播图功能的控制"></a>轮播图功能的控制</h4><p>首先我们需要考虑到轮播图的功能，让我们在调用的时候通过一些参数来控制轮播图的功能，一般轮播图主要有：是否无缝轮播、是否自动播放、以及轮播间隔、这么几个选项，那么就可以在组件的props中定义一些变量来控制轮播图的功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  loop: &#123;</span><br><span class="line">    type: <span class="built_in">Boolean</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  autoplay: &#123;</span><br><span class="line">    type: <span class="built_in">Boolean</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  interval: &#123;</span><br><span class="line">    type: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="number">1000</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="轮播图的初始化"><a href="#轮播图的初始化" class="headerlink" title="轮播图的初始化"></a>轮播图的初始化</h4><h5 id="slider-group宽度的初始化"><a href="#slider-group宽度的初始化" class="headerlink" title="slider-group宽度的初始化"></a>slider-group宽度的初始化</h5><p>由于在轮播图片的大小需要在调用时决定，所以<code>slider-group</code>的宽度就不能够写死，需要在使用组件时通过js去动态的设置<code>slider-group</code>的宽度。<code>slider-group</code>的宽度主要受到这几个方面的影响：</p><ol><li>单张轮播图片的大小</li><li>轮播图片的数量</li><li>是否无缝轮播（如果无缝轮播那么需要在首尾个添加一张图片）</li></ol><p>根据这些条件可以在methods中定义一个初始化slider-group宽度的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_setSliderWidth() &#123;</span><br><span class="line">  <span class="keyword">this</span>.children = <span class="keyword">this</span>.$refs.sliderGroup.children</span><br><span class="line">  <span class="keyword">let</span> width = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> sliderWidth = <span class="keyword">this</span>.$refs.slider.clientWidth</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.children.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> child = <span class="keyword">this</span>.children[i]</span><br><span class="line">    addClass(child, <span class="string">'slider-item'</span>)</span><br><span class="line">    child.style.width = sliderWidth + <span class="string">'px'</span></span><br><span class="line">    width += sliderWidth</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.loop) &#123;</span><br><span class="line">    width += <span class="number">2</span> * sliderWidth</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.$refs.sliderGroup.style.width = width + <span class="string">'px'</span></span><br></pre></td></tr></table></figure><p>上面这个方法首先获取到在调用时添加的<code>slider-item</code>元素，定义一个<code>width</code>变量来储存<code>slider-group</code>的宽度，获取到<code>slider</code>的宽度，这里<code>slider</code>的宽度是由在调用时为<code>slider</code>组件的父元素的宽度，所以一般在调用时需要在<code>&lt;slider&gt;</code>标签外添加一个盒子来控制整个<code>slider</code>组件的宽度。然后遍历<code>slider-item</code>数组，为每个<code>slider-item</code>添加类名，应用上事先设置好的样式，这样就不需要在调用时去添加类名了，方便操作，为每一个<code>slider-item</code>添加宽度，宽度应该和<code>slider</code>的宽度一致，每遍历一次<code>width</code>就加上一个<code>sliderWidth</code>，然后判断是否是无缝滚动，如果是无缝滚动就在加上两倍的<code>sliderWidth</code>，最后设置<code>slider-group</code>的宽度即可。</p><h4 id="slider的初始化和dots的初始化"><a href="#slider的初始化和dots的初始化" class="headerlink" title="slider的初始化和dots的初始化"></a>slider的初始化和dots的初始化</h4><p>slider的初始化只需要根据<code>better-scroll</code>文档中的配置进行相应的配置即可，dots初始化也比较简单，通过在dots<code>data</code>中定义一个数组，dots的数量由数组的长度决定，然后根据<code>slider-item</code>的数量来决定dots的长度即可。具体代码就不贴出来了，都可以从官方文档中找到。</p><h2 id="歌手页面"><a href="#歌手页面" class="headerlink" title="歌手页面"></a>歌手页面</h2><p>歌手页面主要的业务有获取并渲染歌手列表页面，同时给歌手列表页面加上相应的交互效果。通过二级路由展示歌手详细的歌曲列表。</p><h3 id="获取数据并对数据进行处理"><a href="#获取数据并对数据进行处理" class="headerlink" title="获取数据并对数据进行处理"></a>获取数据并对数据进行处理</h3><p>数据的获取依然是抓取qq音乐的接口，但是抓取过来之后就会发现数据的格式和我们需要的格式并不一样，这也是在日常开发中非常常见的问题，那么我们就需要对后端返回的数据进行进一步的加工。</p><h4 id="设计singer的数据格式，并创建一个singer类"><a href="#设计singer的数据格式，并创建一个singer类" class="headerlink" title="设计singer的数据格式，并创建一个singer类"></a>设计singer的数据格式，并创建一个singer类</h4><p>为了能够更好的使用数据，我们利用es6提供的class关键字来定义一个singer的类，为了方便维护可以在common文件夹中的js文件夹中创建一个<code>singer.js</code>的文件，来管理singer。我们的singer的数据结构比较简单只需要id、name、avatar即可。下面是singer类的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Singer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(&#123;id, name&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.avatar = <span class="string">`https://y.gtimg.cn/music/photo_new/T001R300x300M000<span class="subst">$&#123;id&#125;</span>.jpg?max_age=2592000`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设计一个格式化数据的函数"><a href="#设计一个格式化数据的函数" class="headerlink" title="设计一个格式化数据的函数"></a>设计一个格式化数据的函数</h4><p>这个函数的具体实现思想也是比较简单，就是通过遍历后端返回过来的数据来取出我们需要的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">_normalizeSinger(list) &#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;</span><br><span class="line">    hot: &#123;</span><br><span class="line">      title: HOT_NAME,</span><br><span class="line">      items: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  list.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; HOT_SINGER_LEN) &#123;</span><br><span class="line">      map.hot.items.push(<span class="keyword">new</span> Singer(&#123;</span><br><span class="line">        id: item.Fsinger_mid,</span><br><span class="line">        name: item.Fsinger_name</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> key = item.Findex</span><br><span class="line">    <span class="keyword">if</span> (!map[key]) &#123;</span><br><span class="line">      map[key] = &#123;</span><br><span class="line">        title: key,</span><br><span class="line">        items: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map[key].items.push(<span class="keyword">new</span> Singer(&#123;</span><br><span class="line">      id: item.Fsinger_mid,</span><br><span class="line">      name: item.Fsinger_name</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 所得到的对象是无序的需要处理之后变成一个有序的数组。</span></span><br><span class="line">  <span class="keyword">let</span> hot = []</span><br><span class="line">  <span class="keyword">let</span> ret = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> map) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = map[key]</span><br><span class="line">    <span class="keyword">if</span> (value.title.match(<span class="regexp">/[a-zA-Z]/</span>)) &#123;</span><br><span class="line">      ret.push(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.title === HOT_NAME) &#123;</span><br><span class="line">      hot.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ret.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.title.charCodeAt(<span class="number">0</span>) - b.title.charCodeAt(<span class="number">0</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> hot.concat(ret)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ol><li>首先定义一个map对象用来储存格式化后的数据，在展示的时候我默认将前10条放到一个热门的分类中，所以在定义map对象时我们先在其中定义一个hot对象，然后取前10条数据，这里我的热门数据的条数专门定义了一个常量来储存，这个是为了更加的语义化，也为了更加方便的维护代码，我们在开发过程中的一些特定的限制数字都可以使用常量来管理。</li><li>接着按照首字母的不同来区分歌手，在源数据中每个歌手的<code>Findex</code>保存了歌手的首字母，我们就可以将其取出来，判断如果在map中还没有以这个字母为键的对象的话，就在map对象中新建一个以这个字母为键的对象。如果有了这个属性，那么就通过实例化singer对象将有用信息取出，并添加到对象中。</li><li>这样子取出来的数据还是一个无序的对象，我们接着需要将它按照字母顺序排列，在排列之前我们首先需要把无序的对象变成数组，通过遍历map将对象取出储存到数组中，这里为了保证每个对象的title都是字母，需要对数据进行一个简单的判断，由于hot类型的title特殊，所以我们单独处理。</li><li>最后使用数组的sort方法将按照字母分类的数组进行排序，然后将排序之后的数组连接到hot数组之中。</li></ol><h3 id="歌手列表list-view组件"><a href="#歌手列表list-view组件" class="headerlink" title="歌手列表list-view组件"></a>歌手列表list-view组件</h3><p>list-view组件是一个用于展示歌手列表的基础组件，所以把list-view组件放到base目录之下。list-view组件主要实现的效果就是歌手姓名的首字母与右边字母列表的一个联动效果，首先按照歌手的姓名首字母分类渲染到页面中，当左边滚动到不同字母的歌手时，右边的字母列表也会跟着实现相应的字母高亮。</p><h4 id="主要的实现思路"><a href="#主要的实现思路" class="headerlink" title="主要的实现思路"></a>主要的实现思路</h4><h5 id="右侧列表"><a href="#右侧列表" class="headerlink" title="右侧列表"></a>右侧列表</h5><ol><li>通过监听<code>touchstart</code>和<code>touchmove</code> 事件来实现交互，由于右侧列表中的dom元素比较的多，所以我将事件绑定到导航列表的最外层元素上，给列表中每个元素添加一个自定义属性<code>data-index</code>，在触发事件时通过判断<code>data-index</code>的值来确定事件源。左侧列表的跳转通过better-scroll的api实现。</li><li>当touchstart时将手指的位置记录下来，并且跳转到当前手指触摸到的元素上去。</li><li>touchmove时，利用touchstart和touchmove时的距离除以每一个字母元素的高度来计算出当前手指处在什么位置上，并跳转到该元素对应的位置。</li></ol><h5 id="左侧列表"><a href="#左侧列表" class="headerlink" title="左侧列表"></a>左侧列表</h5><ol><li>当左侧列表移动的同时右侧列表的高亮也要同步。</li><li>需要先把左侧列表每一个分类的高度储存到一个数组中。</li><li>获取到当前滑动的位置，然后和上一步中分类列表的高度数组去比较，计算出当前滑动的位置处于的分类。然后再设置右侧列表相对应的高亮。</li></ol><h2 id="歌曲列表组件"><a href="#歌曲列表组件" class="headerlink" title="歌曲列表组件"></a>歌曲列表组件</h2><p>歌曲列表组件主要的难点在于列表向上滑动时，在开始的时候整个列表都向上滑动，当滑动到接近顶部时，列表背景不再向上滑动，只有歌曲列表进行滑动。这么一个类似原生音乐app的交互效果。</p><h3 id="效果实现的主要思路"><a href="#效果实现的主要思路" class="headerlink" title="效果实现的主要思路"></a>效果实现的主要思路</h3><ol><li>要实现这个效果首先要做的就是在布局上要有一个合理的设计。这里我将歌曲列表的盒子固定定位到底部，这个盒子限制高度但是不设置溢出隐藏，盒子里面的歌曲列表使用scroll组件实现区域滚动。</li><li>在列表向上滚动的时候背景也需要向上滚动，这个背景可以使用一个单独的背景div，背景div的高度和歌曲列表盒子的高度相等，它不是固定定位，而是会随着歌曲列表的上滑一起移动。这样就实现了歌曲上滑时背景也一起上滑的效果。</li><li>当滑动到接近顶部的位置的时候就让背景div停止移动，但是这个时候如果再向上滑动的话歌曲列表就会覆盖到专辑图片上。</li><li>为了解决背景div停止移动，歌曲列表有个溢出的现象可以提高专辑图片div的层级，让它的层级高于歌曲列表，这样上滑的歌曲列表就不会溢出了，这个时候需要注意如果只是提高专辑图片div的层级，会出现整个和专辑图片接触的歌曲列表都会覆盖。</li><li>为了解决上面的问题，可以在设置层级时，同时将专辑图片div的高度变小，这样子就只会覆盖掉溢出的歌曲列表了，最后还要注意，如果专辑图片div高度变小，那么里面的随机播放列表按钮也就会移动上来，所以在改变高度的时候还需要将随机播放按钮隐藏掉。</li></ol><p>具体代码实现，这里所有的操作都是在滑动位置变化时进行的，所以下面的函数是在watch中的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">scrollY(newY) &#123;</span><br><span class="line">  <span class="keyword">let</span> minHeight = <span class="keyword">this</span>.minHeight</span><br><span class="line">  <span class="keyword">let</span> zIndex = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> scale = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> blur = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> bgImage = <span class="keyword">this</span>.$refs.bgImage</span><br><span class="line">  <span class="keyword">let</span> bgLayer = <span class="keyword">this</span>.$refs.bgLayer</span><br><span class="line">  <span class="comment">// 控制bgLayer向上移动的最大距离只能是minHeight</span></span><br><span class="line">  <span class="keyword">let</span> translateY = <span class="built_in">Math</span>.max(newY, minHeight)</span><br><span class="line">  <span class="comment">// 当向下滑动时图片放大的比例</span></span><br><span class="line">  <span class="keyword">const</span> percent = <span class="built_in">Math</span>.abs(newY / <span class="keyword">this</span>.bgImageHeight)</span><br><span class="line">  <span class="comment">// 控制bgLayer随着list的移动</span></span><br><span class="line">  bgLayer.style[transform] = <span class="string">`translate3d(0, <span class="subst">$&#123;translateY&#125;</span>px, 0)`</span></span><br><span class="line">  <span class="keyword">if</span> (newY &lt; minHeight) &#123;</span><br><span class="line">    <span class="comment">// 提高层级用来遮住上滑的列表</span></span><br><span class="line">    zIndex = <span class="number">10</span></span><br><span class="line">    <span class="comment">// 将bgImage高度设为RESERVE_HEIGHT，这样保证bgImage只遮住上滑的列表</span></span><br><span class="line">    bgImage.style.padding = <span class="number">0</span></span><br><span class="line">    bgImage.style.height = RESERVE_HEIGHT + <span class="string">'px'</span></span><br><span class="line">    <span class="comment">// 由于bgImage高度变了，所以需要键play隐藏，要不然play会出现在bgImage中</span></span><br><span class="line">    <span class="keyword">this</span>.$refs.play.style.display = <span class="string">'none'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有达到最大高度则将bgImage的高度变回来</span></span><br><span class="line">    bgImage.style[<span class="string">'padding-top'</span>] = <span class="string">'70%'</span></span><br><span class="line">    bgImage.style.height = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.$refs.play.style.display = <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newY &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是向下滑动，则设置bgImage的放大值</span></span><br><span class="line">    zIndex = <span class="number">10</span></span><br><span class="line">    scale = <span class="number">1</span> + percent</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是向上滑动，设置bgImage的模糊值</span></span><br><span class="line">    blur = <span class="built_in">Math</span>.min(<span class="number">20</span> * percent, <span class="number">20</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.$refs.filter.style[backdrop] = <span class="string">`blur(<span class="subst">$&#123;blur&#125;</span>px)`</span></span><br><span class="line">  bgImage.style[transform] = <span class="string">`scale(<span class="subst">$&#123;scale&#125;</span>)`</span></span><br><span class="line">  bgImage.style[<span class="string">'z-index'</span>] = zIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;项目简介&quot;&gt;&lt;a href=&quot;#项目简介&quot; class=&quot;headerlink&quot; title=&quot;项目简介&quot;&gt;&lt;/a&gt;项目简介&lt;/h1&gt;&lt;p&gt;该项目是一个具备完善功能的音乐app，所有数据都通过抓取接口数据动态获取，希望能够通过这一个项目能够更深的体会模块化编程，以
      
    
    </summary>
    
      <category term="vue.js学习笔记" scheme="http://yoursite.com/categories/vue-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>作用域</title>
    <link href="http://yoursite.com/2018/07/23/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2018/07/23/作用域/</id>
    <published>2018-07-22T16:00:00.000Z</published>
    <updated>2018-08-13T15:49:14.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>编程语言最基本的一个功能就是能够储存变量中的值，并且能够在之后的操作中访问和修改这个值。正是这种储存和访问变量的值的能力将状态带给了程序。而对于变量我们关心的则是它们储存在哪里？程序如何找到它们？也就是每一种编程语言中都有一套良好的规则来储存变量，并且在之后能够方便的找到这些变量，这一套规则就被称为作用域。</p><h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><p>JavaScript本质上是一门编译语言，通过JavaScript引擎进行编译，传统的编译语言流程分为下面三个步骤：</p><ul><li><p>分词/词法分析</p><p>这个过程会将字符组成的字符串分解成对编程语言来说有意义的代码块，这些代码块被称为词法单元。例如<code>var a = 2</code>会被分解为var、a、=、2、；。这些词法单元</p></li><li><p>解析/语法分析</p><p>这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。var a = 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下来是一个叫作 Identifier （它的值是 a ）的子节点，以及一个叫作 AssignmentExpression的子节点。 AssignmentExpression 节点有一个叫作 NumericLiteral （它的值是 2 ）的子节点。</p></li><li><p>代码生成</p><p>将AST转换为可执行代码的过程被称为代码生成。var a = 2；的AST转换为一组机器指令，用来创建一个叫做a的变量，并将一个值储存在a中。</p></li></ul><h2 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h2><p>首先了解一下参与代码处理的几个程序。</p><ul><li><p>引擎</p><p>负责JavaScript程序的编译及执行过程</p></li><li><p>编译器</p><p>负责语法分析及代码生成</p></li><li><p>作用域</p><p>负责收集并维护由所有什么的标识符组成的一系列查询、并实施一套非常严格的规则确定当前执行的代码对这些标识符的访问权限。</p></li></ul><p>下面我们通过对var a = 2；这一段代码的分析来理解什么是作用域。</p><ul><li>对应var a = 2；这一句声明引擎会认为是两个完全不一样的声明，一个是由编译器在编译时处理的，另一个则是由引擎在运行时处理的。</li><li>遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在同一个作用域的集合之中。如果已经有了，那么会忽略这个声明，否则就会要求作用域在当前作用域的集合中声明一个变量，并命名为a。</li><li>接下来编译器为引擎生成运行时的所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎在运行时会先询问作用域，在当前作用域中是否存在变量a。如果是，引擎会使用这个变量；如果否，引擎会继续查找该变量。如果最终找到了a变量则执行赋值操作，否则会抛出异常。</li></ul><p>引擎执行查找的方式分为两种：</p><ul><li>LHS查询：执行这个查询需要试图找到变量容器本身。</li><li>RHS查询：执行这个查询时需要找到某个变量的值。</li></ul><blockquote><p>注意：函数声明与普通的变量声明并不相同，编译器可以在代码生成的同时处理声明和值的定义。</p></blockquote><h3 id="作用域的嵌套"><a href="#作用域的嵌套" class="headerlink" title="作用域的嵌套"></a>作用域的嵌套</h3><p>当一个块或函数嵌套在另一个块或函数中时，就会发生作用域嵌套。</p><p>如果在当前作用域无法找到某个变量，那么引擎就会到外层嵌套作用域中继续查找，直到找到该变量，或者直到抵达到最外层的作用域为止。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>当变量还没有声明的情况下LHS和RHS这两种查询行为是不相同的。</p><ul><li>如果RHS查询在所有嵌套的作用域中都找不到所需要的变量，引擎就会抛出ReferenceError异常。</li><li>而当引擎执行LHS查询在全局作用域中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并且将其返回给引擎。这是在非严格模式下会执行的操作。如果是严格模式下那么会抛出ReferenceError异常。</li><li>如果RHS查询找到一个变量，但是我们对这个值进行了不合理的操作，如非函数类型进行函数调用，那么就会抛出TypeError异常。</li></ul><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>作用域共有两种主要的工作模式。第一种是词法作用域，第二种是动态作用域，JavaScript使用的就是词法作用域。</p><h3 id="词法阶段"><a href="#词法阶段" class="headerlink" title="词法阶段"></a>词法阶段</h3><p>大部分标准语言的编译器在第一个工作阶段叫做词法化。</p><p>词法作用域就是定义在词法阶段的作用域，也就是说词法作用域是由你写代码是将变量和块作用域写在哪里来决定的。</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>作用域在找到第一个匹配的表示符时就会立即停止查找，所以如果在多层作用域中定义了同名的表示，那么就只会查找到里当做作用域最近的作用域中的标识符，这个叫做遮蔽效应。</p><p>全局作用中的变量会自动变成全局对象的属性。因此可以不直接通过全局对象的词法名称，而间接的通过对全局属性的引用来对其访问，这个方法可以访问到被同名变量遮蔽的全局变量。</p><p>无论函数在哪里调用，与无论它被谁调用。它的词法作用域都只由函数被声明时所处的位置决定。</p><h3 id="欺骗词法"><a href="#欺骗词法" class="headerlink" title="欺骗词法"></a>欺骗词法</h3><p>JavaScript中有两种方式可以在运行的时候修改(或者说欺骗)词法作用域。但是欺骗词法作用域会导致性能下降。</p><h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>eval()是一个函数，接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置一样。</p><p>默认情况下，如果eval()中所执行的代码包含一个或多个声明(无论是变量还是函数)，就会对eval所处的词法作用域进行修改。</p><p>在严格模式的程序中，eval()在运行时会有自己的词法作用域，意味着其中的声明无法修改所在的作用域。在使用let或const声明变量的字符串时，eval()也会在运行时产生自己的词法作用域。</p><p>setTimeout()和setInterval()的第一个参数可以是字符串，字符串内容可以被解释为一段动态生成的函数代码。当然一般是不使用这种方法的。</p><h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><p>with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。</p><p>尽管with可以将一个对象处理为词法作用域，但是在这个块中使用var声明并不会限制到这个块作用域中，而是会被添加到with所处的函数作用域中。</p><p>eval()函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而with声明实际上是根据你传递给它的对象创建一个新的词法作用域。</p><p>在with块中使用变量时，首先会到当前块作用域(也就是传进去的对象)中查找是否存在这个标识符(也就是对象是否有相对应的属性)，如果找不到该变量，就会按照作用域查找规则继续查找。</p><p><strong>在实际使用中最好不要使用with和eval！</strong></p><h2 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h2><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用以及复用(在嵌套作用域中也可以使用)。</p><h3 id="隐藏内部实现"><a href="#隐藏内部实现" class="headerlink" title="隐藏内部实现"></a>隐藏内部实现</h3><p>对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但是反过来：我们从所写的代码中挑选一个任意的片段，然后使用函数声明将它包装，实际上就是把这些代码隐藏起来了。</p><p>将代码片段包装到一个函数中，实际上就是在这个代码片段周围创建了一个作用域，这段代码中的所有声明都绑定到了这个新创建的包装函数的作用域中，而不是先前的作用域。这样就能把这个代码片段中的变量和函数隐藏到这个作用域中了。</p><p>这种隐藏变量和函数的技术，是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。这个原则指的是在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来。</p><p>隐藏作用域中的变量和函数所带来的另一个好处就是可以规避同名标识符之间的冲突。</p><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>从前面我们知道了，函数可以将变量和函数定义隐藏起来，外部作用域无法访问到内部作用域中的任何内容，但是如果我们直接将需要执行的代码放到一个函数中的话，还是会有一些不太好的地方：</p><ol><li>我们需要创建一个具名函数，那么意味着这个函数名本身就已污染了所在的作用域中。</li><li>我们还需要显示的去调用一下这个函数才能够执行里面的代码。</li></ol><p>那么我们现在我们需要的就是一个不需要函数名，并且可以自动运行的函数。这种函数就是叫做自执行函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">&#125;)()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>在上面的代码中我就实现一个自动执行函数，并且该函数的函数名不会污染它所在的作用域。</p><blockquote><p>这里前面的分号的作用是：如果使用的是无分号的代码风格，那么如果一行代码是以’(‘开始那么需要在前面加上一个分号，防止报错。</p></blockquote><p>观察上面的代码我们可以发现这个函数的声明是以<code>(function...</code>而不是以<code>function...</code>开始，而这个区别就会导致前面的函数会被当做函数表达式而不是一个标准的函数声明来处理。所以foo被绑定在函数表达式自身的函数中而不是所在的作用域中。</p><blockquote><p>区分函数声明和表达式最简单的方法就是看function关键字出现在声明的位置。如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</p></blockquote><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>所谓块级作用域就是：在使用<code>{}</code>包裹的代码块中声明的变量只能在这个代码块中使用，无法在代码块之外使用。</p><p>在es6之前我们声明变量的方法只能是使用<code>var</code>关键字，而使用<code>var</code>关键字声明的变量时没有块级作用域的概念的。在代码块中声明的变量依然可以在外部访问到。</p><p>在es6之前只有只有两个语句可以实现块级作用域：</p><ol><li>with语句，它从对象中创建出来的作用域，只能够在with声明中的作用域有效。</li><li>try/catch语句，catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效。</li></ol><p>es6添加了两个新的关键字，可以实现块级作用域：</p><ol><li>let 关键字，只要在一个代码块中使用let关键字，那么就相当于在这个代码中创建了一个块级作用域。无法在块块级作用域外部访问到块级作用域内部的变量。使用let进行声明不会在块作用域中进行变量声明提升，也就是如果想要在声明前面访问该变量会报错，而使用var关键字声明的变量由于声明提升，在声明前面访问变量会返回undefined。</li><li>const关键字，具有let的所有功能，唯一不同的就是使用const声明的变量无法在之后修改该变量的值，任何试图修改其值的行为都会报错。</li></ol><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h1&gt;&lt;p&gt;编程语言最基本的一个功能就是能够储存变量中的值，并且能够在之后的操作中访问和修改这个值。正是这种储存和访问变量的值的能力将状态带给了
      
    
    </summary>
    
      <category term="JavaScript高级" scheme="http://yoursite.com/categories/JavaScript%E9%AB%98%E7%BA%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>vue饿了么项目</title>
    <link href="http://yoursite.com/2018/07/18/vue%E9%A5%BF%E4%BA%86%E4%B9%88%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/18/vue饿了么项目（一）/</id>
    <published>2018-07-17T16:00:00.000Z</published>
    <updated>2018-07-23T06:13:09.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>这个系列主要用来记录在做项目中遇到的坑，以及解决方法。</p><h2 id="使用vue-cli搭建一个vue项目"><a href="#使用vue-cli搭建一个vue项目" class="headerlink" title="使用vue-cli搭建一个vue项目"></a>使用vue-cli搭建一个vue项目</h2><ol><li>在全局安装vue-cli<code>npm install -g @vue/cli</code></li><li>使用vue-cli创建一个新的项目:<code>vue create 项目名称</code></li><li>使用vue-cli创建的项目中默认是没有下载<code>less</code>的需要在项目中下载<code>less</code>和<code>less-loader</code>，然后在<code>webpack.dev.conf.js</code>中修改配置</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改前</span></span><br><span class="line"> <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: utils.styleLoaders(&#123; <span class="attr">sourceMap</span>: config.dev.cssSourceMap, <span class="attr">usePostCSS</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 将usePostCss这个属性去掉，即可在项目中使用less</span></span><br><span class="line">  <span class="comment">// 修改后</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: utils.styleLoaders(&#123; <span class="attr">sourceMap</span>: config.dev.cssSourceMap&#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h2 id="在项目中使用json文件中的假数据模拟后台数据"><a href="#在项目中使用json文件中的假数据模拟后台数据" class="headerlink" title="在项目中使用json文件中的假数据模拟后台数据"></a>在项目中使用json文件中的假数据模拟后台数据</h2><ol><li>在<code>webpack.dev.conf.js</code>文件中进行配置</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入express模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="comment">// 加载静态的数据</span></span><br><span class="line"><span class="keyword">var</span> appData = <span class="built_in">require</span>(<span class="string">'../data.json'</span>)</span><br><span class="line"><span class="keyword">var</span> seller = appData.seller</span><br><span class="line"><span class="keyword">var</span> goods = appData.goods</span><br><span class="line"><span class="keyword">var</span> ratings = appData.ratings</span><br><span class="line"><span class="keyword">var</span> apiRouters = express.Router()</span><br><span class="line">app.use(<span class="string">'/api'</span>, apiRouters)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在devServer对象中配置路由接口，为devServer添加以下属性</span></span><br><span class="line">before(app) &#123;</span><br><span class="line">      app.get(<span class="string">'/api/seller'</span>, (req, res) =&gt; &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">          errno: <span class="number">0</span>,</span><br><span class="line">          data: seller</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;),</span><br><span class="line">      app.get(<span class="string">'/api/goods'</span>, (req, res) =&gt; &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">          errno: <span class="number">0</span>,</span><br><span class="line">          data: goods</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;),</span><br><span class="line">      app.get(<span class="string">'/api/ratings'</span>, (req, res) =&gt; &#123;</span><br><span class="line">        res.json(&#123;</span><br><span class="line">          errno: <span class="number">0</span>,</span><br><span class="line">          data: ratings</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="移动端1像素边框的实现"><a href="#移动端1像素边框的实现" class="headerlink" title="移动端1像素边框的实现"></a>移动端1像素边框的实现</h2><h3 id="产生原因："><a href="#产生原因：" class="headerlink" title="产生原因："></a>产生原因：</h3><p>由于手机的Retine屏的分辨率与普通屏幕分辨率不同，所以在设置1px边框时很可能会出现边框大于1px的现象。</p><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>移动端1px像素解决方法各大主流网站都各有不同，这里我使用伪类来创建1px的线条，然后通过媒体查询，根据不同设备的<code>devicePixelRatio</code>来实现不同比例的缩放，从而使线条接近1px。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border-1px</span>(<span class="variable">@color</span>) &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="variable">@color</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">1.5</span>),(<span class="attribute">min-device-pixel-ratio</span>: <span class="number">1.5</span>) &#123;</span><br><span class="line">  <span class="selector-class">.border-1px</span> &#123;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">      <span class="attribute">-webkit-transform</span>: scaleY(<span class="number">0.7</span>);</span><br><span class="line">      <span class="attribute">transform</span>: scaleY(<span class="number">0.7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">2</span>),(<span class="attribute">min-device-pixel-ratio</span>: <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="selector-class">.border-1px</span> &#123;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">      <span class="attribute">-webkit-transform</span>: scaleY(<span class="number">0.5</span>);</span><br><span class="line">      <span class="attribute">transform</span>: scaleY(<span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Sticky-footers"><a href="#实现Sticky-footers" class="headerlink" title="实现Sticky footers"></a>实现Sticky footers</h2><p>Sticky footers是css页面布局十分常见的一个效果，当我们需要在底部固定一个内容，当页面内容不够时，底部内容被固定到底部，而当页面内容比较多超过了整个屏幕的大小时，底部固定内容要跟着往下走，而不遮挡到上面的内容，这个布局使用fixed布局无法做到</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="html部分"><a href="#html部分" class="headerlink" title="html部分"></a>html部分</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"detail"</span> <span class="attr">v-show</span>=<span class="string">"detailShow"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"detail-wrapper clearfix"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"detail-main"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"detail-close"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"icon-close"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.detail</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">100</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(7, 17, 27, 0.8);</span><br><span class="line">    .detail-wrapper &#123;</span><br><span class="line">        <span class="selector-tag">min-height</span>: 100%;</span><br><span class="line">        <span class="selector-class">.detail-main</span> &#123;</span><br><span class="line">            <span class="attribute">margin-top</span>:  <span class="number">64px</span>;</span><br><span class="line">            <span class="attribute">padding-bottom</span>: <span class="number">64px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.detail-close</span> &#123;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">32px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">32px</span>;</span><br><span class="line">        <span class="attribute">margin</span>: -<span class="number">64px</span> auto <span class="number">0</span> auto;</span><br><span class="line">        <span class="attribute">clear</span>: both;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">32px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先<code>detail-wrapper</code>盒子是保证盒子最小要能够占满屏幕，这样才能够把<code>detail-close</code>挤到底部去</li><li><code>detail-main</code>中的<code>margin</code>是根据项目实际情况决定的，可以不需要，而<code>padding-bottom</code>则是为了当内容超过一个屏幕的时候，内容不会覆盖到底部内容。</li><li>最后为<code>detail-close</code>设置负的<code>margin-top</code>则是将这个盒子定位到<code>detail-wrapper</code>中去，在页面内容不够长的时候，让脚部区域在固定的位置展示。</li></ol><h2 id="关于vue中dom以及一些异步操作所带来的问题"><a href="#关于vue中dom以及一些异步操作所带来的问题" class="headerlink" title="关于vue中dom以及一些异步操作所带来的问题"></a>关于vue中dom以及一些异步操作所带来的问题</h2><blockquote><p>这个坑卡了三个小时，产生的原因是没有考虑到多个异步操作所带来的问题</p></blockquote><ol><li>首先组件中所有的数据都是由ajax异步请求过来的，而我将这个操作定义为了一个方法，然后到<code>created</code>中去执行了这个方法，获取数据。</li><li>然后我使用请求过来的数据来渲染页面，其中有一个部分是通过<code>v-for</code>渲染的。</li><li>在后面操作中发现需要使用到由<code>v-for</code>渲染出来的DOM元素，这个时候我使用<code>ref</code>绑定到这些DOM元素。</li><li>然后在<code>mounted</code>中去操作DOM元素，这个时候发现无法从<code>this.$refs</code>中取到使用<code>v-for</code>渲染出来的DOM，然而在<code>this.$refs</code>对象中是保存了这个DOM元素的，但是当访问这些DOM元素时会发现结果是<code>undefined</code>。期间将操作放到<code>$nextTick</code>函数里面回调也无法取得DOM元素，非常的奇怪。</li><li>经过三个多小时的谷歌，也无法发现问题出在哪里了，最后我把获取DOM元素的操作放到ajax请求数据的函数中去执行时问题解决了，那么问题可能就出现在当我获取DOM元素时没有考虑到获取数据这个异步操作，导致虽然使用了<code>$nextTick</code>任然无法获取到DOM元素，因为这个时候可能数据还没有取到，所以还没有渲染到页面上，也就无法取得DOM元素了。</li></ol><h3 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取数据的操作</span></span><br><span class="line">created() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getGoods()</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 操作DOM元素的方法</span></span><br><span class="line">mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._initScroll()</span><br><span class="line">        <span class="keyword">this</span>._calculateHeight()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改进之后的代码"><a href="#改进之后的代码" class="headerlink" title="改进之后的代码"></a>改进之后的代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$http.get(<span class="string">'/api/goods'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        res = res.body</span><br><span class="line">        <span class="keyword">if</span> (res.errno === ERR_OK) &#123;</span><br><span class="line">            <span class="keyword">this</span>.goods = res.data</span><br><span class="line">            <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>._initScroll()</span><br><span class="line">                <span class="keyword">this</span>._calculateHeight()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##元素宽度自适应设备宽度，且宽高相等的布局</p><p>移动端在进行图片展示的时候，一般大的图片要求是宽度自适应，而且宽度高度相等布局，而由于图片的宽度是由设备大小所决定，我们就无法将宽度高度固定，而如果不对图片容器固定宽高，当网络速度比较慢时，图片会在页面渲染之后才会请求得到，图片请求到之后插入页面时会改变页面的布局，会导致页面抖动。</p><ul><li>解决办法</li></ul><p>给图片的容器设置<code>width:100%</code>然后设置<code>padding-top:100%</code>这样就能保证容器在没有图片时会有一个与宽度相等的高度。里面的图片元素设置绝对定位，就能够保证图片脱离文档流，不受容器的<code>padding</code>的影响。</p><h2 id="购物车小球动画和添加商品的cartcontrol组件"><a href="#购物车小球动画和添加商品的cartcontrol组件" class="headerlink" title="购物车小球动画和添加商品的cartcontrol组件"></a>购物车小球动画和添加商品的cartcontrol组件</h2><p>这一个部分是整个项目中最难的一个部分，由于项目比较简单所以没有使用<code>vuex</code>,也就导致了兄弟组件之间通信比较麻烦。</p><h3 id="小球动画的原理"><a href="#小球动画的原理" class="headerlink" title="小球动画的原理"></a>小球动画的原理</h3><ol><li>首先小球是设计在购物车组件之中的，为了满足点击需求一共设计有5个小球，将5控制5个小球的展示和隐藏以数组的形式存到<code>data</code>当中，然后通过<code>v-for</code>指令生成小球。并且在<code>data</code>中定义一个空数组<code>dropBalls</code>用来存放下落的小球。</li><li>当点击添加商品的按钮时，小球就会从添加按钮中运动到购物车中，而由于小球一开始是在购物车中的，那么在点击的时候就需要将小球移动到点击按钮中，然后通过过渡让小球从按钮上移动回到购物车里。</li><li>由于每个商品中都有一个添加按钮，那么我们就需要在点击按钮时动态获取当前点击按钮的位置，通过这个位置计算出小球应该移动的距离。</li><li>而问题的关键在于按钮组件与购物车组件是兄弟组件，它们的父组件是商品页面的<code>goods</code>组件。我们就需要解决如何将按钮组件中的按钮的位置传递给购物车组件。</li></ol><h3 id="将按钮组件的位置传递给购物车组件"><a href="#将按钮组件的位置传递给购物车组件" class="headerlink" title="将按钮组件的位置传递给购物车组件"></a>将按钮组件的位置传递给购物车组件</h3><p>兄弟组件之间无法直接通信，所以解决办法是，利用一个中间组件——父组件，来间接的实现通信。</p><ol><li>从<code>cartcontrol</code>组件中将添加按钮的dom对象传递给父组件。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在goods组件中定义方法,并传递给cartcontrol组件，获取点击时cartcontrol中添加按钮的dom对象</span></span><br><span class="line">addFood(target) &#123;</span><br><span class="line">    <span class="keyword">this</span>._drop(target)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在点击添加按钮时在cartcontrol中执行父组件传递过来的方法，并将事件对象，也就是添加按钮的dom对象传递给父组件</span></span><br><span class="line">addCart(event) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.food.count) &#123;</span><br><span class="line">    Vue.set(<span class="keyword">this</span>.food, <span class="string">'count'</span>, <span class="number">1</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.food.count++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.$emit(<span class="string">'add'</span>, event.target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>将获取到的按钮对象传递给shopcart组件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里通过vue的ref属性就可以获取到子组件的对象，也就可以调用子组件中的方法，从而将按钮对象传递给shopcart组件</span></span><br><span class="line">_drop(target) &#123;</span><br><span class="line">    <span class="comment">// 性能优化</span></span><br><span class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.$refs.shopcart.drop(target)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 购物车中的drop方法接受到按钮对象之后，遍历小球数据，将按钮对象保存到找到的第一个没有运动的小球中，并将这个小球对象添加到正在下落的小球数组dropBalls中。</span></span><br><span class="line">drop(el) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.balls.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> ball = <span class="keyword">this</span>.balls[i]</span><br><span class="line">    <span class="keyword">if</span> (!ball.show) &#123;</span><br><span class="line">      ball.show = <span class="literal">true</span></span><br><span class="line">      ball.el = el</span><br><span class="line">      <span class="keyword">this</span>.dropBalls.push(ball)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="利用transition来实现小球动画"><a href="#利用transition来实现小球动画" class="headerlink" title="利用transition来实现小球动画"></a>利用transition来实现小球动画</h3><p>小球的动画我们通过vue提供的transition的钩子函数来控制小球的动画。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到显示的小球，然后将这个小球移动到目标位置</span></span><br><span class="line">beforeDrop(el) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="keyword">this</span>.balls.length</span><br><span class="line">  <span class="keyword">while</span> (count--) &#123;</span><br><span class="line">    <span class="keyword">let</span> ball = <span class="keyword">this</span>.balls[count]</span><br><span class="line">    <span class="keyword">if</span> (ball.show) &#123;</span><br><span class="line">      <span class="keyword">let</span> rect = ball.el.getBoundingClientRect()</span><br><span class="line">      <span class="keyword">let</span> x = rect.left - <span class="number">32</span></span><br><span class="line">      <span class="keyword">let</span> y = -(<span class="built_in">window</span>.innerHeight - rect.top - <span class="number">22</span>)</span><br><span class="line">      el.style.display = <span class="string">''</span></span><br><span class="line">      el.style.webkitTransform = <span class="string">`translate3d(0,<span class="subst">$&#123;y&#125;</span>px,0)`</span></span><br><span class="line">      el.style.transform = <span class="string">`translate3d(0,<span class="subst">$&#123;y&#125;</span>px,0)`</span></span><br><span class="line">      <span class="keyword">let</span> inner = el.getElementsByClassName(<span class="string">'inner-hook'</span>)[<span class="number">0</span>]</span><br><span class="line">      inner.style.webkitTransform = <span class="string">`translate3d(<span class="subst">$&#123;x&#125;</span>px,0,0)`</span></span><br><span class="line">      inner.style.transform = <span class="string">`translate3d(<span class="subst">$&#123;x&#125;</span>px,0,0)`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 给小球设置过渡动画</span></span><br><span class="line">dropping(el, done) &#123;</span><br><span class="line">  <span class="comment">/* eslint-disable no-unused-vas */</span></span><br><span class="line">  <span class="comment">// 这里是手动触发浏览器的重排，他会强制刷新队列要求样式修改任务立即执行</span></span><br><span class="line">  <span class="keyword">let</span> rf = el.offsetHeight</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    el.style.webkitTransform = <span class="string">'translate3d(0,0,0)'</span></span><br><span class="line">    el.style.transform = <span class="string">'translate3d(0,0,0)'</span></span><br><span class="line">    <span class="keyword">let</span> inner = el.getElementsByClassName(<span class="string">'inner-hook'</span>)[<span class="number">0</span>]</span><br><span class="line">    inner.style.webkitTransform = <span class="string">'translate3d(0,0,0)'</span></span><br><span class="line">    inner.style.transform = <span class="string">'translate3d(0,0,0)'</span></span><br><span class="line">    el.addEventListener(<span class="string">'transitionend'</span>, done)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 手动将执行完动画的小球隐藏，这里注意，由于在取的时候我们是从后往前找显示的小球，而dropBalls是push方法将显示小球添加的，所以执行完动画的小球应该是dropBalls数组中的第一个，使用shift方法把它从dropBalls数组中删除，并隐藏它。</span></span><br><span class="line">afterDrop(el) &#123;</span><br><span class="line">  <span class="keyword">let</span> ball = <span class="keyword">this</span>.dropBalls.shift()</span><br><span class="line">  <span class="keyword">if</span> (ball) &#123;</span><br><span class="line">    ball.show = <span class="literal">false</span></span><br><span class="line">    el.style.display = <span class="string">'none'</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="商品页面的商品购买价格计算以及购买商品的数量的展示"><a href="#商品页面的商品购买价格计算以及购买商品的数量的展示" class="headerlink" title="商品页面的商品购买价格计算以及购买商品的数量的展示"></a>商品页面的商品购买价格计算以及购买商品的数量的展示</h2><p>这个部份充分发挥了vue以数据驱动视图的特性，能充分感受到mvvm框架在数据操作上的优势。这里主要涉及到单个商品的数量，以及所有购买商品的数量，还有所有商品的总价，在多个组件之间的联合展示。这里的组件结构是一个父组件<code>goods</code>子组件有<code>cartcontrol shopcart food</code>这三个组件。</p><h3 id="整体的业务需求"><a href="#整体的业务需求" class="headerlink" title="整体的业务需求"></a>整体的业务需求</h3><ol><li>在商品页面展示所有商品列表，每个商品都有一个添加商品的按钮，当每个商品购买数量多于0个时，就会在添加按钮旁边显示购买数量。</li><li>当商品的购买数量不为0是购物车就会显示商品数量的总和，以及商品的总价，当切换到单个商品详情页<code>food</code>组件时，这些状态都不会改变。</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol><li>添加商品</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在cartcontrol组件中，点击添加商品按钮的事件，判断商品对象中是否有count属性，如果没有则添加这个属性并将它的值设置为1，如果有则count数量+1</span></span><br><span class="line">addCart(event) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.food.count) &#123;</span><br><span class="line">    Vue.set(<span class="keyword">this</span>.food, <span class="string">'count'</span>, <span class="number">1</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.food.count++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.$emit(<span class="string">'add'</span>, event.target)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ol start="2"><li>计算选中商品的数量</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在goods组件中定义一个计算属性，来储存被选中的商品。</span></span><br><span class="line">selectFoods() &#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">this</span>.goods.forEach(<span class="function">(<span class="params">good</span>) =&gt;</span> &#123;</span><br><span class="line">        good.foods.forEach(<span class="function">(<span class="params">food</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (food.count &amp;&amp; food.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result.push(food)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>然后通过selectFoods中被选中商品的对象就可以计算出被选中商品的数量，以及商品的总价了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;这个系列主要用来记录在做项目中遇到的坑，以及解决方法。&lt;/p&gt;
&lt;h2 id=&quot;使用vue-cli搭建一个vue项目&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="vue.js学习笔记" scheme="http://yoursite.com/categories/vue-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>vue.js(六)</title>
    <link href="http://yoursite.com/2018/07/14/vue.js(%E5%85%AD)/"/>
    <id>http://yoursite.com/2018/07/14/vue.js(六)/</id>
    <published>2018-07-13T16:00:00.000Z</published>
    <updated>2018-07-14T07:55:18.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vuex的使用"><a href="#vuex的使用" class="headerlink" title="vuex的使用"></a>vuex的使用</h1><h2 id="为什么要使用vuex？"><a href="#为什么要使用vuex？" class="headerlink" title="为什么要使用vuex？"></a>为什么要使用vuex？</h2><p>当我们的项目中组件非常多，而在项目中有一部分的数据是多个组件所共同使用的，这个时候在组件之间传递这个共用的数据就会非常的麻烦。那么我们就建立一个专门储存这些共用数据的地方，当有那个组件需要使用到这个数据的时候，直接去这个储存数据的地方取用数据即可，而vuex就是一个可以提供储存公用数据的插件。</p><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><ol><li>安装</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vuex</span><br></pre></td></tr></table></figure><ol start="2"><li>在项目中引入vuex</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span> </span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure><ol start="3"><li>创建一个store，并挂载到vm实例中去</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment (state) &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>其中第一个对象<code>state</code>用来存放公用数据。</li><li>第二个对象<code>mutations</code>用来定义操作数据的方法。</li></ul><ol start="4"><li><p>在组件中访问和操作公用数据</p><ul><li>我们已经把<code>store</code>对象挂载到了vm实例中，那么我们就可以通过vm实例中的<code>$store</code>去访问到数据，如：<code>this.$store.state.数据对象名称</code></li><li>如果我们要对数据进行操作，那么首先要在<code>mutations</code>去定义操作数据的方法，再到组件中去调用这个方法，因为一旦有多个组件需要对这个数据进行操作，而每个组件操作的方法又不一样，那么一旦数据发生错误，我们就很难定位到时那个组件的方法所导致的错误，所以需要操作数据时先在<code>mutations</code>中定义这个方法，然后再调用。<code>this.$store.commit(&#39;reduce&#39;)</code></li><li><code>mutations</code>中的函数只能接受两个参数，第一个参数默认为<code>state</code>，第二参数是自定义参数，如果有需要就可以传，没有需要就不用传，不能再去定义第三个形参了，函数内部接受不到，如果需要传递多个参数进去，只能通过给第二个参数传递对象。</li><li>如果我们需要将数据进行加工之后再返回给组件，那么可以在<code>getters</code>中定义数据加工的函数，这个属性和<code>filter</code>过滤器比较相似，可以对数据进行操作而不改变数据本身，最后通过<code>return</code>返回加工后的数据。在定义函数时接受state作为其第一个参数，</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vuex的使用&quot;&gt;&lt;a href=&quot;#vuex的使用&quot; class=&quot;headerlink&quot; title=&quot;vuex的使用&quot;&gt;&lt;/a&gt;vuex的使用&lt;/h1&gt;&lt;h2 id=&quot;为什么要使用vuex？&quot;&gt;&lt;a href=&quot;#为什么要使用vuex？&quot; class=&quot;he
      
    
    </summary>
    
      <category term="vue.js学习笔记" scheme="http://yoursite.com/categories/vue-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack(一)</title>
    <link href="http://yoursite.com/2018/07/08/webpack%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/08/webpack（一）/</id>
    <published>2018-07-07T16:00:00.000Z</published>
    <updated>2018-07-09T11:10:10.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="webpack起步"><a href="#webpack起步" class="headerlink" title="webpack起步"></a>webpack起步</h2><h3 id="什么是webpack？"><a href="#什么是webpack？" class="headerlink" title="什么是webpack？"></a>什么是webpack？</h3><p>webpack是前端的一个项目构建工具，是基于Node.js开发出来的一个前端工具。</p><h3 id="webpack的作用"><a href="#webpack的作用" class="headerlink" title="webpack的作用"></a>webpack的作用</h3><p>借助webpack这个前端自动化构建工具，可以完美的实现资源的合并、打包、混淆等诸多功能。</p><h3 id="webpack和Gulp的区别"><a href="#webpack和Gulp的区别" class="headerlink" title="webpack和Gulp的区别"></a>webpack和Gulp的区别</h3><ol><li>使用Gulp，是基于task任务的；</li><li>使用webpack，是基于整个项目进行构建的；</li></ol><h3 id="webpack的安装"><a href="#webpack的安装" class="headerlink" title="webpack的安装"></a>webpack的安装</h3><ol><li>运行<code>npm i webpack -g</code>全局安装webpack，这样就可以在全局使用webpack命令了。</li><li>在项目根目录中运行<code>npm i webpack --save-dev</code>安装到项目依赖中。</li><li>在使用webpack4时还需要安装<code>webpack-cli</code>，使用npm安装即可</li></ol><h3 id="webpack能做什么？"><a href="#webpack能做什么？" class="headerlink" title="webpack能做什么？"></a>webpack能做什么？</h3><ol><li>webpack可以处理JS文件的相互依赖关系。</li><li>webpack能够处理JS的兼容问题，把高级的、浏览器无法识别的语法，转为低级的，浏览器可以识别的语法。</li></ol><h3 id="webpack配置文件的基本使用"><a href="#webpack配置文件的基本使用" class="headerlink" title="webpack配置文件的基本使用"></a>webpack配置文件的基本使用</h3><p>webpack是基于Node开发的，所以在webpack配置文件中使用node的语法进行相应的配置。</p><ol><li>首先配置文件中可以载入node中的模块，来进行相应的操作，如：可以载入node中的<code>path</code>模块，那么我们就可以使用这个模块中的相应的方法了。</li><li>我们的配置全部挂载到<code>module.exports</code>对象中去。通过模块的导出，将配置对象导出。</li></ol><h4 id="配置对象中的属性"><a href="#配置对象中的属性" class="headerlink" title="配置对象中的属性"></a>配置对象中的属性</h4><ol><li><code>entry</code>表示使用webpack打包哪一个文件，传入的值是需要打包的文件的路径。</li><li><p><code>output</code>输出文件的相关配置，是一个对象，传入两个属性：</p><ol><li><code>path</code>指定打包之后的文件保存的目录</li><li><code>filename</code>指定打包之后输出文件的名称</li></ol></li></ol><h3 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h3><p>当配置好配置文件之后我们就可以开始打包我们的文件了，在项目的根路径输入<code>webpack</code>命令即可开始打包。在打包过程中webpack做了下面几步：</p><ol><li>首先，webpack回去项目的根目录中查找一个叫做<code>webpack.config.js</code>的配置文件</li><li>找到配置文件之后，webpack会去解析这个配置文件，当解析完配置文件后，就得到了配置文件中导出的配置对象。</li><li>拿到配置对象后，从配置对象中找到指定的入口和出口，然后对文件进行打包构建。</li></ol><h3 id="webpack-dev-server的使用"><a href="#webpack-dev-server的使用" class="headerlink" title="webpack-dev-server的使用"></a>webpack-dev-server的使用</h3><p>在使用webpack时，我们的代码每更新一次就需要重新执行<code>webpack</code>命令打包一次，这样操作非常的繁琐，<code>webpack-dev-server</code>可以解决这个问题，它可以监听代码的变化提供自动打包服务。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol><li>在项目根目录下运行<code>npm i webpack-dev-server -D</code>命令，将工具安装到项目的本地开发依赖中。</li><li>由于<code>webpack-dev-server</code>是安装在项目中，而没有在全局中安装，所以无法把它当做脚本命令在<code>powershell</code>终端中直接运行(只有那些安装在全局<code>-g</code>的工具，才能够在终端中正常运行)</li><li>我们可以借助<code>npm</code>来运行我们的工具，在<code>npm</code>生成的<code>package.json</code>配置文件中的<code>scripts</code>属性中添加我们的工具。添加一个属性<code>&quot;dev&quot;: &quot;webpack-dev-server&quot;</code>,然后我们就可以在命令行中执行<code>npm run dev</code>，这样就可以运行我们的<code>webpack-dev-server</code>了。</li></ol><h4 id="webpack-dev-server配置命令"><a href="#webpack-dev-server配置命令" class="headerlink" title="webpack-dev-server配置命令"></a>webpack-dev-server配置命令</h4><ol><li><p>可以直接到<code>package.json</code>文件中的<code>secript</code>中我们自己设置的<code>dev</code>属性的后面添加命令参数。</p><ul><li>设置修改完后自动打开浏览器的命令<code>&quot;dev&quot;: &quot;webpack-dev-server --open&quot;</code></li><li>修改服务器占用的端口号命令<code>&quot;dev&quot;: &quot;webpack-dev-server --open --port 3000&quot;</code></li><li>设置打开浏览器是展示的根路径命令<code>&quot;dev&quot;: &quot;webpack-dev-server --open --port 3000 --contentBase src&quot;</code></li><li><p>启用热重载命令<code>&quot;dev&quot;: &quot;webpack-dev-server --open --port 3000 --contentBase src --hot&quot;</code></p><ul><li>在没有启用热重载时，当我们更新代码时<code>webpack</code>会直接将整个文件全部重新打包一遍，而启用热重载之后每次更新代码之后，将会只更新我们修改过的代码那一部分，而不会将整个文件重新打包。</li><li>启用热重载之后当我们更新css样式时，页面不会整体刷新，会进行异步的请求。</li></ul></li></ul></li><li><p>可以到<code>webpack.config.js</code>中去进行相应的命令配置</p><ul><li>在<code>webpack.config.js</code>中启用热更新，需要在配置文件中引入webpack模块，然后到配置对象中的<code>plugins</code>中加入一个热更新的模块对象，最后才能启用热更新。</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line">devServer: &#123; <span class="comment">//这是配置dev-server命令参数的第二种形式</span></span><br><span class="line">        open: <span class="literal">true</span>,</span><br><span class="line">        port: <span class="number">3000</span>,</span><br><span class="line">        contentBase: <span class="string">'src'</span>,</span><br><span class="line">        hot: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><h3 id="使用html-webpack-plugin插件配置启动页面"><a href="#使用html-webpack-plugin插件配置启动页面" class="headerlink" title="使用html-webpack-plugin插件配置启动页面"></a>使用html-webpack-plugin插件配置启动页面</h3><p>使用html-webpack-plugin的作用有：</p><ol><li>会自动在内存中根据指定的页面生成一个内存中的页面。</li><li>会自动把内存中打包好的<code>bundle.js</code>插入到页面中去，不需要我们手动引入。</li></ol><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ol><li>下载。</li><li>在<code>webpack.config.js</code>文件中引入<code>html-webpack-plugin</code>模块。</li><li>在配置对象中的<code>plugins</code>属性中加入一个<code>htmlWebpackPlugin</code>对象实例。</li><li><p>在这个对象实例中传入配置参数</p><ul><li><code>template</code>属性指定模板页面，将来会根据指定的页面路径，生成内存中的页面</li><li><code>filename</code>指定生成页面的名称</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line">plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">        <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">            template: path.join(__dirname, <span class="string">'./src/index.html'</span>),<span class="comment">//指定模板页面</span></span><br><span class="line">            <span class="comment">//将来会根据指定的页面路径，去生成内存中的页面</span></span><br><span class="line">            filename: <span class="string">'index.html'</span> <span class="comment">//指定生成的页面的名称</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><h3 id="配置处理css样式表的第三方loader"><a href="#配置处理css样式表的第三方loader" class="headerlink" title="配置处理css样式表的第三方loader"></a>配置处理css样式表的第三方loader</h3><p>webpack默认只能打包处理JS类型的文件，无法处理其他非JS类型的文件，如果我们需要在项目中处理其他类型的文件，那么就需要配置处理第三方文件的loader，下面以配置css的loader为例，演示loader的配置。</p><ol><li>安装<code>npm i style-loader css-loader -D</code></li><li>打开<code>webpack.config.js</code>这个配置文件，在配置对象里面，新增一个配置属性，叫做module，他是一个对象，在这个对象身上有个rules属性，这个rules属性是个数组；这个数组中存放了所有的第三方文件的匹配处理规则。</li><li>每个处理规则以对象的形式存在，有两个属性<code>test</code>匹配文件后缀名的正则表达式，第二个属性<code>use</code>匹配之后处理的loader。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="webpack处理第三方文件类型的过程"><a href="#webpack处理第三方文件类型的过程" class="headerlink" title="webpack处理第三方文件类型的过程"></a>webpack处理第三方文件类型的过程</h4><ol><li>发现这个要处理的文件不是JS文件，然后就会去配置文件中，查找有没有对应的第三方loader规则。</li><li>如果能找到对应的规则，就会调用对应的loader处理这种类型的文件。</li><li>在调用loader的时候，是从后往前调用的，后面的loader把文件处理之后再交给前面的loader进行处理，直到调用完所有的loader，然后会把处理结果交给webpack进行打包。</li></ol><h4 id="处理常见的第三方文件需要下载的loader"><a href="#处理常见的第三方文件需要下载的loader" class="headerlink" title="处理常见的第三方文件需要下载的loader"></a>处理常见的第三方文件需要下载的loader</h4><ul><li>处理less文件时需要下载<code>style-loader</code>、<code>css-loader</code>、<code>less-loader</code>在配置文件<code>use</code>属性中也是按照这个顺序设置，在需要处理less文件时，除了下载和设置loader，还需要在项目中下载less的包才能正常处理。</li><li><p>处理url资源，如：图片、字体文件等资源：</p><ul><li>需要按照<code>url-loader</code>和<code>file-loader</code>注意在<code>use</code>中只需要设置<code>url-loader</code>即可，<code>file-loader</code>为内部依赖，不需要配置。</li><li>如果需要向loader中传入参数时可以在<code>use</code>中的loader名称之后通过<code>?</code>传参的方式传递。</li><li><p>在处理图片时默认会转换为<code>base64</code>的格式，我们可以通过设置参数来控制，使小图片转换为<code>base64</code>格式，大图片不转换。</p><ul><li><code>limit</code>参数，设置转换为<code>base64</code>格式的最大文件，文件达到设置的限制，就不会被转换。</li><li><code>name</code>参数，设置文件的名字。为了避免名字重复的情况，<code>url-loader</code>会自动将名字转换为一个随机的<code>hash</code>值，我们可以设置<code>name=[name].[ext]</code>这样子文件在展示的时候就会是文件本身的名字。但是注意我们在磁盘中的文件一个文件夹中不会有两个同名文件，但是我们在使用<code>url-loader</code>之后不会再有文件路径了，只会有文件名，所以如果我们使用了不同文件夹中的相同文件名的两个文件，就会出问题，后面文件会覆盖前面的文件。所以如果想显示本身文件名又要避免文件同名的情况，可以这样做：<code>name=[hash:8]-[name].[ext]</code>,这样就在原文件名的前面添加了8位的hash值，就不会出现重名的情况了。hash值最多是32位。</li></ul></li></ul></li></ul><h3 id="babel的配置"><a href="#babel的配置" class="headerlink" title="babel的配置"></a>babel的配置</h3><p>在webpack中默认只能够处理一部分ES6的新语法，一些更高级的ES6语法或者ES7语法，webpack处理不了，这个时候就需要接触与第三方的loader，来帮助webpack来处理这些高级的语法，当第三方loader把高级语法转为低级语法之后，会把结果交给webpack，打包到bundle.js中。</p><ol><li><p>安装：</p><ul><li>第一套包： <code>npm i babel-core babel-loader babel-plugin-transform-runtime -D</code>，这一套包相当于babel的转换工具。</li><li>第二套包：<code>npm i babel-preset-env babel-preset-stage-0 -D</code>，这一套包中有高级语法到低级语法的对应关系。这里<code>present</code>翻译为语法</li></ul></li><li><p>打开webpack的配置文件，在module节点的rules数组中，添加一个新的匹配规则：</p><ul><li><code>{ test: test: /\.js$/, use: &#39;babel-loader&#39;, exclude:/node_modules/}</code></li><li><p>我们在配置babel的loader规则时，必须把node_modules目录通过exclude选项排除掉。原因有两个：</p><ul><li>如果不排除node_modules，那么babel会把node_modules中所有的第三方JS文件，都打包编译，这样会非常消耗CPU，打包速度也非常慢。</li><li>如果最终node_modules中的JS被转换完毕了，我们的项目也是无法运行的。</li></ul></li></ul></li><li><p>在项目的根目录中新建一个叫做<code>.babelrc</code>的Babel配置文件，这个配置文件，属于JSON格式，所以在写<code>.babelrc</code>配置的时候，必须符合JSON语法的规范。</p><ul><li>在<code>.babelrc</code>中写如下配置:</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>: [<span class="string">"env"</span>, <span class="string">"stage-0"</span>],</span><br><span class="line">    <span class="string">"plugins"</span>: [<span class="string">"transform-runtime"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;webpack起步&quot;&gt;&lt;a href=&quot;#webpack起步&quot; class=&quot;headerlink&quot; title=&quot;webpack起步&quot;&gt;&lt;/a&gt;webpack起步&lt;/h2&gt;&lt;h3 id=&quot;什么是webpack？&quot;&gt;&lt;a href=&quot;#什么是webpack？&quot; c
      
    
    </summary>
    
      <category term="webpack学习笔记" scheme="http://yoursite.com/categories/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>vue.js(四)</title>
    <link href="http://yoursite.com/2018/07/07/vue(%E5%9B%9B)/"/>
    <id>http://yoursite.com/2018/07/07/vue(四)/</id>
    <published>2018-07-06T16:00:00.000Z</published>
    <updated>2018-07-08T05:28:00.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="组件之间的传值"><a href="#组件之间的传值" class="headerlink" title="组件之间的传值"></a>组件之间的传值</h3><h4 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h4><ol><li>父组件可以在使用子组件的时候把值通过属性绑定的形式传递给子组件，如：<code>&lt;son :parentmes=&quot;mes&quot;&gt;&lt;/son&gt;</code></li><li>子组件在使用之前需要在子组件的<code>props</code>这个属性中先定义一下传递过来的值，<code>props</code>属性是一个数组，将传递过来的值的名称以字符串形式放到<code>props</code>里面即可，如：<code>props: [&#39;parentmes&#39;]</code></li><li>使用<code>props</code>中的值和使用<code>data</code>中的值的方法一样。</li></ol><blockquote><p>注意：由父组件传递过来的<code>props</code>中的值是只读的，不能够在子组件中修改。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;son :parentmes=<span class="string">"mes"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;template id="son"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;h1&gt;&#123;&#123;sonMes&#125;&#125;&lt;/</span>h1&gt;</span><br><span class="line">            &lt;h2&gt;&#123;&#123;parentmes&#125;&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">        var vm = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">            el: '#app',</span></span><br><span class="line"><span class="regexp">            data: &#123;</span></span><br><span class="line"><span class="regexp">                mes: '父组件的值'</span></span><br><span class="line"><span class="regexp">            &#125;,</span></span><br><span class="line"><span class="regexp">            components: &#123;</span></span><br><span class="line"><span class="regexp">                son: &#123;</span></span><br><span class="line"><span class="regexp">                    template: '#son',</span></span><br><span class="line"><span class="regexp">                    props: ['parentmes'],</span></span><br><span class="line"><span class="regexp">                    data() &#123;</span></span><br><span class="line"><span class="regexp">                        return &#123;</span></span><br><span class="line"><span class="regexp">                            sonMes: '我是子组件的的mes'</span></span><br><span class="line"><span class="regexp">                        &#125;</span></span><br><span class="line"><span class="regexp">                    &#125;</span></span><br><span class="line"><span class="regexp">                &#125;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h4 id="父组件向子组件传递方法"><a href="#父组件向子组件传递方法" class="headerlink" title="父组件向子组件传递方法"></a>父组件向子组件传递方法</h4><ol><li>父组件可以在在使用子组件的时候利用<code>v-bind:</code>绑定把父组件中的方法传递给子组件，如：<code>&lt;son :parentmes=&quot;mes&quot; @parent-method=&quot;parentMethod&quot;&gt;&lt;/son&gt;</code></li><li>在需要调用父组件传递过来的方法的时候可以使用<code>this.$emit(&#39;parent-method&#39;)</code>来直接调用。如果需要传递参数那么直接在方法名字符串后面传递，如：<code>this.$emit(&#39;parent-method,参数1，参数2&#39;)</code></li><li>通过这个也可以实现子组件向父组件传值。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el: <span class="string">'#app'</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">                mes: <span class="string">'父组件的值'</span>,</span><br><span class="line">                sonData: <span class="string">''</span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                parentMethod (mes) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'我是父组件的方法打印的方法'</span>)</span><br><span class="line">                    <span class="keyword">this</span>.sonData = mes</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            components: &#123;</span><br><span class="line">                son: &#123;</span><br><span class="line">                    template: <span class="string">'#son'</span>,</span><br><span class="line">                    props: [<span class="string">'parentmes'</span>],</span><br><span class="line">                    data() &#123;</span><br><span class="line">                        <span class="keyword">return</span> &#123;</span><br><span class="line">                            sonMes: <span class="string">'我是子组件的的mes'</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    methods: &#123;</span><br><span class="line">                        sonMethod () &#123;</span><br><span class="line">                            <span class="keyword">this</span>.$emit(<span class="string">'parent-method'</span>,<span class="keyword">this</span>.sonMes)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用ref获取DOM元素和组件的引用"><a href="#使用ref获取DOM元素和组件的引用" class="headerlink" title="使用ref获取DOM元素和组件的引用"></a>使用ref获取DOM元素和组件的引用</h3><p>在Vue中不提倡直接操作DOM元素，我们需要对DOM进行操作的时候可以使用<code>Vue</code>中提供的<code>ref</code>来实现</p><ol><li>为需要操作的DOM元素绑定<code>ref=“名称”</code>属性，绑定之后再<code>Vue</code>实例中的<code>$refs</code>属性中就会以对象的形式保存这个DOM元素的引用,属性的名称就是将来访问属性时的<code>key</code>。如：<code>&lt;h1 ref=&quot;domH1&quot;&gt;你好我是h1DOM&lt;/h1&gt;</code></li><li>使用时只需要通过<code>Vue</code>的实例对象来访问<code>$refs</code>属性就可以了，在<code>Vue</code>实例对象内部通过<code>this.$refs.名称</code>即可访问到相应的DOM元素。</li><li>当然通过这种方法我们也可以直接获取到组件的引用，从而在父组件中访问到子组件中所有的<code>data</code>和<code>methods</code>等。</li></ol><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="什么是路由？"><a href="#什么是路由？" class="headerlink" title="什么是路由？"></a>什么是路由？</h4><ol><li>后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；</li><li>前端路由：对应单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要使用hash来实现；</li><li>在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由</li></ol><h4 id="vue-router的基本使用"><a href="#vue-router的基本使用" class="headerlink" title="vue-router的基本使用"></a>vue-router的基本使用</h4><ol><li>当导入了vue-router包之后在window全局对象中，就有了一个路由的构造函数，叫做VueRouter，我们就可以创建一个VueRouter的实例,并且进行相应的配置</li><li><p>设置<code>VueRouter</code>实例中的<code>routes</code>属性，这个属性就是路由的匹配规则，它是一个数组，数组中每个路由匹配规则以对象的形式存在。每个规则对象有两个属性：</p><ul><li>属性1：<code>path</code>表示监听那个路由链接地址</li><li>属性2：<code>component</code>表示当路由地址匹配时所展示的相应的组件，这里传入组件对象</li></ul></li><li><p>把<code>VueRouter</code>实例挂载到<code>vue</code>实例对象的<code>router</code>属性中即可。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> login = &#123;</span><br><span class="line">            template: <span class="string">'#login'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> register = &#123;</span><br><span class="line">            template: <span class="string">'#register'</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> routerObj = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">            </span><br><span class="line">            routes: [&#123;</span><br><span class="line">                    path: <span class="string">'/login'</span>,</span><br><span class="line">                    component: login</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    path: <span class="string">'/register'</span>,</span><br><span class="line">                    component: register</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el: <span class="string">'#app'</span>,</span><br><span class="line">            data: &#123;&#125;,</span><br><span class="line">            methods: &#123;&#125;,</span><br><span class="line">            router: routerObj</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><h5 id="ruter-link的使用"><a href="#ruter-link的使用" class="headerlink" title="ruter-link的使用"></a>ruter-link的使用</h5><ul><li><code>vue-router</code>中提供了一个专门用于路由链接的元素<code>&lt;router-link&gt;</code>，在这个元素中的<code>to</code>属性中设置跳转的路由，前面可以不用加<code>#</code>。</li><li><code>&lt;router-link&gt;</code>默认渲染为一个a链接，当然也可以通过元素的<code>tag</code>属性修改渲染之后的元素</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/login"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/register"</span> <span class="attr">tag</span>=<span class="string">"span"</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="路由redirect重定向的使用"><a href="#路由redirect重定向的使用" class="headerlink" title="路由redirect重定向的使用"></a>路由redirect重定向的使用</h5><p>使用<code>redirect</code>使路由满足条件时不是切换组件而是重定向到某个路由中去。<br>如：<code>{path: &#39;/&#39;, redirect: &#39;/login&#39;},</code>在访问首页时，就会自动切换到<code>login</code>路由加载<code>login</code>的组件</p><h5 id="设置选中路由的样式"><a href="#设置选中路由的样式" class="headerlink" title="设置选中路由的样式"></a>设置选中路由的样式</h5><ul><li>使用<code>&lt;router-link&gt;</code>来控制路由跳转时，被选中的路由会自动添加一个<code>router-link-active</code>的类名，我们就可以利用这个类名来设置选中路由的样式。</li><li>当然我们也可以自定义选中路由的类名，可以在<code>VueRouter</code>实例中设置<code>linkActiveClass</code>属性，来修改默认的选中类名。</li></ul><h4 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h4><ol><li><p>使用query方式传递参数</p><ul><li>可以直接通过修改路由链接，在路由链接后面使用<code>?</code>传参，不用去修改路由规则</li><li>参数保存在<code>Vue</code>实例中的<code>$route.query</code>属性中，以对象的形式存在，需要使用时以对象的方式访问即可,如：<code>$route.query.id</code>即可访问到<code>?</code>后面的id的值。</li></ul></li><li><p>使用<code>params</code>方式传递参数</p><ul><li>这个方法需要改变路由的匹配规则，在路由匹配规则中设置需要传的值，然后在<code>vue-router</code>内部会通过正则表达式来匹配，如果没有格式没有匹配正确，那么就无法显示组件。匹配规则如：<code>path: &#39;/register/:id/:name&#39;</code></li><li>参数保存在<code>Vue</code>实例中的<code>$route.params</code>属性中，以对象的形式存在，需要使用时以对象的方式访问即可,如：<code>$route.params.id</code>即可访问到id的值。</li></ul></li></ol><h4 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h4><ul><li>如果想在一个路由的下面加入子路由，那么可以使用路由规则对象的<code>children</code>属性，这个属性是一个数组，里面放入子路由的路由规则对象。</li><li>子路由的路由规则对象需要注意<code>path</code>属性前面不能带<code>/</code>否则就会以根路径开始请求。</li><li>父路由加载子路由时的跳转链接应该是<code>/父路由/子路由</code>,如：<code>&lt;router-link to=&quot;/account/login&quot;&gt;登录&lt;/router-link&gt;</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> routerObj = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes: [&#123;</span><br><span class="line">        path: <span class="string">'/account'</span>,</span><br><span class="line">        component: account,</span><br><span class="line">        children: [&#123;</span><br><span class="line">                path: <span class="string">'login'</span>,</span><br><span class="line">                component: login</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                path: <span class="string">'register'</span>,</span><br><span class="line">                component: register</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;组件之间的传值&quot;&gt;&lt;a href=&quot;#组件之间的传值&quot; class=&quot;headerlink&quot; title=&quot;组件之间的传值&quot;&gt;&lt;/a&gt;组件之间的传值&lt;/h3&gt;&lt;h4 id=&quot;父组件向子组件传值&quot;&gt;&lt;a href=&quot;#父组件向子组件传值&quot; class=&quot;header
      
    
    </summary>
    
      <category term="vue.js学习笔记" scheme="http://yoursite.com/categories/vue-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>vue.js(三)</title>
    <link href="http://yoursite.com/2018/07/05/vue(%E4%B8%89)/"/>
    <id>http://yoursite.com/2018/07/05/vue(三)/</id>
    <published>2018-07-04T16:00:00.000Z</published>
    <updated>2018-07-18T14:42:47.384Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue组件化"><a href="#Vue组件化" class="headerlink" title="Vue组件化"></a>Vue组件化</h3><h4 id="什么是组件？"><a href="#什么是组件？" class="headerlink" title="什么是组件？"></a>什么是组件？</h4><p>组件的出现就是为了拆分Vue实例的代码量，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可。</p><h4 id="组件化和模块化的区别："><a href="#组件化和模块化的区别：" class="headerlink" title="组件化和模块化的区别："></a>组件化和模块化的区别：</h4><ul><li>模块化：是从代码逻辑的角度进行划分的；方便代码的分层开发，保证每个功能模块的职能单一；</li><li>组件化：是从UI界面的角度进行划分，前端组件化的目的是方便UI组件的重复使用</li></ul><h4 id="创建组件的方式"><a href="#创建组件的方式" class="headerlink" title="创建组件的方式"></a>创建组件的方式</h4><ol><li>使用<code>Vue.extend</code>来创建组件模板对象。在<code>template</code>属性中传入组件的模板字符串也就是组件的HTML结构</li><li>使用<code>Vue.component(&#39;组件名称&#39;,创建出来的组件模板对象)</code></li><li><p>使用组件时只需要把组件名称以HTML标签的形式放到指定的Vue实例的节点里面去</p><ul><li>在设置组件名称时注意如果组件名称以驼峰命名如<code>myCom1</code>那么在使用组件时的标签应该是<code>my-com1</code></li><li>如果没有使用驼峰命名，那么标签名就是组件名</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;my-com1&gt;<span class="xml"><span class="tag">&lt;/<span class="name">my-com1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        Vue.component(<span class="string">'myCom1'</span>, Vue.extend(&#123;</span><br><span class="line">            template: <span class="string">'&lt;h1&gt;这个是使用extend创建的组件&lt;/h1&gt;'</span></span><br><span class="line">        &#125;))</span><br><span class="line">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el: <span class="string">'#app'</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>在设置模板时要注意，模板有且只能有一个根元素，否则会报错。</p></li><li><p>模板对象也可以直接传入一个对象如下所示：</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'myCom1'</span>, &#123;</span><br><span class="line">    template: <span class="string">'&lt;h1&gt;这个是使用extend创建的组件&lt;/h1&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="6"><li>当需要设置复杂的模板时我们也可以在vue实例标签外利用<code>&lt;tempalte&gt;</code>标签来设置</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;my-com1&gt;<span class="xml"><span class="tag">&lt;/<span class="name">my-com1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;template id=<span class="string">"tmp1"</span>&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;我是由template标签创造出来的模板&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &lt;h2&gt;哈哈哈哈&lt;/</span>h2&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>template&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        Vue.component(<span class="string">'myCom1'</span>,&#123;</span><br><span class="line">            template: <span class="string">'#tmp1'</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el: <span class="string">'#app'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h4 id="定义私有组件"><a href="#定义私有组件" class="headerlink" title="定义私有组件"></a>定义私有组件</h4><p>在Vue实例中的<code>components</code>属性中定义私有组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el: <span class="string">'#app2'</span>,</span><br><span class="line">            components: &#123;</span><br><span class="line">                private: &#123;</span><br><span class="line">                    template: <span class="string">'#tmp2'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><h4 id="组件中data"><a href="#组件中data" class="headerlink" title="组件中data"></a>组件中data</h4><p>在每个组件中也是有<code>data</code>和<code>methods</code>等属性的，但是注意组件中的<code>data</code>应该是一个函数，函数返回一个对象，在返回的这个对象中存数据。</p><blockquote><p>这么做的原因是：如果<code>data</code>是以对象形式存在，那么所有组件的<code>data</code>都是指向同一个<code>data</code>，这样子只要改变一个组件的<code>data</code>所有组件的<code>data</code>就都会改变，而如果是通过函数返回<code>data</code>的话每次新建出来的组件的<code>data</code>就是一个重新创建的<code>data</code>了，各组件之间互不影响。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'myCom1'</span>, &#123;</span><br><span class="line">            template: <span class="string">'#tmp1'</span>,</span><br><span class="line">            data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    hello: <span class="string">'hello 组件'</span>,</span><br><span class="line">                    say: <span class="string">''</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                change () &#123;</span><br><span class="line">                    <span class="keyword">this</span>.hello = <span class="keyword">this</span>.say</span><br><span class="line">                    <span class="keyword">this</span>.say = <span class="string">''</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><h4 id="组件的切换"><a href="#组件的切换" class="headerlink" title="组件的切换"></a>组件的切换</h4><h5 id="使用v-if和v-else结合flag进行组件切换"><a href="#使用v-if和v-else结合flag进行组件切换" class="headerlink" title="使用v-if和v-else结合flag进行组件切换"></a>使用<code>v-if</code>和<code>v-else</code>结合flag进行组件切换</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;a href=<span class="string">""</span> @click.prevent=<span class="string">"flag = false"</span>&gt;注册&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;a href="" @click.prevent="flag = true"&gt;登录&lt;/</span>a&gt;</span><br><span class="line">        &lt;log-<span class="keyword">in</span> v-<span class="keyword">if</span>=<span class="string">"flag"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">log-in</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">register</span> <span class="attr">v-else</span>=<span class="string">"flag"</span>&gt;</span><span class="tag">&lt;/<span class="name">register</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;template id=<span class="string">"login"</span>&gt;</span><br><span class="line">        &lt;h1&gt;这是登录页面&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>template&gt;</span><br><span class="line">    &lt;template id=<span class="string">"register"</span>&gt;</span><br><span class="line">        &lt;h1&gt;这是注册页面&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>template&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el: <span class="string">'#app'</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">                flag: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            components: &#123;</span><br><span class="line">                logIn: &#123;</span><br><span class="line">                    template: <span class="string">'#login'</span></span><br><span class="line">                &#125;,</span><br><span class="line">                register: &#123;</span><br><span class="line">                    template: <span class="string">'#register'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h5 id="使用vue提供的component元素实现组件的切换"><a href="#使用vue提供的component元素实现组件的切换" class="headerlink" title="使用vue提供的component元素实现组件的切换"></a>使用vue提供的component元素实现组件的切换</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;a href=<span class="string">""</span> @click.prevent=<span class="string">"tempName = 'register'"</span>&gt;注册&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">        &lt;a href="" @click.prevent="tempName = 'logIn'"&gt;登录&lt;/</span>a&gt;</span><br><span class="line">        &lt;component :is=<span class="string">"tempName"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;template id="login"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h1&gt;这是登录页面&lt;/</span>h1&gt;</span><br><span class="line">    &lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">    &lt;template id="register"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h1&gt;这是注册页面&lt;/</span>h1&gt;</span><br><span class="line">    &lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">        var vm = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">            el: '#app',</span></span><br><span class="line"><span class="regexp">            data: &#123;</span></span><br><span class="line"><span class="regexp">                tempName: 'logIn'</span></span><br><span class="line"><span class="regexp">            &#125;,</span></span><br><span class="line"><span class="regexp">            methods: &#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            &#125;,</span></span><br><span class="line"><span class="regexp">            components: &#123;</span></span><br><span class="line"><span class="regexp">                logIn: &#123;</span></span><br><span class="line"><span class="regexp">                    template: '#login'</span></span><br><span class="line"><span class="regexp">                &#125;,</span></span><br><span class="line"><span class="regexp">                register: &#123;</span></span><br><span class="line"><span class="regexp">                    template: '#register'</span></span><br><span class="line"><span class="regexp">                &#125;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h5 id="在组件切换时应用动画"><a href="#在组件切换时应用动画" class="headerlink" title="在组件切换时应用动画"></a>在组件切换时应用动画</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition name=<span class="string">"tmp"</span> mode=<span class="string">"out-in"</span>&gt;</span><br><span class="line">     &lt;component :is=<span class="string">"tempName"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/transition&gt;</span></span><br></pre></td></tr></table></figure><p>然后使用css设置动画即可，其中<code>mode=&quot;out-in&quot;</code>的作用是设置切换的方式，这里是先消失再出现</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vue组件化&quot;&gt;&lt;a href=&quot;#Vue组件化&quot; class=&quot;headerlink&quot; title=&quot;Vue组件化&quot;&gt;&lt;/a&gt;Vue组件化&lt;/h3&gt;&lt;h4 id=&quot;什么是组件？&quot;&gt;&lt;a href=&quot;#什么是组件？&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="vue.js学习笔记" scheme="http://yoursite.com/categories/vue-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>vue.js(二)</title>
    <link href="http://yoursite.com/2018/07/03/vue(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2018/07/03/vue(二)/</id>
    <published>2018-07-02T16:00:00.000Z</published>
    <updated>2018-07-06T02:25:52.155Z</updated>
    
    <content type="html"><![CDATA[<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>概念： Vue.js允许自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：差值表达式和v-bind表达式，过滤器应该被添加在JavaScript表达式的尾部，由“管道符‘’<code>|</code>指示。</p><h4 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h4><p>在全局条件下创建过滤器就是全局过滤器，所有的<code>Vue</code>实例都可以使用这个过滤器。</p><ul><li>创建：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">'dateFormat'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">dateStr</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(dateStr),</span><br><span class="line">                year = now.getFullYear(),</span><br><span class="line">                month = (now.getMonth() + <span class="number">1</span>).toString().padStart(<span class="number">2</span>,fillString=<span class="string">'0'</span>),</span><br><span class="line">                date = now.getDate().toString().padStart(<span class="number">2</span>,fillString=<span class="string">'0'</span>),</span><br><span class="line">                hour = now.getHours().toString().padStart(<span class="number">2</span>,fillString=<span class="string">'0'</span>),</span><br><span class="line">                minutes = now.getMinutes().toString().padStart(<span class="number">2</span>,fillString=<span class="string">'0'</span>),</span><br><span class="line">                time = <span class="string">`<span class="subst">$&#123;year&#125;</span>-<span class="subst">$&#123;month&#125;</span>-<span class="subst">$&#123;date&#125;</span>  <span class="subst">$&#123;hour&#125;</span>:<span class="subst">$&#123;minutes&#125;</span>`</span></span><br><span class="line">                <span class="keyword">return</span> time</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>上面使用了一个es6的字符串方法，<code>String.prototype.padStart(maxLength,fillString=&#39; XX&#39;)</code>第一个参数是字符串的最大长度，如果没有达到最大长度则从字符串头部开始添加第二个参数，直到满足长度。类似的还有<code>String.prototype.padStart(maxLength,fillString=&#39; XX&#39;)</code>这个是添加到尾部</p></blockquote><ul><li>使用</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.time | dateFormat &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="私有过滤器"><a href="#私有过滤器" class="headerlink" title="私有过滤器"></a>私有过滤器</h4><p>如果想定义一个只有某一个<code>Vue</code>实例才能访问的私有过滤器，需要在<code>Vue</code>实例里面的<code>filters</code>属性中添加过滤方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">           el: <span class="string">'.app'</span>,</span><br><span class="line">           data: &#123;</span><br><span class="line"></span><br><span class="line">           &#125;,</span><br><span class="line">           methods: &#123;</span><br><span class="line"></span><br><span class="line">           &#125;,</span><br><span class="line">           filters: &#123;</span><br><span class="line">               dateFormat: <span class="function"><span class="keyword">function</span> (<span class="params">dateStr</span>) </span>&#123;</span><br><span class="line">                   <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(dateStr),</span><br><span class="line">                       year = now.getFullYear(),</span><br><span class="line">                       month = (now.getMonth() + <span class="number">1</span>).toString().padStart(<span class="number">2</span>, fillString = <span class="string">'0'</span>),</span><br><span class="line">                       date = now.getDate().toString().padStart(<span class="number">2</span>, fillString = <span class="string">'0'</span>),</span><br><span class="line">                       hour = now.getHours().toString().padStart(<span class="number">2</span>, fillString = <span class="string">'0'</span>),</span><br><span class="line">                       minutes = now.getMinutes().toString().padStart(<span class="number">2</span>, fillString = <span class="string">'0'</span>),</span><br><span class="line">                       time = <span class="string">`<span class="subst">$&#123;year&#125;</span>-<span class="subst">$&#123;month&#125;</span>-<span class="subst">$&#123;date&#125;</span>  <span class="subst">$&#123;hour&#125;</span>:<span class="subst">$&#123;minutes&#125;</span>`</span></span><br><span class="line">                   <span class="keyword">return</span> time</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure><h3 id="自定义按键修饰符"><a href="#自定义按键修饰符" class="headerlink" title="自定义按键修饰符"></a>自定义按键修饰符</h3><p>按键修饰符可以控制键盘事件中只有触发特定的键才执行这个事件，比如：当内容输入完成点击回车提交表单。</p><p>框架内置的按键修饰符：</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code></li><li><code>.space</code></li><li><code>.esc</code></li><li><code>.up</code></li><li><code>.dowm</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><p>其他按键需要使用每个键的<code>keyCode</code>来访问，也可以通过全局<code>config.keyCodes</code>对象自定义按键修饰符别名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义按键修饰符</span></span><br><span class="line">Vue.config.keyCodes.f1 = <span class="number">112</span></span><br><span class="line"><span class="comment">//使用按键修饰符来控制事件</span></span><br><span class="line">&lt;input type=<span class="string">"text"</span> @keyup.enter=<span class="string">"add"</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>在需要对普通DOM元素进行底层操作时，可以使用自定义指令，自定义指令的名称不需要带<code>v-</code>，在Vue的底层会自动加上这个前缀，所以在使用的时候<code>v-指令名称</code>。</p><ul><li>全局指令</li></ul><p>自定义全局指令使用<code>Vue</code>对象的<code>directive()</code>方法，第一个参数是指令名称，第二个参数是一个对象，里面是指令的钩子函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'foucs'</span>, &#123;</span><br><span class="line">            bind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123; <span class="comment">//当指令绑定到元素上时，会立即执行bind函数，只执行一次</span></span><br><span class="line">                el.style.color = <span class="string">'red'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123; <span class="comment">//当元素插入到DOM中的时候，会执行inserted函数只触发一次</span></span><br><span class="line">                el.focus()</span><br><span class="line">            &#125;,</span><br><span class="line">            update: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123; <span class="comment">//所在组件的VNode更新时调用，也可能发生在其子VNode更新之前</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><ul><li>私有指令</li></ul><p>可以在<code>Vue</code>实例内部的<code>directives</code>属性内添加私有指令。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el: <span class="string">'.app'</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            directives: &#123;</span><br><span class="line">                focus: &#123;</span><br><span class="line">                    bind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123; <span class="comment">//当指令绑定到元素上时，会立即执行bind函数，只执行一次</span></span><br><span class="line">                        el.style.color = <span class="string">'red'</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123; <span class="comment">//当元素插入到DOM中的时候，会执行inserted函数只触发一次</span></span><br><span class="line">                        el.focus()</span><br><span class="line">                    &#125;,</span><br><span class="line">                    update: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123; <span class="comment">//所在组件的VNode更新时调用，也可能发生在其子VNode更新之前</span></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><h4 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h4><ul><li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li><li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li><li><code>update</code>：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</li><li><code>componentUpdated</code>：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li><li><code>unbind</code>：只调用一次，指令与元素解绑时调用。</li></ul><h4 id="钩子函数的参数"><a href="#钩子函数的参数" class="headerlink" title="钩子函数的参数"></a>钩子函数的参数</h4><ul><li><code>el</code>：指令所绑定的元素，可以用来直接操作 DOM 。</li><li><p><code>binding</code>：一个对象，包含以下属性：</p><ul><li><code>name</code>：指令名，不包括<code>v-</code>前缀。</li><li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code>中，绑定值为 <code>2</code>。</li><li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code>钩子中可用。无论值是否改变都可用。</li><li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li><li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li><li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>{ foo: true, bar: true }</code>。</li><li><code>vnode</code>: Vue 编译生成的虚拟节点。</li><li><code>oldVnode</code>: 上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code>钩子中可用。</li></ul></li></ul><h4 id="简写形式："><a href="#简写形式：" class="headerlink" title="简写形式："></a>简写形式：</h4><p>指令函数中使用比较多的就是<code>bind</code>和<code>update</code>，如果我们只关心这两个状态时触发的行为那么就可以简写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'color-swatch'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">  el.style.backgroundColor = binding.value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h4><p>如果指令需要接受多个值，那么可以传入一个JavaScript对象字面量。指令函数能够接受所有合法的JavaScript表达式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-demo</span>=<span class="string">"&#123; color: 'white', text: 'hello!' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'demo'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(binding.value.color) <span class="comment">// =&gt; "white"</span></span><br><span class="line">  <span class="built_in">console</span>.log(binding.value.text)  <span class="comment">// =&gt; "hello!"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Vue实例的生命周期"><a href="#Vue实例的生命周期" class="headerlink" title="Vue实例的生命周期"></a>Vue实例的生命周期</h3><ul><li>生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！</li><li>声明周期钩子：就是生命周期事件的别名</li><li><p>主要生命周期函数分类：</p><ul><li><p>创建时期的生命周期函数：</p><ul><li>beforeCreate：实例刚在内存中创建出来，还没有初始化好data和methods属性</li><li>created：实例已经在内存中创建出来，此时data和methods已经被创建出来，但是还没有开始编译模板。</li><li>beforeMount：此时已经完成模板的编译，但是还没有挂载到页面中。</li><li>mounted：此时已经编译好了模板，挂载到页面的指定容器中显示了。</li></ul></li><li><p>运行期间的生命周期函数：</p><ul><li>beforeUpdate：状态更新之前执行此函数，此时data中的状态值是最新的，但是界面上显示的数据还是旧的，因为此时还没有开始渲染DOM节点。</li><li>updated：实例更新完毕之后调用此函数，此时data中的状态值和界面上显示的数据，都已经完成了更新，界面被重新渲染好了！</li></ul></li><li><p>销毁期间的生命周期函数：</p><ul><li>beforeDestroy：实例销毁之前调用，在这一步实例任然可以使用。</li><li>destroyed：Vue实例销毁后调用，调用后，Vue实例指示的所有东西都会解绑，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ul></li></ul></li></ul><h3 id="使用vue-resource发送ajax请求"><a href="#使用vue-resource发送ajax请求" class="headerlink" title="使用vue-resource发送ajax请求"></a>使用vue-resource发送ajax请求</h3><p>vue中可以发送ajax请求的第三方包有<code>vue-resource</code>和<code>axios</code></p><ul><li>使用<code>vue-resource</code>发送请求：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在全局中使用</span></span><br><span class="line">Vue.http.get(<span class="string">'/someUrl'</span>, [config]).then(successCallback, errorCallback);</span><br><span class="line">Vue.http.post(<span class="string">'/someUrl'</span>, [body], [config]).then(successCallback, errorCallback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在vue实例中使用</span></span><br><span class="line"><span class="keyword">this</span>.$http.get(<span class="string">'/someUrl'</span>, [config]).then(successCallback, errorCallback);</span><br><span class="line"><span class="keyword">this</span>.$http.post(<span class="string">'/someUrl'</span>, [body], [config]).then(successCallback, errorCallback);</span><br></pre></td></tr></table></figure><ul><li>全局配置数据接口的根域名</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.options.root = <span class="string">'/root'</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：如果在全局配置了数据接口的根域名，那么每次单独发送http请求的时候，请求的url路径时，应该以相对路径开头，前面不能带<code>/</code>，否则不会启用根路径做拼接</p></blockquote><ul><li>全局启用emulateJSON选项</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.options.emulateJSON = <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>这个配置的作用是，在手动发送ajax请求时修改为表单的形式发送请求。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;过滤器&quot;&gt;&lt;a href=&quot;#过滤器&quot; class=&quot;headerlink&quot; title=&quot;过滤器&quot;&gt;&lt;/a&gt;过滤器&lt;/h3&gt;&lt;p&gt;概念： Vue.js允许自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：差值表达式和v-bind表达式，过滤器应
      
    
    </summary>
    
      <category term="vue.js学习笔记" scheme="http://yoursite.com/categories/vue-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>vue.js(五)</title>
    <link href="http://yoursite.com/2018/07/03/vue(%E4%BA%94)/"/>
    <id>http://yoursite.com/2018/07/03/vue(五)/</id>
    <published>2018-07-02T16:00:00.000Z</published>
    <updated>2018-07-10T14:29:05.715Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在vue中监听数据变化的方法"><a href="#在vue中监听数据变化的方法" class="headerlink" title="在vue中监听数据变化的方法"></a>在vue中监听数据变化的方法</h3><ol><li>watch属性。</li></ol><p>这个属性可以监视实例对象中指定数据的变化，然后触发<code>watch</code>中对应的处理函数</p><ul><li>这个属性是一个对象，里面的每个属性的<code>key</code>为实例对象中需要监视的数据的名称，值为数据改变时调用的处理函数。这个处理函数有两个参数第一个是<code>newVal</code>，第二个是<code>oldVal</code>可以在函数中使用这两个值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> watch: &#123;</span><br><span class="line">    <span class="string">'firstName'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fullName = newVal + <span class="string">'-'</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'lastName'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fullName = <span class="keyword">this</span>.firstName + <span class="string">'-'</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'$route.path'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(newVal + <span class="string">'======='</span> + oldVal)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>computed计算属性</li></ol><p>在computed中，可以定义一些属性，这些属性叫做计算属性，计算属性的本质是一个方法，但是在<code>vue</code>的底层会执行这个方法，然后得到方法的返回值，然后这个属性就会被挂载到<code>vue</code>实例中去，我们就可以直接通过<code>vm.计算属性名</code>来访问这个计算属性的计算后的返回值了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    <span class="string">'fullName'</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">'-'</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用vue实例的render方法渲染组件"><a href="#使用vue实例的render方法渲染组件" class="headerlink" title="使用vue实例的render方法渲染组件"></a>使用vue实例的render方法渲染组件</h3><ol><li>render属性是一个方法，这个方法有一个参数<code>createElements</code>，这个参数是一个方法，调用它能够把指定的组件模板渲染为html结构。</li><li>在render的函数中<code>return createElements(模板对象)</code>那么这个组件会替换页面中<code>el</code>指定的那个容器。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElements</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElements(login)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在webpack构建的项目中使用vue"><a href="#在webpack构建的项目中使用vue" class="headerlink" title="在webpack构建的项目中使用vue"></a>在webpack构建的项目中使用vue</h3><h4 id="webpack中导入vue和普通网页中使用script导入vue的区别"><a href="#webpack中导入vue和普通网页中使用script导入vue的区别" class="headerlink" title="webpack中导入vue和普通网页中使用script导入vue的区别"></a>webpack中导入vue和普通网页中使用script导入vue的区别</h4><ol><li>在webpack中通过<code>import Vue from &#39;vue&#39;</code>导入的vue文件是<code>vue.runtime.common.js</code>而我们使用script导入的vue是<code>vue.js</code>文件。</li><li>这个包中的vue模式为<code>runtime-only</code>的形式构建出来的包。</li><li><p>我们在webpack中导入的vue文件是功能不全的文件，所以有些功能是无法使用的。如果想使用<code>vue.js</code>文件，可以做通过以下操作来实现：</p><ul><li>通过路径来导入vue文件<code>import Vue from &#39;../node_modules/vue/dist/vue.js&#39;</code></li><li>直接修改vue包中<code>package.json</code>中的<code>main</code>属性，让<code>main</code>属性中的路径指向<code>vue.js</code></li><li>在webpack的配置文件中添加以下属性：</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    alias: &#123; <span class="comment">// 修改vue导入的时候包的路径</span></span><br><span class="line">        <span class="string">"vue$"</span>: <span class="string">"vue/dist/vue.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在vue中结合render函数渲染指定的组件到容器中"><a href="#在vue中结合render函数渲染指定的组件到容器中" class="headerlink" title="在vue中结合render函数渲染指定的组件到容器中"></a>在vue中结合render函数渲染指定的组件到容器中</h4><p>在<code>runtime-only</code>的条件下我们无法使用<code>components</code>去渲染组件，在这种模式下需要使用一种新的方法来渲染组件。</p><ol><li><p>首先我们需要为组件单独创建文件，文件的后缀名为<code>.vue</code>，文件的内容：</p><ul><li><code>&lt;template&gt;&lt;/template&gt;</code>这里添加html结构。</li><li><code>&lt;script&gt;&lt;/script&gt;</code>这里添加<code>js</code>代码</li><li><code>&lt;style&gt;&lt;/style&gt;</code>这里添加<code>css</code>代码</li></ul></li><li><p>如果要使用<code>.vue</code>类型的文件，我们还需要安装第三方loader。<code>npm i vue-loader vue-template-compiler -D</code>,这里的<code>vue-loader</code>内部依赖于<code>vue-template-compiler</code>,所以在设置<code>rules</code>时只需要<code>use:&#39;vue-loader&#39;</code>即可。</p></li><li>要想使用vue-loader还需要在配置文件中引入插件，这个插件就在<code>vue-loader</code>里面，需要加载到配置文件中：<code>const VueLoaderPlugin = require(&#39;vue-loader/lib/plugin&#39;)</code>,然后再<code>new</code>一个<code>VueLoaderPlugin</code>的对象实例，放到<code>plugins</code>中去。</li><li>将我们创建的<code>.vue</code>结尾的组件文件使用<code>import</code>导入到入口文件中。</li><li>使用<code>render</code>函数渲染组件。</li></ol><h3 id="导入与导出成员"><a href="#导入与导出成员" class="headerlink" title="导入与导出成员"></a>导入与导出成员</h3><p>在ES6中为我们提供了导入与导出成员的方法。</p><ol><li>导入成员使用<code>import 名称 form 文件地址</code>，当在我们的入口文件中碰到这一行代码时，会自动加载并且执行文件地址所指向的文件中的代码，如果我们需要在代码执行完毕之后接受这个文件导出的成员，那么就可以在import后面带上一个任意变量名称，这个变量名称就会接受文件导出的成员，如果不需要接受文件导出的成员，那么可以不加变量名称。这样就只是单纯的执行文件中的代码。</li><li><p>导出成员有两种方式：</p><ul><li><p><code>export default</code> 导出成员</p><ul><li>使用这种方法导出的成员可以使用任意变量来接受。</li><li>在一个模块中<code>export default</code> 只允许向外暴露一次。</li></ul></li><li><p><code>export</code>导出成员</p><ul><li>使用这种方式暴露的成员，只能够使用<code>{ }</code>的形式来接受，这种形式，叫做按需导出。</li><li>这种方式可以导出多个成员，在接受的时候我们想接受那个成员就在<code>{}</code>中添加这个成员导出时的变量名即可。</li><li>在接受成员时必须严格按照导出的时候的名称来接受。</li><li>如果想要更换变量名称那么可以使用<code>as</code>来起别名<code>import preson, {title as header, content} from &#39;./test.js&#39;</code></li></ul></li></ul></li></ol><h3 id="在webpack中使用vue-router"><a href="#在webpack中使用vue-router" class="headerlink" title="在webpack中使用vue-router"></a>在webpack中使用vue-router</h3><ol><li>下载并引入。</li><li>通过<code>Vue.use(VueRouter)</code>手动安装。</li><li>构建组件文件，并引入到页面中。</li><li>创建路由实例，设置路由规则，并挂载到<code>vm</code>实例上去。</li></ol><h3 id="组件中style标签的lang属性和scoped属性"><a href="#组件中style标签的lang属性和scoped属性" class="headerlink" title="组件中style标签的lang属性和scoped属性"></a>组件中style标签的lang属性和scoped属性</h3><ul><li>默认条件下在组件中style标签中设置的是应用于全局的样式。</li><li>给style加上<code>scoped</code>属性之后，就会变成私有样式，只应用于自己这个组件。</li><li>组件中style标签中默认只能写css，如果想使用less或sass需要设置标签的lang属性。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;在vue中监听数据变化的方法&quot;&gt;&lt;a href=&quot;#在vue中监听数据变化的方法&quot; class=&quot;headerlink&quot; title=&quot;在vue中监听数据变化的方法&quot;&gt;&lt;/a&gt;在vue中监听数据变化的方法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;watch属性。&lt;/li&gt;
&lt;/
      
    
    </summary>
    
      <category term="vue.js学习笔记" scheme="http://yoursite.com/categories/vue-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>es6(一)</title>
    <link href="http://yoursite.com/2018/07/02/es6(%E4%B8%80)/"/>
    <id>http://yoursite.com/2018/07/02/es6(一)/</id>
    <published>2018-07-01T16:00:00.000Z</published>
    <updated>2018-07-03T02:03:37.244Z</updated>
    
    <content type="html"><![CDATA[<h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><h4 id="let与var的区别"><a href="#let与var的区别" class="headerlink" title="let与var的区别"></a>let与var的区别</h4><ul><li><code>let</code>所声明的变量只在<code>let</code>命令所在的代码块内有效(for循环的计数器适合使用let声明)</li><li>使用<code>let</code>所声明的变量不存在变量提升，在声明之前使用变量会报错</li><li><code>let</code>不能重复声明同一个变量，也不能在函数内部重新声明变量，这样会报错。</li></ul><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><ul><li>在块级作用域中使用<code>let</code>声明一个变量，那么在执行代码时这个变量就被绑定到了这个块级作用域而不会受外部作用域的影响。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">12</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(tmp)<span class="comment">//ReferenceError: tmp is not defined</span></span><br><span class="line">    <span class="keyword">let</span> tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码在块级作用域中使用<code>let</code>声明了<code>tmp</code>那么在操作<code>tmp</code>时就不会去块级作用域外部寻找了，而变量声明又在使用之后那么就会报错。</p></blockquote><ul><li>如果变量使用<code>let</code>声明那么<code>typeof</code>就不再安全，因为如果在变量声明之前使用<code>typeof 变量</code>那么也会产生语法错误，而没有声明的变量反而不会报错，会返回<code>undefined</code></li></ul><h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><p>ES6新增的块级作用域的特点是：外层作用域无法读取内层作用域的变量。内层作用域可以定义外层作用域的同名变量而不会覆盖外层作用域的变量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;let命令&quot;&gt;&lt;a href=&quot;#let命令&quot; class=&quot;headerlink&quot; title=&quot;let命令&quot;&gt;&lt;/a&gt;let命令&lt;/h3&gt;&lt;h4 id=&quot;let与var的区别&quot;&gt;&lt;a href=&quot;#let与var的区别&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="es6入门读书笔记" scheme="http://yoursite.com/categories/es6%E5%85%A5%E9%97%A8%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>vue.js(一)</title>
    <link href="http://yoursite.com/2018/07/01/vue(%E4%B8%80)/"/>
    <id>http://yoursite.com/2018/07/01/vue(一)/</id>
    <published>2018-06-30T16:00:00.000Z</published>
    <updated>2018-07-02T13:44:42.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><h4 id="数据渲染"><a href="#数据渲染" class="headerlink" title="数据渲染"></a>数据渲染</h4><ol><li><p>起步</p><ul><li>创建一个vue的实例</li><li>通过<code>el</code>属性来绑定要操作的元素。</li><li>在data中存元素需要使用的数据。</li></ul></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"vue"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#vue'</span>,</span></span><br><span class="line"><span class="undefined">        data: &#123;</span></span><br><span class="line"><span class="javascript">            mes: <span class="string">'hello world'</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>渲染与方法：</li></ol><ul><li><p>直接使用模板语法渲染：</p><ul><li>优点：灵活，它只是简单的替换模板语法所在的位置，元素中的其他字符串不受影响</li><li>缺点： 先加载html后加载<code>vue.js</code>文件网速较慢时页面会出现闪烁问题，因为在加载html时模板字符串被当做普通字符串解析，而加载完<code>vue.js</code>文件后模板字符串会被替换成相应的数据，页面会闪烁。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"vue"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; mes + 'world' &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#vue'</span>,</span></span><br><span class="line"><span class="undefined">        data: &#123;</span></span><br><span class="line"><span class="javascript">            mes: <span class="string">'hello '</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>v-loack</code>指令</p><ul><li>给需要渲染数据的元素添加<code>v-cloak</code>属性</li><li>然后通过属性选择器来设置<code>v-cloak</code>属性的元素隐藏</li><li>这样可以解决低网速下闪烁问题</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        [v-cloak] &#123;</span></span><br><span class="line"><span class="undefined">            display: none;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"vue"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123; mes &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#vue'</span>,</span></span><br><span class="line"><span class="undefined">        data: &#123;</span></span><br><span class="line"><span class="javascript">            mes: <span class="string">'hello '</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>v-text</code>指令</p><ul><li><code>v-text</code>指令作用是使用数据替换掉元素内的所有内容</li><li>优点：这样不会引起闪烁问题</li><li>缺点： 元素内所有内容都被替换掉了，处理不够灵活</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"vue"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123; mes &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-text</span>=<span class="string">"mes"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#vue'</span>,</span></span><br><span class="line"><span class="undefined">        data: &#123;</span></span><br><span class="line"><span class="javascript">            mes: <span class="string">'hello '</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>v-html</code>指令</p><ul><li>上面的指令都是插入字符串，就算是有HTML标签的字符串也会被转义直接当做字符串来输出</li><li>如果想插入HTML需要使用<code>v-html</code></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"vue"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123; mes &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-text</span>=<span class="string">"mes"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">"mes2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#vue'</span>,</span></span><br><span class="line"><span class="undefined">        data: &#123;</span></span><br><span class="line"><span class="javascript">            mes: <span class="string">'hello '</span>,</span></span><br><span class="line"><span class="xml">            mes2: '<span class="tag">&lt;<span class="name">h2</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>'</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>v-bind:</code>指令</p><ul><li><code>v-bind:</code>是用来绑定数据的指令</li><li>可以简写为<code>:要绑定的属性</code></li><li><code>v-bind</code>中可以写合法的JS表达式</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"vue"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123; mes &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-text</span>=<span class="string">"mes"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">"mes2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:title</span>=<span class="string">"myTitle"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">:title</span>=<span class="string">"myTitle + ' enen'"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#vue'</span>,</span></span><br><span class="line"><span class="undefined">        data: &#123;</span></span><br><span class="line"><span class="javascript">            mes: <span class="string">'hello '</span>,</span></span><br><span class="line"><span class="xml">            mes2: '<span class="tag">&lt;<span class="name">h2</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>',</span></span><br><span class="line"><span class="javascript">            myTitle: <span class="string">'hello world'</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>vue实例内部的this</p><ul><li>在vue实例的内部的this都是指向vue实例本身。</li><li>可以直接通过this来访问实例本身的属性或方法。</li><li>在<code>data</code>里面的属性和<code>methods</code>里面的方法是直接挂载在vue实例本身，可以直接通过<code>this.属性</code>来直接访问。</li></ul></li><li><p>事件修饰符</p><ul><li>.stop阻止冒泡</li><li>.prevent阻止默认事件</li><li>.capture添加事件监听器时使用事件捕获模式</li><li>.self只当事件在该元素本身(比如不是子元素)触发回调</li><li>.once事件只触发一次</li></ul></li><li><p><code>v-model</code>指令</p><ul><li>使用<code>v-model</code>指令可以实现数据的双向绑定</li><li>之前的<code>v-text</code>和模板语法等只能实现数据单向绑定，即M层—&gt;V层，M层数据改变时V层数据会改变，V层数据改变时M层数据不会改变</li><li>而数据双向绑定则是任何一个层的数据改变都会对方层的数据</li></ul></li></ul><h4 id="通过class控制样式"><a href="#通过class控制样式" class="headerlink" title="通过class控制样式"></a>通过class控制样式</h4><ol><li>数组</li></ol><p>使用<code>v-bind:</code>指令，class中传入类名数组</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">"['red','thin','italic']"</span>&gt;</span>这是一个h1标签啦啦啦<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>三元表达式</li></ol><p>在数组中可以使用三元表达式来控制样式的变化</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">"['red','thin',flag ? 'italic':'']"</span>&gt;</span>这是一个h1标签啦啦啦<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>数组中嵌套对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :class=&quot;[&apos;red&apos;,&apos;thin&apos;,&#123;&apos;italic&apos;: flag&#125;]&quot;&gt;这是一个h1标签啦啦啦&lt;/h1&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>直接传入一个对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :class=&quot;&#123;red: true,thin: false,italic: true&#125;&quot;&gt;这是一个h1标签啦啦啦&lt;/h1&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>传入<code>data</code>中的对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :class=&quot;classObj&quot;&gt;这是一个h1标签啦啦啦&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h4 id="使用内联样式"><a href="#使用内联样式" class="headerlink" title="使用内联样式"></a>使用内联样式</h4><ol><li>直接传入一个<code>data</code>中定义好的对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :style=&quot;styleObj1&quot;&gt;这是一个h1标签啦啦啦&lt;/h1&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>如果想使用多个样式对象传入一个数组就可以了</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 :style=&quot;[styleObj1,styleObj2]&quot;&gt;这是一个h1标签啦啦啦&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h4 id="v-for指令"><a href="#v-for指令" class="headerlink" title="v-for指令"></a>v-for指令</h4><ol><li>可以遍历数组</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-for=&quot;(item, i) in arr&quot;&gt;爱好=====&#123;&#123;item&#125;&#125;=====索引=====&#123;&#123;i&#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>可以遍历对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-for=&quot;(val, key) in obj&quot;&gt;爱好=====&#123;&#123;val&#125;&#125;=====索引=====&#123;&#123;key&#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>循环对象数组</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-for=&quot;(user, i) in arrObj&quot;&gt;姓名=====&#123;&#123;user.name&#125;&#125;=====年龄=====&#123;&#123;user.age&#125;&#125;=====索引=====&#123;&#123;i&#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>迭代数字</li></ol><p>这里数字的迭代是从1开始的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-for=&quot;(count, i) in 10&quot;&gt;&#123;&#123;count&#125;&#125;======&#123;&#123;i&#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>使用<code>v-for</code>时的注意</p><ul><li>当<code>v-for</code>正在更新渲染过的元素列表时，默认使用“就地复用”策略。如果数据项的顺序改变时，Vue将不是移动DOM元素来匹配数据项的顺序，而是简单复用此处每个元素，并保证它在特定索引下已被渲染过的每个元素。</li><li>为了给Vue一个提示，以便它可以跟踪每个节点的身份，从而重用和重新拍序现有元素，所以需要为每项提供一个唯一的key属性</li></ul></li></ol><h4 id="条件指令"><a href="#条件指令" class="headerlink" title="条件指令"></a>条件指令</h4><ol><li><p><code>v-if</code></p><ul><li>这个指令如果不满足条件那么就会移除元素</li><li>适用于那些切换操作少，并且一般情况下不出现在页面中的元素，这样能节省渲染成本</li><li>但是如果是需要频繁切换的元素就不适用，因为这样频繁的移除和创建元素对性能消耗大</li></ul></li><li><p><code>v-show</code></p><ul><li>这个指令如果不满足条件就隐藏元素</li><li>适用于那些切换操作频繁的元素。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本指令&quot;&gt;&lt;a href=&quot;#基本指令&quot; class=&quot;headerlink&quot; title=&quot;基本指令&quot;&gt;&lt;/a&gt;基本指令&lt;/h3&gt;&lt;h4 id=&quot;数据渲染&quot;&gt;&lt;a href=&quot;#数据渲染&quot; class=&quot;headerlink&quot; title=&quot;数据渲染&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="vue.js学习笔记" scheme="http://yoursite.com/categories/vue-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>node.js(六)</title>
    <link href="http://yoursite.com/2018/06/26/node.js(%E5%85%AD)/"/>
    <id>http://yoursite.com/2018/06/26/node.js(六)/</id>
    <published>2018-06-25T16:00:00.000Z</published>
    <updated>2018-06-27T04:59:41.379Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Path模块"><a href="#Path模块" class="headerlink" title="Path模块"></a>Path模块</h3><ul><li><p>path.basename(path[,ext])</p><ul><li>第一个参数时文件路径，当只有一个参数时返回带有扩展名的文件名</li><li>第二个参数和文件的扩展名相同的时候，返回不带扩展名的文件名</li></ul></li><li><p>path.dirname(path)</p><ul><li>获取文件的目录</li></ul></li><li><p>path.extname(path)</p><ul><li>获取文件的扩展名</li></ul></li><li><p>path.isAbsolute(path)</p><ul><li>检验路径是否为绝对路径，返回布尔值</li></ul></li><li><p>path.join([…paths])</p><ul><li>可以自动拼接路径，返回拼接后的路径</li></ul></li><li><p>path.normalize(path)</p><ul><li>可以将路径转换为标准的路径</li></ul></li><li><p>path.parse(path)</p><ul><li><p>把一个路径转为对象</p><ul><li>root根路径</li><li>dir目录</li><li>base包含后缀名的文件名</li><li>ext后缀名</li><li>name不包含后缀名的文件名</li></ul></li></ul></li><li><p>path.format(pathObject)</p></li><li><p>把一个对象转为路径</p></li></ul><h3 id="Node中的其他成员"><a href="#Node中的其他成员" class="headerlink" title="Node中的其他成员"></a>Node中的其他成员</h3><p>在每个模块中，处理<code>require</code>、<code>exports</code>等模块相关API之外，还有两个特殊成员：</p><ul><li><code>_dirname</code>可以用来<strong>动态获取</strong>当前文件模块所属目录的绝对路径</li><li><code>_filename</code>可以用来<strong>动态获取</strong>当前文件夹的绝对路径</li></ul><h4 id="文件操作中的路径问题"><a href="#文件操作中的路径问题" class="headerlink" title="文件操作中的路径问题"></a>文件操作中的路径问题</h4><p>在Node中文件操作的路径被设计为相对于执行node命令所处的路径，所以在node中的文件操作中，相对路径是不靠谱的。</p><ul><li>所以在Node中文件操作统一都使用动态绝对路径来处理，利用<code>_dirname</code>和<code>_filename</code>可以动态获取路径，再加以处理</li><li>在路径拼接过程中最好不要手动拼接，使用<code>path.join()</code>来辅助拼接</li></ul><blockquote><p>注意：模块中的路径标识和这里的路径没有关系，不受影响的(依然是正常的相对路径)</p></blockquote><h3 id="art-template中的子模版与模板继承"><a href="#art-template中的子模版与模板继承" class="headerlink" title="art-template中的子模版与模板继承"></a>art-template中的子模版与模板继承</h3><h4 id="子模板"><a href="#子模板" class="headerlink" title="子模板"></a>子模板</h4><p>art-template可以支持在一个模板中插入另一个模板。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;% include(&apos;./header.art&apos;) %&gt;</span><br><span class="line">&lt;% include(&apos;./header.art&apos;, data) %&gt;</span><br></pre></td></tr></table></figure><h4 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h4><p>利用模板继承可以构建一个包含站点共同元素的基本模板骨架</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--layout.html--&gt;</span></span><br><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123;block 'title'&#125;&#125;My Site&#123;&#123;/block&#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &#123;&#123;block 'head'&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"main.css"</span>&gt;</span></span><br><span class="line">    &#123;&#123;/block&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;&#123;block 'content'&#125;&#125;&#123;&#123;/block&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line">&#123;&#123;extend './layout.art'&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;block 'title'&#125;&#125;&#123;&#123;title&#125;&#125;&#123;&#123;/block&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;block 'head'&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"custom.css"</span>&gt;</span></span><br><span class="line">&#123;&#123;/block&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;block 'content'&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is just an awesome page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;&#123;/block&#125;&#125;</span><br></pre></td></tr></table></figure><p>在渲染index.html时，会自动应用布局骨架</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Path模块&quot;&gt;&lt;a href=&quot;#Path模块&quot; class=&quot;headerlink&quot; title=&quot;Path模块&quot;&gt;&lt;/a&gt;Path模块&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;path.basename(path[,ext])&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数时
      
    
    </summary>
    
      <category term="node.js学习笔记" scheme="http://yoursite.com/categories/node-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>node.js(五)</title>
    <link href="http://yoursite.com/2018/06/25/node.js(%E4%BA%94)/"/>
    <id>http://yoursite.com/2018/06/25/node.js(五)/</id>
    <published>2018-06-24T16:00:00.000Z</published>
    <updated>2018-06-26T05:07:04.269Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><h4 id="关系型数据库和非关系型数据库"><a href="#关系型数据库和非关系型数据库" class="headerlink" title="关系型数据库和非关系型数据库"></a>关系型数据库和非关系型数据库</h4><ul><li><p>关系型数据库</p><ul><li>所有的关系型数据库都需要通过<code>sql</code>语言来进行操作</li><li>所有的关系型数据库在操作之前都需要设计表的结构</li><li>数据表还支持约束</li></ul></li><li><p>非关系型数据库</p><ul><li>非关系型数据库非常灵活</li><li>有的非关系型数据库就是key-value对</li><li><p>MongoDB是最像关系型数据库的非关系型数据库</p><ul><li>数据库——&gt;数据库</li><li>数据表——&gt;集合（数组）</li><li>表记录——&gt;文档对象</li></ul></li></ul></li><li><p>MongoDB不需要设计表结构</p></li><li>可以往里面存任意数据，没有结构性</li></ul><h4 id="启动和关闭数据库"><a href="#启动和关闭数据库" class="headerlink" title="启动和关闭数据库"></a>启动和关闭数据库</h4><p>启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> MongoDB默认使用执行mongod命令所在的盘符根目录下的/data/db作为自己的数据库存储目录</span><br><span class="line"><span class="meta">#</span> 所以在第一次执行命令之前要先手动创建一个/data/db</span><br><span class="line">mongod</span><br></pre></td></tr></table></figure><p>修改默认数据存储目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --dbpath=数据存储目录路径</span><br></pre></td></tr></table></figure><p>停止：直接在开启服务的控制台Ctrl+C即停止</p><h4 id="连接和退出数据库"><a href="#连接和退出数据库" class="headerlink" title="连接和退出数据库"></a>连接和退出数据库</h4><p>连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在数据库开启状态下该命令默认连接本机的MongoDB服务</span><br><span class="line">mongo</span><br></pre></td></tr></table></figure><p>退出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在连接状态下输入exit退出连接</span><br></pre></td></tr></table></figure><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><ul><li><p><code>show dbs</code></p><ul><li>查看显示所有数据库</li></ul></li><li><p><code>db</code></p><ul><li>查看当前操作的数据库</li></ul></li><li><p><code>use 数据库名称</code></p><ul><li>切换到指定的数据(如果没有会自动新建)</li></ul></li><li><p>插入数据</p><ul><li>通过<code>db</code>像JS操作对象一样操作数据</li></ul></li></ul><h4 id="在Node中使用MongoDB"><a href="#在Node中使用MongoDB" class="headerlink" title="在Node中使用MongoDB"></a>在Node中使用MongoDB</h4><ul><li>使用官方的<code>mongodb</code>包来操作</li></ul><blockquote><p>网址：<a href="https://github.com/mongodb/node-mongodb-native" target="_blank" rel="noopener">https://github.com/mongodb/node-mongodb-native</a></p></blockquote><ul><li>使用第三方mongoose来操作MongoDB数据库</li></ul><p>第三方包：<code>mongoose</code>基于MongoDB官方的<code>mongodb</code>包再一次做了封装</p><blockquote><p>官网：<a href="http://mongoosejs.com/" target="_blank" rel="noopener">http://mongoosejs.com/</a><br>官方指南：<a href="http://mongoosejs.com/docs/guide.html" target="_blank" rel="noopener">http://mongoosejs.com/docs/guide.html</a><br>官方api：<a href="http://mongoosejs.com/docs/api.html" target="_blank" rel="noopener">http://mongoosejs.com/docs/api.html</a></p></blockquote><h5 id="使用Mongoose操作数据库"><a href="#使用Mongoose操作数据库" class="headerlink" title="使用Mongoose操作数据库"></a>使用Mongoose操作数据库</h5><h6 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h6><p>在需要使用的js文件中引入模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>)</span><br></pre></td></tr></table></figure><h6 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://localhost/student'</span>)</span><br></pre></td></tr></table></figure><h6 id="设计表的结构"><a href="#设计表的结构" class="headerlink" title="设计表的结构"></a>设计表的结构</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Schema = mongoose.Schema</span><br><span class="line"><span class="keyword">var</span> StudentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    gender: &#123;</span><br><span class="line">        type: <span class="built_in">Number</span>,</span><br><span class="line">        enum: [<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">        <span class="keyword">default</span>:<span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        type: <span class="built_in">Number</span>,</span><br><span class="line">        required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    hobbies: &#123;</span><br><span class="line">        type: <span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="增删改查CRUD"><a href="#增删改查CRUD" class="headerlink" title="增删改查CRUD"></a>增删改查CRUD</h6><p>新增：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> admin = <span class="keyword">new</span> User(&#123;</span><br><span class="line">    username: <span class="string">'admin'</span>,</span><br><span class="line">    password: <span class="string">'12542'</span>,</span><br><span class="line">    email: <span class="string">'admin@123456.com'</span></span><br><span class="line">&#125;)</span><br><span class="line">admin.save(<span class="function"><span class="keyword">function</span> (<span class="params">err, ret</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'保存失败'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'保存成功'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(ret)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>查询：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询所有，返回的是一个数组</span></span><br><span class="line">User.find(<span class="function"><span class="keyword">function</span> (<span class="params">err, ret</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(ret)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按条件查询所有,第一个参数是查询的限制条件，返回的是一个数组</span></span><br><span class="line">User.find(&#123;</span><br><span class="line">    username: <span class="string">'zs'</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, ret</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(ret)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按条件查询单个，第一个参数是查询的限制条件，如果查询到多个则返回第一个，返回的是一个对象</span></span><br><span class="line">User.findOne(&#123;</span><br><span class="line">    username: <span class="string">'zs'</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, ret</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(ret)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>删除：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">User.remove(&#123;</span><br><span class="line">    username: <span class="string">'zs'</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, ret</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'删除失败'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(ret)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'删除成功'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>更新：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据条件查询并更新多条数据，第一个参数是条件，第二个参数是更新后的数据</span></span><br><span class="line">User.updateOne(&#123;<span class="attr">username</span>: <span class="string">'admin'</span>&#125;, &#123;<span class="attr">password</span>: <span class="string">'123'</span>&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, ret</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'更新失败'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'更新成功'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(ret)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据id查询并更新一条数据，第二个参数是id，第二个是更新的数据</span></span><br><span class="line">User.findByIdAndUpdate(<span class="string">'5b311f421d97022a180aa763'</span>,&#123;<span class="attr">password</span>: <span class="string">'123456'</span>&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, ret</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'更新失败'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(ret)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MongoDB&quot;&gt;&lt;a href=&quot;#MongoDB&quot; class=&quot;headerlink&quot; title=&quot;MongoDB&quot;&gt;&lt;/a&gt;MongoDB&lt;/h3&gt;&lt;h4 id=&quot;关系型数据库和非关系型数据库&quot;&gt;&lt;a href=&quot;#关系型数据库和非关系型数据库&quot; cla
      
    
    </summary>
    
      <category term="node.js学习笔记" scheme="http://yoursite.com/categories/node-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>node.js(四)</title>
    <link href="http://yoursite.com/2018/06/24/node.js(%E5%9B%9B)/"/>
    <id>http://yoursite.com/2018/06/24/node.js(四)/</id>
    <published>2018-06-23T16:00:00.000Z</published>
    <updated>2018-06-25T11:36:19.257Z</updated>
    
    <content type="html"><![CDATA[<h4 id="文件操作路径和模块标识路径"><a href="#文件操作路径和模块标识路径" class="headerlink" title="文件操作路径和模块标识路径"></a>文件操作路径和模块标识路径</h4><ul><li>在文件操作中使用相对路径时可以省略<code>./</code>。</li><li>在模块加载中相对路径不能省略<code>./</code>。</li><li>对于这两个操作以<code>/</code>开头都是表示绝对路径，从当前文件模块所处的磁盘根目录开始寻找文件。</li></ul><h4 id="开放公共资源"><a href="#开放公共资源" class="headerlink" title="开放公共资源"></a>开放公共资源</h4><ol><li>第一个参数为公共开放资源的文件名称，第二个参数为公共资源文件夹相对路径，用户可以通过文件的路径访问文件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过http://localhost:3000/public/img/ab3.jpg访问</span></span><br><span class="line">app.use(<span class="string">'/public/'</span>,express.static(<span class="string">'./public/'</span>))</span><br></pre></td></tr></table></figure><ol start="2"><li>省略第一个参数，用户可以省略<code>/public/</code>来访问</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过http://localhost:3000/img/ab3.jpg访问</span></span><br><span class="line">app.use(express.static(<span class="string">'./public/'</span>))</span><br></pre></td></tr></table></figure><ol start="3"><li>第一个参数也可自定义，这样访问时只需要把<code>/public/</code>换成自定义的字符串即可</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过http://localhost:3000/aaa/img/ab3.jpg访问</span></span><br><span class="line">app.use(<span class="string">'/aaa/'</span>,express.static(<span class="string">'./public/'</span>))</span><br></pre></td></tr></table></figure><h4 id="在express中使用art-template"><a href="#在express中使用art-template" class="headerlink" title="在express中使用art-template"></a>在express中使用art-template</h4><ul><li>配置express：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.engine(<span class="string">'html'</span>, <span class="built_in">require</span>(<span class="string">'express-art-template'</span>))</span><br></pre></td></tr></table></figure><ul><li><p>利用express使用art-template</p><ul><li>Express为Response对应的对象提供了一个方法:<code>render</code></li><li>通过配置之后才可以使用<code>render</code>方法</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.render(<span class="string">'html模板名'</span>, &#123;模板数据&#125;)</span><br></pre></td></tr></table></figure><ul><li>这里第一个参数不能写路径。直接写模板的文件名，Express默认约定开发人员把所有的视图文件都放到views目录中。</li><li>如果想要修改默认的views目录，可以<code>app.set(&#39;views&#39;, render函数的默认路径)</code></li></ul><h4 id="配置express解析表单POST请求体的中间件"><a href="#配置express解析表单POST请求体的中间件" class="headerlink" title="配置express解析表单POST请求体的中间件"></a>配置express解析表单POST请求体的中间件</h4><p>express中没有解析请求体的方法，需要下载<code>body-parser</code>中间件才能够处理请求体</p><ol><li>下载：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install body-parser</span><br></pre></td></tr></table></figure><ol start="2"><li>载入模块：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>配置：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br><span class="line">app.use(bodyParser.json())</span><br></pre></td></tr></table></figure><ol start="4"><li>使用：直接通过<code>req.body</code>来获取请求体中的信息，以json格式存在</li></ol><h4 id="路由设计"><a href="#路由设计" class="headerlink" title="路由设计"></a>路由设计</h4><ol><li>编写说明文档，文档中规定好路由和请求方法参数等</li><li>单独提取路由模块，把路由模块放到一个单独文件单独处理</li><li>通过Express提供的api来让路由模块中的方法可以到入口模块中使用</li><li>创建一个路由容器</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> router = express.Router()</span><br></pre></td></tr></table></figure><ol start="5"><li>然后把所有的路由操作函数都挂载到<code>router</code>上 </li><li>最后通过<code>module.exports = router</code>导出<code>router</code></li><li>在使用的时候加载路由这个文件并且执行相应的配置</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">'./router'</span>)</span><br><span class="line">app.use(router)</span><br></pre></td></tr></table></figure><h4 id="模块的设计"><a href="#模块的设计" class="headerlink" title="模块的设计"></a>模块的设计</h4><ol><li>模块化编程的目的是增强代码的可维护性，提高开发的效率</li><li>每个模块的职责要单一，不能够混乱操作</li><li>每个项目最好只有一个入口</li></ol><h4 id="es6的新增数组方法find和findindex"><a href="#es6的新增数组方法find和findindex" class="headerlink" title="es6的新增数组方法find和findindex"></a>es6的新增数组方法find和findindex</h4><ul><li>find方法可以根据条件查找数组中满足条件的指定项，返回该项。</li><li>findindex方法可以根据条件查找数组中满足条件的指定项的索引，返回索引</li><li>这两个方法由数组调用，参数为一个函数。原理是相同的</li></ul><p>底层实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.find = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt;= <span class="keyword">this</span>.length ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback(<span class="keyword">this</span>[i],i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;文件操作路径和模块标识路径&quot;&gt;&lt;a href=&quot;#文件操作路径和模块标识路径&quot; class=&quot;headerlink&quot; title=&quot;文件操作路径和模块标识路径&quot;&gt;&lt;/a&gt;文件操作路径和模块标识路径&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在文件操作中使用相对路径时可以省略&lt;co
      
    
    </summary>
    
      <category term="node.js学习笔记" scheme="http://yoursite.com/categories/node-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>node.js(三)</title>
    <link href="http://yoursite.com/2018/06/23/node.js(%E4%B8%89)/"/>
    <id>http://yoursite.com/2018/06/23/node.js(三)/</id>
    <published>2018-06-22T16:00:00.000Z</published>
    <updated>2018-06-23T13:33:51.106Z</updated>
    
    <content type="html"><![CDATA[<h3 id="node中的模块系统"><a href="#node中的模块系统" class="headerlink" title="node中的模块系统"></a>node中的模块系统</h3><ol><li><p>模块系统包括：</p><ul><li>核心模块</li><li>第三方模块</li><li>自己写的模块</li><li>加载规则以及加载机制</li></ul></li><li><p>模块的使用</p><ul><li>node中通过<code>require</code>方法来载入模块。</li><li>node中具有模块作用域，加载模块只是执行模块的代码，而无法再一个模块外部直接访问被加载的模块里面的成员。</li><li>要想访问加载模块里面的成员，我们可以接受<code>require</code>方法的返回值，这个方法返回的是一个对象。</li><li>如果被加载的模块想把成员传递到外部模块去，可以将成员挂载到<code>exports</code>这个对象上去，但是注意一定时通过对象的方法挂载，而不能直接给<code>exports</code>赋值。</li><li>如果想把一个成员直接传递给外部模块那么可以直接给<code>module.exports</code>赋值，这样载入模块的返回值就是这个成员。</li><li>在模块执行的最后，默认返回<code>module.exports</code>，那么挂载在<code>module.exports</code>上面的成员也就在返回值里面了。</li></ul></li><li><p>模块原理</p><ul><li>在node中每个模块内部都有一个自己的<code>module</code>对象，在该<code>module</code>对象中，有一个成员<code>exports</code>也是一个对象。</li><li>当我们需要对外导出成员时，只需要把导出成员挂载到<code>module.exports</code>中，但是如果每次导出接口成员时都通过<code>module.exports.xxx=xxx</code>的方式就很麻烦</li><li>为了解决上一个问题，node在模块内部默认做了一个这样的操作：<code>var exports = module.exports</code>，所以<code>exports</code>与<code>module.exports</code>共同指向同一个对象，我们在<code>exports</code>上挂载成员时，<code>module.exports</code>也会改变，因为他们本质上指向的是同一个对象。</li><li>当我们给<code>exports</code>赋值后，<code>exports</code>的指向就改变了,不再和<code>module.exports</code>指向同一个对象，而最后返回的是<code>module.exports</code>，所以给<code>exports</code>赋值无法导出成员。</li><li>当我们给<code>module.exports</code>赋值后，<code>module.exports</code>的指向也就改变了，不再和<code>exports</code>指向同一个对象，那么之后如果再对<code>exports</code>进操作就无法影响<code>module.exports</code>，除非通过代码改变<code>exports</code>的指向：<code>exports = module.exports</code>再次建立它们的关系</li></ul></li><li><p>require方法与加载规则</p><ul><li><p>优先从缓存加载</p><ul><li>在执行代码时，如果已经加载过一个模块了，之后再次<code>require</code>这个模块就不会重复加载了。</li><li>再次<code>require</code>这个模块会返回接口对象，但是不会重复执行里面的代码，这样能避免重复加载，提高模块加载效率</li></ul></li><li><p>核心模块的加载</p><ul><li>核心模块本质上也是文件，核心模块的文件已经被编译到了二进制数据中了，只需要按照名字来加载就可以了。</li></ul></li><li><p>路径模块（自定义模块）</p><ul><li>自定义模块要以路径形式来加载</li><li><code>./</code>当前目录</li><li><code>../</code>上一级目录</li><li><code>/xxx</code>这里的<code>/</code>表示的是当前文件模块所属磁盘根路径</li><li>在加载自定义模块时，一定不能省略上面的路径标识，可以省略后缀名<code>.js</code></li></ul></li><li><p>第三方模块的加载</p><ul><li>凡是第三方模块都必须通过npm来下载</li><li>使用的时候可以通过<code>require(&#39;包名&#39;)</code>的方式来进行加载才可以使用</li><li>任何一个第三方的包名都不会和核心模块的名字一样</li></ul></li><li><p>第三方模块查找顺序 ( 以<code>art-template</code>为例 )</p></li></ul></li></ol><blockquote><ol><li>判断是否是核心模块，或者是路径模块，如果都不是那就按第三方模块规则来查找</li><li>首先查找当前文件所处目录中的<code>node_modules</code>目录</li><li>找到<code>node_modules/art-template</code></li><li>找到<code>node_modules/art-template/package.json</code>文件</li><li>找到<code>node_modules/art-template/package.json</code>文件中的main属性</li><li>main属性中记录了<code>art-template</code>的入口模块。</li><li>加载使用这个第三方包，这里本质上加载的还是文件。</li></ol><ul><li>异常情况<ul><li>如果<code>package.json</code>文件不存在或者main指定的入口模块没有，那么node会自动寻找该目录下的<code>index.js</code>,<code>index.js</code>会作为默认备选项。</li><li>如果上面的条件有一个不成立，那么会进入上一级目录中的<code>node_modules</code>目录中查找，重复2-7的操作，如果有异常自动到上上级查找，重复操作，</li><li>如果最后到磁盘根目录还是没有找到最后就会报错<code>can not find module xxx</code></li><li>在查找时只会在上级目录根目录下查找是否有<code>node_modules</code>文件，而不会到根目录下的子目录里面去查找。（这一点和js的作用域链很相似）</li></ul></li></ul></blockquote><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><ul><li>node package manager</li></ul><h4 id="npm-网站"><a href="#npm-网站" class="headerlink" title="npm 网站"></a>npm 网站</h4><blockquote><p>npmjs.com</p></blockquote><h4 id="npm命令行工具"><a href="#npm命令行工具" class="headerlink" title="npm命令行工具"></a>npm命令行工具</h4><p>查看npm版本的命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm --version</span><br></pre></td></tr></table></figure></p><p>升级npm：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global npm</span><br></pre></td></tr></table></figure></p><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><ul><li><p>npm init </p><ul><li>生成包描述文件</li><li>npm init -y 跳过向导快速生成</li></ul></li><li><p>npm install</p><ul><li>一次性把dependencies选项中的依赖全部下载下来</li><li>npm i</li></ul></li><li><p>npm install 包名</p><ul><li>只下载一个包</li><li>npm i 包名</li></ul></li><li><p>npm install –save 包名</p><ul><li>下载并保存依赖项</li><li>npm i –S 包名</li></ul></li><li><p>npm uninstall 包名</p><ul><li>只删除指定的包，但是如果这个包有依赖项，依赖项不会被删除</li></ul></li><li><p>npm uninstall – save 包名</p><ul><li>删除的同时也会把依赖信息也清除</li><li>npm un -S 包名</li></ul></li><li><p>npm –help</p><ul><li>查看帮助</li></ul></li><li><p>npm 命令 –help</p><ul><li>查看指定命令的帮助</li></ul></li></ul><h3 id="package-json（包描述文件）"><a href="#package-json（包描述文件）" class="headerlink" title="package.json（包描述文件）"></a>package.json（包描述文件）</h3><ul><li>建议在每个项目的根目录下都有一个<code>package.js</code>文件</li><li>这个文件可以通过<code>npm init</code>的方式自动初始化出来。</li><li>文件里面的<code>dependencies</code>选项中可以保存第三方包的依赖信息。</li><li>建议在执行<code>npm install 包名</code>的时候都加上<code>--sava</code>这个选项，目的是用来保存依赖信息</li><li>如果文件中的<code>node_modules</code>被删除了也不用担心，我们只需要：<code>npm install</code>就会自动把<code>dependencies</code>里面所有的包下载下来。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;node中的模块系统&quot;&gt;&lt;a href=&quot;#node中的模块系统&quot; class=&quot;headerlink&quot; title=&quot;node中的模块系统&quot;&gt;&lt;/a&gt;node中的模块系统&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;模块系统包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心模块&lt;/li
      
    
    </summary>
    
      <category term="node.js学习笔记" scheme="http://yoursite.com/categories/node-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>node.js(二)</title>
    <link href="http://yoursite.com/2018/06/20/node.js(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2018/06/20/node.js(二)/</id>
    <published>2018-06-19T16:00:00.000Z</published>
    <updated>2018-06-23T04:39:37.738Z</updated>
    
    <content type="html"><![CDATA[<h3 id="node中模板引擎的使用"><a href="#node中模板引擎的使用" class="headerlink" title="node中模板引擎的使用"></a>node中模板引擎的使用</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li>安装npm install art-template</li><li><p>在需要使用的文件模块加载art-template</p><ul><li>只需要使用require方法加载就可以了：require（‘art-template’）</li></ul></li><li><p>查文档，使用模板引擎API</p></li></ol><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol><li>创建一个HTML模板文件</li><li><p>通过<code>fs</code>模块的<code>readFile</code>方法加载模板文件</p><ul><li>默认读取到的是二进制数据，而模板引擎中接受的应该是字符串，所以需要通过<code>toString</code>方法把二进制数据转换成字符串</li></ul></li><li><p>通过模板引擎的<code>render</code>方法进行模板的渲染</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> template = <span class="built_in">require</span>(<span class="string">'art-template'</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./tpl.html'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取文件失败了'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 默认读取到的 data 是二进制数据</span></span><br><span class="line">  <span class="comment">// 而模板引擎的 render 方法需要接收的是字符串</span></span><br><span class="line">  <span class="comment">// 所以我们在这里需要把 data 二进制数据转为 字符串 才可以给模板引擎使用</span></span><br><span class="line">  <span class="keyword">var</span> ret = template.render(data.toString(), &#123;</span><br><span class="line">    name: <span class="string">'Jack'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    province: <span class="string">'北京市'</span>,</span><br><span class="line">    hobbies: [</span><br><span class="line">      <span class="string">'写代码'</span>,</span><br><span class="line">      <span class="string">'唱歌'</span>,</span><br><span class="line">      <span class="string">'打游戏'</span></span><br><span class="line">    ],</span><br><span class="line">    title: <span class="string">'个人信息'</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(ret)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="留言本案例"><a href="#留言本案例" class="headerlink" title="留言本案例"></a>留言本案例</h3><ol><li>路径问题</li></ol><blockquote><p>在服务端中，文件的路径不要使用相对路径，因为在这个时候所有的资源都是通过url标识符来获取的，比如说我的服务器开放了<code>/public/</code>目录，那么请求路径就都写成<code>/public/xxx</code>这里<code>/</code>是url根路径的意思。</p></blockquote><ol start="2"><li>文件结构问题</li></ol><blockquote><ol><li>把当前模块所有的依赖项都声明在文件模块最上面</li><li>为了让目录结构清晰统一，我们约定，把所有HTML文件都放在views(视图)目录中</li><li>为了方便统一处理静态资源，我们约定把所有的静态资源都存放在public目录中</li><li>我们可以通过代码控制那些资源可以被用户访问，那些资源不能被用户访问，这里我们开放整个public目录</li></ol></blockquote><ol start="3"><li>处理客户端发送的请求</li></ol><blockquote><p>我们可以根据客户端的请求路径来进行相应的操作，但是当涉及到客户端在url中传递参数时，路径就不一致了，所以我们要通过<code>?</code>前面的请求路径来判断客户端需要请求的操作。</p></blockquote><ul><li>使用<code>url.parse</code>方法可以将请求路径解析为方便操作的对象，第二个参数true表示直接将查询字符串转换为对象<code>var parseObj = url.parse(req.url, true)</code></li><li>获取不包含参数的请求路径<code>var pathname = parseObj.pathname</code></li><li>根据<code>pathname</code>来进行相应的操作</li><li>当用户请求路径为<code>/</code>时，服务端到数据库中查询数据，通过模板引擎渲染，然后把渲染过后的字符串发送给客户端。</li><li><p>当用户请求路径为<code>/addComments?xxx</code>时</p><ul><li>获取表单提交的数据<code>var comment = parseObj.query</code></li><li>将当前的时间日期添加到数据对象中<code>comment.dateTime = &#39;2017-11-2 17:11:22&#39;</code></li><li>将新的数据对象添加到数据库中</li><li>让用户重定向到首页，这个时候数据库中的数据已经发生变化，用户看到的页面也发生了变化</li></ul></li><li><p>如何通过服务器让客户端重定向？</p></li></ul><blockquote><ol><li>设置响应状态码<code>res.statusCode= 302</code>状态码302为临时重定向</li><li>在响应头中通过Location告诉客户端重定向去哪里<code>res.setHeader(&#39;Location&#39;, &#39;/&#39;)</code></li></ol></blockquote><ul><li><p>状态码302与301的区别</p><ul><li>301是永久重定向，当设置状态码为301时，浏览器会把它储存到缓存中，当下次再次请求这个地址时，在浏览器端就会直接阻止这个请求，而是去请求之前重定向的页面。</li><li>302是临时重定向，浏览器不会储存，当下次再次请求这个地址时，依然会把这个请求发送到服务端。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;node中模板引擎的使用&quot;&gt;&lt;a href=&quot;#node中模板引擎的使用&quot; class=&quot;headerlink&quot; title=&quot;node中模板引擎的使用&quot;&gt;&lt;/a&gt;node中模板引擎的使用&lt;/h3&gt;&lt;h4 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; cla
      
    
    </summary>
    
      <category term="node.js学习笔记" scheme="http://yoursite.com/categories/node-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>node.js(一)</title>
    <link href="http://yoursite.com/2018/06/04/node.js(%E4%B8%80)/"/>
    <id>http://yoursite.com/2018/06/04/node.js(一)/</id>
    <published>2018-06-03T16:00:00.000Z</published>
    <updated>2018-06-04T15:02:49.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Node-js是什么"><a href="#Node-js是什么" class="headerlink" title="Node.js是什么"></a>Node.js是什么</h3><ul><li><p>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. </p><ul><li>Node.js不是一门语言</li><li>Node.js不是库、不是框架</li><li>Node.js是一个JavaScript运行环境</li><li>Node.js可以解析和执行JavaScript代码</li><li>Node.js可以让JavaScript代码完全脱离浏览器运行</li></ul></li><li><p>浏览器中的JavaScript</p><ul><li><p>ECMAScript</p><ul><li>基本语法</li><li>语句</li><li>函数</li><li>对象</li></ul></li><li><p>BOM</p></li><li>DOM</li></ul></li><li><p>Node.js中的JavaScript</p><ul><li>没有BOM、DOM</li><li>ECMAScript</li><li><p>在Node这个JavaScript执行环境中为JavaScript提供了一些服务器级别的操作API</p><ul><li>例如文件的读写</li><li>网络服务的构建</li><li>网络通信</li><li>http服务器</li><li>等处理。。。</li></ul></li></ul></li><li><p>构建在Chrome的V8引擎之上</p><ul><li>代码只是具有特定格式的字符串</li><li>引擎可以认识它，引擎可以去解析和执行代码</li><li>Node.js的作者把Google Chrome中的V8引擎移植出来，开发了一个独立的JavaScript运行环境</li></ul></li><li><p>Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.</p><ul><li>event-driven事件驱动</li><li>non-blocking I/O model 非阻塞模型（异步）</li><li>lightweight and efficient 轻量和高效</li></ul></li></ul><ul><li><p>Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world.</p><ul><li>npm 是世界上最大的开源库生态系统</li><li>绝大多数JavaScript相关的包都存放在npm上，可以更方便的去下载使用</li><li><code>npm install jQuery</code></li></ul></li><li><p>Node.js一些资源</p><ul><li>《深入浅出Node.js》</li><li>《Node.js权威指南》</li><li>JavaScript标准参考教程（alpha）：<a href="http://javascript.ruanyifeng.com/nodejs/basic.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/nodejs/basic.html</a></li><li>Node入门：<a href="http://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener">http://www.nodebeginner.org/index-zh-cn.html</a></li><li>官方API文档：<a href="http://node.js.org/dist/latest-v6.x/docs/api" target="_blank" rel="noopener">http://node.js.org/dist/latest-v6.x/docs/api</a></li><li>中文文档：<a href="http://www.nodeclass.com/api/node.html" target="_blank" rel="noopener">http://www.nodeclass.com/api/node.html</a></li><li>CNODE社区：<a href="http://cnode.js.org" target="_blank" rel="noopener">http://cnode.js.org</a></li><li>CNODE-新手入门：<a href="http://cnodejs.org/getstart" target="_blank" rel="noopener">http://cnodejs.org/getstart</a></li></ul></li></ul><h3 id="学习node的目的"><a href="#学习node的目的" class="headerlink" title="学习node的目的"></a>学习node的目的</h3><ul><li><p>B/S编程模型</p><ul><li>Browser-Server</li><li>back-end</li><li>任何服务器技术这种BS编程模型都一样，和语言无关</li><li>node只是学习BS编程模型的一个工具</li></ul></li><li><p>模块化编程</p><ul><li>RequireJS</li><li>SeaJS</li><li>在Node中可以引用加载JavaScript脚本文件</li></ul></li><li><p>Node常用API</p></li><li><p>异步编程</p><ul><li>回调函数</li><li>promise</li><li>async</li><li>generator</li></ul></li><li><p>Express web开发框架</p></li><li>ECMAScript6</li></ul><h3 id="初步体验node-js"><a href="#初步体验node-js" class="headerlink" title="初步体验node.js"></a>初步体验node.js</h3><ol><li><p>Hello World</p><ul><li>解析执行JavaScript</li></ul></li></ol><ul><li><p>使用node运行js文件的步骤</p><ol><li>创建编写JavaScript脚本文件</li><li>打开终端，定位到脚本文件所属目录</li><li>输入<code>node 文件名</code>执行对应的文件<br>注意：文件名不用使用<code>node.js</code>来命名，最好不要使用中文名。</li></ol><ul><li>读写文件</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*fs是filesystem的简写，就是文件系统的意思</span></span><br><span class="line"><span class="comment"> 在node中如果想要进行文件操作，就必须引入fs这个核心模块</span></span><br><span class="line"><span class="comment"> 在fs这个核心模块中提供了所有的文件操作相关的API</span></span><br><span class="line"><span class="comment"> 例如：fs.redFile就是用来读取文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1.使用require方法加载fs核心模块</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.读取文件</span></span><br><span class="line"><span class="comment"> 第一个参数是读取文件的路径</span></span><br><span class="line"><span class="comment"> 第二个参数是一个回调函数</span></span><br><span class="line"><span class="comment"> 参数：data error</span></span><br><span class="line"><span class="comment"> 读取成功</span></span><br><span class="line"><span class="comment"> data  是数据</span></span><br><span class="line"><span class="comment"> error null</span></span><br><span class="line"><span class="comment"> 读取失败</span></span><br><span class="line"><span class="comment"> data 是undefined</span></span><br><span class="line"><span class="comment"> error是错误对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fs.readFile(<span class="string">'./data/hello.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error,data</span>) </span>&#123;</span><br><span class="line"> <span class="comment">//&lt;Buffer 68 65 6c 6c 6f 20 6e 6f 64 65 6a 73&gt;</span></span><br><span class="line"> <span class="comment">//文件中储存的是二级制数据 0 1</span></span><br><span class="line"> <span class="comment">//这里把二进制数据转换为了16机制</span></span><br><span class="line"> <span class="comment">//我们可以通过toString方法把其转为我能认识的字符</span></span><br><span class="line"> <span class="keyword">if</span>(error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'文件读取失败'</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写文件</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数：文件路径</span></span><br><span class="line"><span class="comment">//第二个参数：文件内容</span></span><br><span class="line"><span class="comment">//第三个参数：回调函数</span></span><br><span class="line"><span class="comment">//接受一个参数 error</span></span><br><span class="line"><span class="comment">//写入成功error是null 写入失败error是错误对象</span></span><br><span class="line">fs.writeFile(<span class="string">'./data/你好.md'</span>,<span class="string">'大家好，我是nodejs'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'文件写入失败'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'文件写入成功'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>http</li></ul><p>最简单的http服务：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node中专门提供了一个核心模块：http</span></span><br><span class="line"><span class="comment">//http 这个模块的职责就是帮你创建编写服务器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 加载http核心模块</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用http.createServer()方法创建一个web服务器</span></span><br><span class="line"><span class="comment">//       返回一个Server 实例</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用服务器</span></span><br><span class="line"><span class="comment">//    服务器是提供对数据的服务的</span></span><br><span class="line"><span class="comment">//     发请求——&gt;接受请求——&gt;处理请求——&gt;发送响应</span></span><br><span class="line"><span class="comment">//    注册request请求事件，当客户端请求过来，就会自动触发服务器的request请求事件，然后执行第二个参数：回调处理函数</span></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'收到客户端的请求了'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 绑定端口号，启动服务器</span></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'服务器启动成功。'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="node中的JS模块系统"><a href="#node中的JS模块系统" class="headerlink" title="node中的JS模块系统"></a>node中的JS模块系统</h3><ol><li><p>require的作用</p><ul><li>require是一个方法，它的作用是用来加载模块的</li><li>代码执行时碰到这个方法会去执行模块文件中的代码，然后再执行之后的代码。</li><li>require方法还有另一个作用，可以实现模块之间的通信。</li></ul></li><li><p>node中，模块有三种：</p><ul><li>具名的核心模块。例如：fs、http</li><li><p>用户自己编写的文件模块。加载自己的文件模块时注意：</p><ul><li>相对路径必须加<code>./</code></li><li>可以省略后缀名</li><li>相对路径中<code>./</code>不能省略，否则会报错</li></ul></li></ul></li><li><p>在node中，没有全局作用域，只有模块作用域</p><ul><li>模块内部和外部不能互相访问，默认都是封闭的。</li><li>不同模块之间无法访问到对方的方法和变量，只是简单执行了模块里面的代码</li></ul></li><li><p>模块之间的通信：</p><ul><li>require方法还能够拿到被加载文件模块导出的接口对象</li><li>在每个文件模块都提供一个对象：<code>exports</code></li><li><code>exports</code>默认是一个空对象</li><li>我们只需要把需要被外部访问的成员挂载在exports对象中，就可以了</li><li>require对象的返回值就是被加载模块的exports对象</li></ul></li><li><p>content-type</p><ul><li>在服务端发送给客户端的数据默认是utf8编码的，但是浏览器不知道内容是utf8编码的内容。</li><li>浏览器在不知道服务器响应内容的编码的情况下会按照当前操作系统默认编码去解析。中文操作系统默认是gbk，所以在设置编码格式的情况下中文会乱码</li><li>解决办法就是正确的告诉浏览器服务器发送给你的数据是什么编码的。</li><li>在http协议中，Content-type就是用来告诉浏览器我发送的数据是什么类型</li><li><code>res.setHeader(&quot;Content-Type&quot;,&#39;text/plain: charset=utf-8&#39;)</code>可以设置响应体的数据类型。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Node-js是什么&quot;&gt;&lt;a href=&quot;#Node-js是什么&quot; class=&quot;headerlink&quot; title=&quot;Node.js是什么&quot;&gt;&lt;/a&gt;Node.js是什么&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Node.js® is a JavaScript runt
      
    
    </summary>
    
      <category term="node.js学习笔记" scheme="http://yoursite.com/categories/node-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
