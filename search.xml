<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构基础]]></title>
    <url>%2F2018%2F08%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[栈栈是一种遵从先进后出原则的有序集合。新添加的或待删除的元素都保存在栈的同一端，称为栈顶，另一端叫做栈底。新元素都靠近栈顶，旧元素都接近栈底。 创建一个栈，并且让这个栈有一些基本的方法 push()：添加一个(或多个)新元素到栈顶。 pop()：移除栈顶的元素，同时返回被移除的元素。 peek()：返回栈顶的元素，不修改栈。 isEmpty()：如果栈里没有任何元素返回true，否则返回false clear()：移除栈里所有的元素 size()：返回栈里的元素个数 123456789101112131415161718192021222324252627282930function Stack() &#123; let items = [] this.push = function () &#123; for (let i = 0; i &lt; arguments.length; i++) &#123; let item = arguments[i] if (item !== undefined) &#123; items.push(item) &#125; &#125; return items &#125; this.pop = function () &#123; return items.pop() &#125; this.peek = function () &#123; return items[items.length - 1] &#125; this.isEmpty = function () &#123; return items.length === 0 &#125; this.clear = function () &#123; items = [] &#125; this.size = function () &#123; return items.length &#125; this.print = function () &#123; console.log(items.toString()) &#125;&#125; 可以使用什么的类来创建一个进制转换的函数 123456789101112131415function baseConverter(decNumber, base) &#123; let remStack = new Stack(), rem, remString = '', digits = '0123456789ABCDEF' while (decNumber &gt; 0) &#123; rem = Math.floor(decNumber % base) remStack.push(rem) decNumber = Math.floor(decNumber / base) &#125; while (!remStack.isEmpty()) &#123; remString += digits[remStack.pop()] &#125; return remString&#125; 队列队列是遵循先进先出的的原则的一组有序的项，队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。 使用es6语法来实现Queue类： 123456789101112131415161718192021222324252627282930313233343536let Queue = (() =&gt; &#123; const items = new WeakMap() class Queue &#123; constructor() &#123; items.set(this, []) &#125; enqueue() &#123; let s = items.get(this) for (let i = 0; i &lt; arguments.length; i++) &#123; let item = arguments[i] s.push(item) &#125; &#125; dequeue() &#123; let s = items.get(this) return s.shift() &#125; front() &#123; let s = items.get(this) return s[0] &#125; isEmpty() &#123; let s = items.get(this) return s.length === 0 &#125; size() &#123; let s = items.get(this) return s.length &#125; print() &#123; let s = items.get(this) console.log(s.toString()) &#125; &#125; return Queue&#125;)() 上面使用了es6的class语法创建了一个Queue类，具备了队列基本的一些功能。 优先队列为队列中每个元素添加一个优先级，元素的添加和移除都基于优先级，我们只需修改一下添加元素如队列的规则即可，在添加元素之前判断当前元素的优先级是否高于目前队列中的其它元素的优先级，从队列的开始进行寻找，如果找到当前元素高于队列中某个元素的优先级，将当前元素插入到该元素的前面。如果要添加的元素的优先级小于队列中所有的元素，或者队列中还没有元素，就执行简单的入列操作。 1234567891011121314151617181920212223// 只需在原来的基础上修改这两个方法即可enqueue(element, priority) &#123; let s = items.get(this) let queueElement = new QueueElement(element, priority) let added = false for (let i = 0; i &lt; s.length; i++) &#123; let item = s[i] if (queueElement.priority &lt; item.priority) &#123; s.splice(i, 0, queueElement) added = true break &#125; &#125; if(!added) &#123; s.push(queueElement) &#125;&#125;，print() &#123; let s = items.get(this) s.forEach(item =&gt; &#123; console.log(`$&#123;item.element&#125;-$&#123;item.priority&#125;`) &#125;)&#125; 链表链表储存有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置。每个元素由一个储存元素本身的节点和一个指向下一个元素的引用组成。 相对于传统的数组，链表的一个好处在于，添加或移除元素时不需要移动其他元素。由于链表需要使用指针，所以要想访问链表中间的一个元素，需要从起点开始迭代列表直到找到所需的元素。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构基础]]></title>
    <url>%2F2018%2F08%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[数据结构与算法什么是数据结构？数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各自种联系。这些联系可以通过定义相关的函数来给出。 数据对象在计算机中的组织方式 逻辑结构 物理存储结构 数据对象必定与一系列加在其上的操作相关联 完成这些操作所用的方法就是算法 抽象数据类型 数据类型 数据对象集 数据集合相关联的操作集 抽象：描述数据类型的方法不依赖于具体实现 与存放数据的机器无关 与数据存储的物理结构无关 什么是算法？ 一个有限的指令集 接受一些输入 产生输出 一定在有限的步骤之后终止 每一条指令必须： 有充分的目标，不能有歧义 在计算机能处理的范围之内 描述时应不依赖与任何一种计算机语言以及具体的实现手段 数组数组是一种基本的数据结构，用于按顺序储存元素的集合。但是元素可以随机存取，因为数组中每个元素都可以通过数值索引来识别。 动态数组]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[播放器内核]]></title>
    <url>%2F2018%2F08%2F09%2F%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E5%86%85%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[音乐播放器内核播放器组件是本次项目中的重点和难点，逻辑复杂，基本实现音乐播放器的播放功能。 播放器组件的显示和隐藏由于只要播放列表中有歌曲，播放器组件就会显示出来，所以将播放器组件挂载到app.vue中，播放器组件设计为有两个部分，一个是全屏的播放器，另一个是mini播放器。在两个播放器切换的时候会设计一个动画来提升用户体验。由于动画相对复杂，所以使用transition的钩子函数来实现，由于需要在js中设置animation动画所以使用create-keyframe-animation插件来简化操作。 动画设置的原理本动画的效果是：在打开大播放器时大播放器中的专辑图片从小播放器的专辑图片位置处飞入。 获取到小播放器中专辑图片的位置，与应该设置的所发比例。由于小播放器与大播放器的位置是相对固定的所以在获取位置时可以直接通过计算来获取到。但是由于位置获取需要一些计算，所以将计算位置单独封装成一个函数，增强代码的可读性。 设置入场动画，动画就是一个简单的animation动画，不过是在js中设置的，了解插件方法即可 入场之后移除动画。 出场动画相对简单，不涉及到多段变化，直接使用transition和transform即可。这里需要注意的一点就是我们在style中写的样式由于有postcss所以并不需要做兼容，但是如果是在js中写的样式就是需要加上浏览器前缀做兼容的了，为了简化代码量我们也可以将这个封装成一个方法。 封装设置浏览器前缀的方法，由于该方法与dom操作有关，所以将其写在dom.js文件之中。这方法使用浏览器检测来确定需要加的前缀名称。 首先创建一个div并获取到它的style属性对象。 然后检测该对象中是否有特定浏览器前缀的属性。 将根据检测到的浏览器，封装一个给样式添加前缀的方法，这个方法返回添加前缀之后的字符串。 离开动画之后移除设置的样式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 动画的钩子函数enter(el, done) &#123; // 获取开始的位置和所发比例 const &#123; x, y, scale &#125; = this._getPosAndScale() let animation = &#123; 0: &#123; transform: `translate3d($&#123;x&#125;px,$&#123;y&#125;px,0) scale($&#123;scale&#125;)` &#125;, 60: &#123; transform: 'translate3d(0,0,0) scale(1.1)' &#125;, 100: &#123; transform: 'scale(1)' &#125; &#125; // 使用create-keyframe-animation插件来设置animation动画 animations.registerAnimation(&#123; name: 'move', animation, presets: &#123; duration: 400, easing: 'linear' &#125; &#125;) // 将注册的动画绑定到dom元素上 animations.runAnimation(this.$refs.cdWrapper, 'move', done)&#125;,afterEnter(el) &#123; // 移除动画 animations.unregisterAnimation('move') this.$refs.cdWrapper.style.animation = ''&#125;,leave(el, done) &#123; const &#123; x, y, scale &#125; = this._getPosAndScale() this.$refs.cdWrapper.style[transform] = `translate3d($&#123;x&#125;px,$&#123;y&#125;px,0) scale($&#123;scale&#125;)` this.$refs.cdWrapper.style.transition = 'all 0.4s' this.$refs.cdWrapper.addEventListener('transitionend', done)&#125;,afterLeave(el) &#123; this.$refs.cdWrapper.style[transform] = '' this.$refs.cdWrapper.style['transition'] = ''&#125;,// 位置计算函数。_getPosAndScale() &#123; // 计算位置和缩放比例 const targetWidth = 40 const paddingLeft = 40 const paddingBottom = 30 const paddingTop = 80 const width = window.innerWidth * 0.8 const scale = targetWidth / width const x = -(width / 2 - paddingLeft) const y = window.innerHeight - paddingTop - paddingBottom - width / 2 return &#123; x, y, scale &#125;&#125;,// 添加浏览器前缀的方法let elementStyle = document.createElement('div').stylelet prefix = (() =&gt; &#123; let transformNames = &#123; webkit: 'webkitTransform', moz: 'mozTransform', O: 'OTransform', ms: 'msTransform', standard: 'transform' &#125; for (let k in transformNames) &#123; let value = transformNames[k] if (elementStyle[value] !== undefined) &#123; return k &#125; &#125; return false&#125;)()export function prefixStyle(style) &#123; if (prefix === false) &#123; return false &#125; if (prefix === 'transform') &#123; return style &#125; return prefix + style.charAt(0).toUpperCase() + style.substr(1)&#125; 专辑图片旋转动画专辑图片动画就是在歌曲播放时专辑图片会自动旋转，本来这个动画应该是比较简单，使用一个animation动画然后用js控制类名即可，但是由于ios的animation-play-state: paused失效，所以无法使用这个方法来控制动画的暂停。 使用js来实现旋转动画如果只是单纯的在歌曲停止时移除animation动画的话会导致再次播放的时候专辑图片的旋转角度跳转回最开始，这样子用户体验极差，所以为了解决这个问题，可以在图片的外部添加一个盒子用来记录暂停时图片旋转的位置。 依然是通过类名来控制图片的转动。 当歌曲处于时播放状态时给图片添加animation动画来让图片旋转。 当歌曲处于停止状态时移除类名，但是在此之前先将img的旋转位置记录下来然后，然图片外面的盒子旋转到这个位置，再移除类名使旋转停止，这样在下一次开始旋转时就不会跳转到开始的位置去了。 1234567891011cdCls() &#123; if (!this.playing &amp;&amp; this.$refs.cd) &#123; let cd = this.$refs.cd let Img = this.$refs.cdImg let cdTransform = getComputedStyle(cd).transform let ImgTransform = getComputedStyle(Img).transform cd.style.transform = cdTransform === 'none' ? ImgTransform : cdTransform.concat(' ', ImgTransform) return '' &#125; return 'play'&#125;, 歌曲播放当currentSong改变时就执行播放歌曲的操作，由于qq音乐接口的限制，在获取歌曲列表时获取不到歌曲的播发源，需要通过歌曲的id发送请求获取到每个歌曲的vkey然后进行拼接才能得到歌曲的播放地址。 在获取播放列表时我一开始是在获取到播放列表之后立即通过循环发送请求获取到列表中每一个歌曲的url，但是后面发现这样做不仅会使用户消耗过多的流量，也会延长歌曲列表的渲染时间。 后面使用的方案是将获取播放地址的方法定义到每个歌曲对象之中，每个歌曲播放时再去发送请求获取播放地址，并且将播放地址挂载到歌曲对象中，如果歌曲对象已经有了播放地址就不再发送请求，然后将地址设置到audio中。 在播放歌曲前进行拦截判断和必要的数据初始化，然后再获取播放所需的歌曲url和歌曲的歌词。 12345678910111213141516171819202122232425262728293031323334353637383940414243currentSong(newSong, oldSong) &#123; // 检查是否有id if (!this.currentSong.id) return // 检查新的歌曲旧歌曲是否是同一首，如果是就不执行操作 if (newSong.id === oldSong.id) return // 切换时如果存在歌词，那么先停止歌词的滚动 if (this.currentLyric) &#123; this.currentLyric.stop() &#125; // 初始化歌曲播放时间和当前正在播放歌词 this.currentTime = 0 this.playingLyric = '' clearTimeout(this.timer) this.timer = setTimeout(() =&gt; &#123; this.getCurrentUrl() this.getCurrentLyric() &#125;, 20)&#125;,getCurrentUrl() &#123; this.currentSong.getMusicUrl().then(url =&gt; &#123; this.$refs.audio.setAttribute('src', url) this.$refs.audio.play() &#125;).catch(() =&gt; &#123; this.songReady = true this.setPlayingState(false) this.$refs.noMusic.show() &#125;)&#125;,getCurrentLyric() &#123; this.currentSong.getLyric().then(lyric =&gt; &#123; if (this.currentSong.lyric !== lyric) &#123; return &#125; this.currentLyric = new Lyric(lyric, this.handler) if (this.playing) &#123; this.currentLyric.play() &#125; &#125;).catch(() =&gt; &#123; this.currentLyric = null this.playingLyric = '' this.currentNumber = 0 &#125;)&#125;, 这里对歌词的处理使用的是lyric-parser插件，能够实现歌词的自动轮播功能。 歌曲的播放和暂停使用playing属性来控制，之后操作歌曲的播放和暂停时就只需要控制playing属性即可。 123456789101112131415playing(newVal) &#123; let audio = this.$refs.audio this.$nextTick(() =&gt; &#123; newVal ? audio.play() : audio.pause() &#125;)&#125;,togglePlaying() &#123; if (!this.songReady) &#123; return &#125; this.setPlayingState(!this.playing) if (this.currentLyric) &#123; this.currentLyric.togglePlay() &#125;&#125;, 歌曲的切换与模式的变化歌曲切换一个是由两个操作上一首和下一首，这里为了避免用户切换歌曲过块可以使用一个开关来阻止用户的这个行为，当用户切换歌曲之后将开关关闭，阻止用户进行切换操作，只有当歌曲加载完成能够播放的时候才打开开关允许用户进行切换歌曲的操作，在请求歌曲时或者是播放歌曲时出现错误则弹出信息框提示用户切换歌曲。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869prev() &#123; if (!this.songReady) &#123; return &#125; // 如果歌曲列表只有一首歌调用loop方法，循环播放这一首歌即可 if (this.playList.length === 1) &#123; this.loop() return &#125; // 判断当前播放歌曲是否是第一首歌，如果是就把歌曲切换到最后一首歌，如果不是就切换到第一首歌 let nextIndex = this.currentIndex &lt;= 0 ? this.playList.length - 1 : this.currentIndex - 1 // 修改当前播放歌曲的 this.setCurrentIndex(nextIndex) // 如果播放状态为暂停就修改为播放 if (!this.playing) &#123; this.setPlayingState(true) &#125; this.songReady = false&#125;,next() &#123; if (!this.songReady) &#123; return &#125; if (this.playList.length === 1) &#123; this.loop() return &#125; // 判断当前歌曲是否是最后一首，如果是就切换到第一首，如果不是就切换到下一首 let nextIndex = this.currentIndex &gt;= this.playList.length - 1 ? 0 : this.currentIndex + 1 this.setCurrentIndex(nextIndex) if (!this.playing) &#123; this.setPlayingState(true) &#125; this.songReady = false&#125;,ready() &#123; this.songReady = true if (this.playing) &#123; this.$refs.audio.play() // 添加播放的歌曲到播放历史 this.playHistory(this.currentSong) &#125; window.removeEventListener('touchstart', this.firstPlay, false)&#125;,error() &#123; this.songReady = true this.setPlayingState(false) this.$refs.noMusic.show()&#125;,ended() &#123; if (this.mode === playMode.loop) &#123; this.loop() &#125; else &#123; this.next() &#125;&#125;,loop() &#123; let audio = this.$refs.audio audio.currentTime = 0 // chrome50 版本之后不允许pause之后立即调用play，所以需要设置一个延时 setTimeout(_ =&gt; &#123; audio.play() this.setPlayingState(true) if (this.currentLyric) &#123; // 将歌词跳转到开始 this.currentLyric.seek(0) &#125; &#125;, 150)&#125;, 在实现播放功能时发现一个问题，那就是在ios设备上不允许自动播放音频的，必须通过用户的行为才能触发音频的播放功能，为了解决这个问题可以在vue的created钩子函数中监听一个touchstart事件，在这个事件中触发播放操作，在第一首歌能够播放之后再将这个事件移除，即可实现自动播放功能。 模式的切换，播放器一共支持3种模式的播放，顺序播放、乱序播放、单曲循环。可以使用changeMode函数来实现mode的改变 1234567891011121314151617181920212223242526272829303132333435changeMode() &#123; // 计算出mode改变后的值 let mode = (this.mode + 1) % 3 // 改变mode的值 this.setPlayMode(mode) let list = null if (this.mode === playMode.random) &#123; // 如果mode是乱序播放，则调用shuffle函数打乱当前播放列表 // 这个函数是一个工具函数定义在util.js中 list = shuffle(this.sequenceList) &#125; else &#123; // 如果不是乱序播放则将播放列表变成顺序播放的列表 list = this.sequenceList &#125; // 当播放列表改变时当前歌曲的index也会改变， // 所以需要修改一下currentIndex让它和当前歌曲的index保持一致 this.resetCurrentIndex(list) // 修改播放列表 this.setPlayList(list)&#125;,// 乱序函数function getRandomInt(min, max) &#123; //获取一个从最小值到最大值的随机整数 return Math.floor(Math.random() * (max - min + 1) + min)&#125;export function shuffle(arr) &#123; let _arr = arr.slice() for (let i = 0; i &lt; _arr.length; i++) &#123; let j = getRandomInt(0, i) let k = _arr[j] _arr[j] = _arr[i] _arr[i] = k &#125; return _arr&#125; 进度条控制歌曲播放功能这一部分实现的是进度条控制歌曲进度的功能，分别有拖拽进度条btn歌曲进度跳转到相应的位置播放歌曲，点击进度条改变歌曲播放进度，使用进度条显示歌曲播放的时间和进度。由于这里功能比较多，所以将进度条组件单独抽离出来封装成一个基础的组件。 进度条的进度展示由于进度条组件是一个基础的组件，所以进度应该是由使用它的组件来提供的，这里使用进度条的组件就就是播放器组件，所以歌曲播放进度需要在播放器组件中计算出来并传到进度条组件中。计算进度的方法非常的简单，使用当前播放时间除以播放从时间即可。 获取到歌曲播放进度之后就可以在进度条组件中，监视进度数据的变化，以此来改变进度条的长度。 123456789101112131415161718192021222324// 在player组件中计算出当前播发百分比，并传递给进度条组件percent() &#123; return this.currentTime / this.currentSong.duration&#125;// 在进度条组件中使用percent来展示进度条watch: &#123; percent(newVal) &#123; // 传入的歌曲播放进度必须大于0，当用户在修改歌曲播放进度时不改变进度条，进度条外部盒子的宽度必须大于0 if (newVal &gt; 0 &amp;&amp; !this.touch.initiated &amp;&amp; this.$refs.progressBar.clientWidth &gt; 0) &#123; // 进度条的从长度应该是进度条外部盒子的长度减去进度条最前面圆形的按钮的长度。 const barWidth = this.$refs.progressBar.clientWidth - progressBtnWidth // 计算出进度条的长度，这里Math.min()的作用是， //当歌曲切换之后而歌曲总时长变化了，而当前歌曲的播放时间还没有变化， // 就会出现percent大于1的情况，所以使用这个函数避免offsetWidth大于barWidth的情况 let offsetWidth = barWidth * Math.min(newVal, 1) // 修改进度条长度，并且设置btn的偏移量 this._offset(offsetWidth) &#125; &#125;&#125;,_offset(offsetWidth) &#123; this.$refs.progress.style.width = offsetWidth + 'px' this.$refs.btn.style[transform] = `translate3d($&#123;offsetWidth&#125;px,0,0)`&#125; 滑动进度条btn控制歌曲播放时间123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 利用滑动事件来计算出新的播放进度,并传递给外部progressTouchStart(e) &#123; // 滑动开始时建立一个滑动开始的标识符 this.touch.initiated = true // 记录滑动开始时手指的位置 this.touch.startX = e.touches[0].pageX // 记录滑动开始时进度条的长度 this.touch.left = this.$refs.progress.clientWidth&#125;,progressTouchMove(e) &#123; // 判断是否触发过touchstart事件。 if (!this.touch.initiated) &#123; return &#125; // 计算出手指移动的距离 const deltaX = e.touches[0].pageX - this.touch.startX // 获取进度条应该修改的长度，首先这里必须保证这个长度是大于等于0的所以使用Math.max函数，之后必须保证长度必须小于等于进度条盒子的长度 let offsetWidth = Math.min(this.$refs.progressBar.clientWidth - progressBtnWidth, Math.max(0, deltaX + this.touch.left)) // 修改进度条和btn的偏移 this._offset(offsetWidth) // 将进度条改变这个传递到外部的函数，由于在移动滑动进度条时只需要修改歌曲的时间，而不需要修改歌曲的播放的位置，所以使用一个标识符来区分这两个事件 this._triggerPercent(true)&#125;,progressEnd(e) &#123; // 拖拽完成之后修改正在滑动标识符让进度条正常运行 this.touch.initiated = false // 将进度改变传递给外部 this._triggerPercent()&#125;,// player组件接受到新的播放进度并进行相应的处理precentBarChange(percent) &#123; // 接受新的歌曲进度，并计算出歌曲播放的时间 const currentTime = this.currentSong.duration * percent // 修改当前歌曲的播放时间 this.$refs.audio.currentTime = currentTime // 如果歌曲处于暂停状态，就播放歌曲 if (!this.playing) &#123; this.togglePlaying() &#125; // 让自动更新播放时间的update函数正常工作 this.progressMove = false // 修改歌词展示位置 if (this.currentLyric) &#123; this.currentLyric.seek(currentTime * 1000) &#125;&#125;,currentTimeChange(percent) &#123; // 拖动进度条时同步当前播放时间 this.currentTime = this.currentSong.duration * percent // 阻止自动更新当前播放时间 this.progressMove = true // 修改歌词展示位置 if (this.currentLyric) &#123; this.currentLyric.seek(this.currentTime * 1000) &#125;&#125;,// 在歌曲播放的时候自动获取当前播放时间，并使用一个变量将其展示出来update(e) &#123; if (this.progressMove) &#123; return &#125; if (!this.playing) &#123; this.setPlayingState(true) &#125; this.currentTime = e.target.currentTime&#125;, 点击进度条修改歌曲播放位置。 123456789progressClick(e) &#123; // 点击进度条时获取到点击时的位置然后计算出应该偏移的长度 const rect = this.$refs.progressBar.getBoundingClientRect() const offsetWidth = e.pageX - rect.left // 当点击到小方块时e.offsetX的值是不对的，所以不能用这个 // this._offset(e.offsetX) this._offset(offsetWidth) this._triggerPercent()&#125;, 歌曲专辑图片和歌曲歌词显示的切换这一部分的效果依然是使用touch事件来实现的，通过计算滑动的距离与比例来设置歌词部分的偏移与歌曲专辑图片的透明度来实现切换。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677middleTouchStart(e) &#123; // 设置一个滑动开始的标识符 this.initiated = true // 记录滑动开始时手指的位置 let touch = e.touches[0] this.touch.startX = touch.pageX this.touch.startY = touch.pageY // 用来判断是否是移动 this.touch.move = false&#125;,middleTouchMove(e) &#123; // 判断是否触发过touchStart事件 if (!this.initiated) &#123; return &#125; // 计算出滑动的距离 const touch = e.touches[0] const deltaX = touch.pageX - this.touch.startX const deltaY = touch.pageY - this.touch.startY // 当竖直方向上的滑动距离大于水平方向上的滑动距离时，可能是用户在滑动歌词，就直接退 if (Math.abs(deltaX) &lt; Math.abs(deltaY)) &#123; return &#125; // 修改移动标识符 this.touch.move = true // 当当前所处位置在cd时，那么位置偏移为0.如果不是那就是在歌词部分，位置偏移就是-win const innerWidth = -window.innerWidth // 获取到当前的位置 const left = this.currentShow === 'cd' ? 0 : innerWidth // 由于只能向左偏移所以偏移量一定是负的小于0，而偏移的位置最多就只能是innerWidth const offsetWidth = Math.min(0, Math.max(innerWidth, left + deltaX)) // 计算出偏移的比例 this.touch.precent = Math.abs(offsetWidth / innerWidth) // 设置lyricList的偏移 this.$refs.lyricList.$el.style[transform] = `translate3d($&#123;offsetWidth&#125;px,0,0)` this.$refs.lyricList.$el.style[transitionDuration] = 0 // 设置专辑图片的透明度，偏移比例越大就越透明 this.$refs.middleL.style.opacity = 1 - this.touch.precent&#125;,middleTouchEnd() &#123; // 判断是否有移动 if (!this.touch.move) &#123; return &#125; let offsetWidth let opacity if (this.currentShow === 'cd') &#123; // 如果当前显示的是cd，判断偏移比例是否大于0.1 // 如果大于0.1需要将cd隐藏显示lyric if (this.touch.precent &gt; 0.1) &#123; // offsetWidth变量是用来控制lyric的偏移量来控制lyric的显示和隐藏 offsetWidth = -window.innerWidth this.currentShow = 'lyric' // opactiy是设置cd的透明度来控制cd的显示和隐藏 opacity = 0 &#125; else &#123; offsetWidth = 0 opacity = 1 &#125; &#125; else &#123; // 如果当前处于lyric部分，那么precent&lt;0.9实际上就是偏移量大于0.1 if (this.touch.precent &lt; 0.9) &#123; offsetWidth = 0 this.currentShow = 'cd' opacity = 1 &#125; else &#123; offsetWidth = -window.innerWidth opacity = 0 &#125; &#125; const time = 300 // 将样式设置到相应的元素上去 this.$refs.lyricList.$el.style[transform] = `translate3d($&#123;offsetWidth&#125;px,0,0)` this.$refs.lyricList.$el.style[transitionDuration] = `$&#123;time&#125;ms` this.$refs.middleL.style.opacity = opacity this.$refs.middleL.style[transitionDuration] = `$&#123;time&#125;ms`&#125;,]]></content>
      <categories>
        <category>vue.js学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue音乐播放器项目]]></title>
    <url>%2F2018%2F07%2F25%2Fvue-music%2F</url>
    <content type="text"><![CDATA[项目简介该项目是一个具备完善功能的音乐app，所有数据都通过抓取接口数据动态获取，希望能够通过这一个项目能够更深的体会模块化编程，以及更加熟练的使用vue。 数据的获取由于这一次的数据不再是本地的假数据了，那么第一个需要解决的问题就是获取项目中所需要的数据，本项目的数据全部抓取自qq音乐，那么接下来就让我们来看看如何获取接口的数据。 首先一般接口数据的获取方法分为jsonp和后端代理获取数据，我们可以通过查看网站自身是如何获取数据的，一般jsonp获取数据的请求可以在Network中的JS选项中查看，而一般需要后端代理获取数据的就是XHR请求。 jsonp数据获取jsonp是获取跨域数据最常见的一种方法，它的原理也是非常的简单，由于同源（“协议+域名+端口”相同才为同源）策略会阻止来自不同的域的ajax请求，所以为了解决这个问题我们就需要找到一个不受限制的请求来获取资源，而在网页中&lt;script&gt;标签在获取资源时是不受到同源策略的影响的，而jsonp就是利用这个特点来获取数据的，下面是jsonp实现的一个基本步骤： 在代码中动态创建一个script标签。 然后把标签的src属性设置为接口的名字。 在src中还要应该传入一个callback函数名，并且创建这个callback函数。 把创建的script标签添加到页面中，这个时候就会对接口发起请求了。 而服务端会返回的是一段js代码，当请求到页面之后会自动执行这些代码。 由于我们在src中传入了一个callback函数名，只要后端返回的代码中调用了callback函数，并且将我们需要的数据进行以参数的形式传递给这个函数，那么我们也就可以拿到数据了。 原生实现： 123456789101112131415&lt;script&gt; var script = document.createElement('script'); script.type = 'text/javascript'; // 传参并指定回调执行函数为onBack script.src = 'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack'; document.head.appendChild(script); // 回调执行函数 function onBack(res) &#123; alert(JSON.stringify(res)); &#125; &lt;/script&gt; // 服务端返回如下（返回时就会执行这个函数） onBack(&#123;"status": true, "user": "admin"&#125;) 使用jsonp前面介绍了jsonp的基本实现原理，但是当然我在项目中并不会直接使用原生的jsonp来进行操作，这里我使用一个名叫jsonp的第三方库，但是由于这个库并没有实现promise，所以可以对他进行一些改造。 1234567891011121314151617181920212223import originJSONP from 'jsonp'export default function jsonp(url, data, option) &#123; url += (url.indexOf('?') &lt; 0 ? '?' : '&amp;') + param(data) return new Promise((resolve, reject) =&gt; &#123; originJSONP(url, option, (err, data) =&gt; &#123; if (!err) &#123; resolve(data) &#125; else &#123; reject(data) &#125; &#125;) &#125;)&#125;function param(data) &#123; let url = '' for (var k in data) &#123; let value = data[k] === undefined ? '' : data[k] url += `&amp;$&#123;k&#125;=$&#123;encodeURIComponent(value)&#125;` &#125; return url ? url.substring(1) : ''&#125; 首先引入json的库，然后在他原来的基础上进行进一步封装。 原来的originJSONP函数接受三个参数，url， option，callback，传给后端的数据需要手动拼接到url后面，为了使用方便新的jsonp函数我让他的url和数据分离开来，在jsonp函数内部进行拼接。在这里我定义了一个拼接数据的方法，这个方法只在内部使用所以不需要传递出去，这个方法接受一个对象，然后对这个对象进行遍历，首先检查每一项的值是否为undefined，如果是就把它变成空字符串，然后将数据通过&amp;键=值的格式拼接到我们的临时变量之中，最后检查临时变量中是否有值，如果有就把它的第一个&amp;符号去掉然后返回找个值，如果没有值返回空字符串。然后到jsonp函数中调用这个函数，将传递过来的data拼接到url的后面，这里要注意在拼接的时候的?和&amp;。 后端代理获取数据如果网站在请求数据时要验证请求头中的referer和host的时候前端无法获取到数据了，因为我们在前端是无法修改请求头中的信息的，这个时候就需要利用本地的后端服务器去获取数据，然后通过接口传递给前端。后端代理的原理就是把请求头中的referer和host设置成源网站一样的就可以获取到数据了。 1234567891011121314app.get('/api/getDiscList', (req, res) =&gt; &#123; const url = 'https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg' axios.get(url, &#123; headers: &#123; referer: 'https://c.y.qq.com/', host: 'c.y.qq.com' &#125;, params: req.query &#125;).then(response =&gt; &#123; res.json(response.data) &#125;).catch(e =&gt; &#123; console.log(e) &#125;)&#125;) 轮播图组件的封装轮播图在项目中是非常常见的，为了在项目中能够多次复用，可以把轮播图作为一个单独的组件抽离出。本项目使用better-scroll来实现区域滑动的操作，所以轮播图组件也是基于better-scroll来实现。 基本的布局在轮播图组件中利用vue提供的&lt;slot&gt;标签来实现在调用时再来填充轮播图内部的内容，轮播图的宽度也应该在调用时决定。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;div class="slider" ref="slider"&gt; &lt;div class="slider-group" ref="sliderGroup"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class="dots"&gt; &lt;span v-for="(item, index) in dots" :key="index" class="dot" :class="&#123;'active': currentPageIndex === index&#125;"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;style lang="less" scoped&gt;@import url("../../common/less/variable.less");.slider &#123; min-height: 1px; .slider-group &#123; position: relative; overflow: hidden; white-space: nowrap; .slider-item &#123; float: left; text-align: center; box-sizing: border-box; overflow: hidden; a &#123; display: block; width: 100%; overflow: hidden; text-decoration: none; img &#123; display: block; width: 100%; &#125; &#125; &#125; &#125; .dots &#123; position: absolute; bottom: 12px; right: 0; left: 0; text-align: center; font-size: 0; .dot &#123; width: 8px; display: inline-block; height: 8px; border-radius: 50%; background-color: @color-text-l; margin: 0 4px; &amp;.active &#123; width: 20px; border-radius: 5px; background-color: @color-text-ll; &#125; &#125; &#125;&#125;&lt;/style&gt; 组件的业务逻辑轮播图功能的控制首先我们需要考虑到轮播图的功能，让我们在调用的时候通过一些参数来控制轮播图的功能，一般轮播图主要有：是否无缝轮播、是否自动播放、以及轮播间隔、这么几个选项，那么就可以在组件的props中定义一些变量来控制轮播图的功能。 12345678910111213props: &#123; loop: &#123; type: Boolean, default: true &#125;, autoplay: &#123; type: Boolean, default: true &#125;, interval: &#123; type: Number, default: 1000 &#125; 轮播图的初始化slider-group宽度的初始化由于在轮播图片的大小需要在调用时决定，所以slider-group的宽度就不能够写死，需要在使用组件时通过js去动态的设置slider-group的宽度。slider-group的宽度主要受到这几个方面的影响： 单张轮播图片的大小 轮播图片的数量 是否无缝轮播（如果无缝轮播那么需要在首尾个添加一张图片） 根据这些条件可以在methods中定义一个初始化slider-group宽度的方法。 1234567891011121314_setSliderWidth() &#123; this.children = this.$refs.sliderGroup.children let width = 0 let sliderWidth = this.$refs.slider.clientWidth for (let i = 0; i &lt; this.children.length; i++) &#123; let child = this.children[i] addClass(child, 'slider-item') child.style.width = sliderWidth + 'px' width += sliderWidth &#125; if (this.loop) &#123; width += 2 * sliderWidth &#125; this.$refs.sliderGroup.style.width = width + 'px' 上面这个方法首先获取到在调用时添加的slider-item元素，定义一个width变量来储存slider-group的宽度，获取到slider的宽度，这里slider的宽度是由在调用时为slider组件的父元素的宽度，所以一般在调用时需要在&lt;slider&gt;标签外添加一个盒子来控制整个slider组件的宽度。然后遍历slider-item数组，为每个slider-item添加类名，应用上事先设置好的样式，这样就不需要在调用时去添加类名了，方便操作，为每一个slider-item添加宽度，宽度应该和slider的宽度一致，每遍历一次width就加上一个sliderWidth，然后判断是否是无缝滚动，如果是无缝滚动就在加上两倍的sliderWidth，最后设置slider-group的宽度即可。 slider的初始化和dots的初始化slider的初始化只需要根据better-scroll文档中的配置进行相应的配置即可，dots初始化也比较简单，通过在dotsdata中定义一个数组，dots的数量由数组的长度决定，然后根据slider-item的数量来决定dots的长度即可。具体代码就不贴出来了，都可以从官方文档中找到。 歌手页面歌手页面主要的业务有获取并渲染歌手列表页面，同时给歌手列表页面加上相应的交互效果。通过二级路由展示歌手详细的歌曲列表。 获取数据并对数据进行处理数据的获取依然是抓取qq音乐的接口，但是抓取过来之后就会发现数据的格式和我们需要的格式并不一样，这也是在日常开发中非常常见的问题，那么我们就需要对后端返回的数据进行进一步的加工。 设计singer的数据格式，并创建一个singer类为了能够更好的使用数据，我们利用es6提供的class关键字来定义一个singer的类，为了方便维护可以在common文件夹中的js文件夹中创建一个singer.js的文件，来管理singer。我们的singer的数据结构比较简单只需要id、name、avatar即可。下面是singer类的代码。 1234567export default class Singer &#123; constructor(&#123;id, name&#125;) &#123; this.id = id this.name = name this.avatar = `https://y.gtimg.cn/music/photo_new/T001R300x300M000$&#123;id&#125;.jpg?max_age=2592000` &#125;&#125; 设计一个格式化数据的函数这个函数的具体实现思想也是比较简单，就是通过遍历后端返回过来的数据来取出我们需要的数据。 123456789101112131415161718192021222324252627282930313233343536373839404142_normalizeSinger(list) &#123; let map = &#123; hot: &#123; title: HOT_NAME, items: [] &#125; &#125; list.forEach((item, index) =&gt; &#123; if (index &lt; HOT_SINGER_LEN) &#123; map.hot.items.push(new Singer(&#123; id: item.Fsinger_mid, name: item.Fsinger_name &#125;)) &#125; let key = item.Findex if (!map[key]) &#123; map[key] = &#123; title: key, items: [] &#125; &#125; map[key].items.push(new Singer(&#123; id: item.Fsinger_mid, name: item.Fsinger_name &#125;)) &#125;) // 所得到的对象是无序的需要处理之后变成一个有序的数组。 let hot = [] let ret = [] for (let key in map) &#123; let value = map[key] if (value.title.match(/[a-zA-Z]/)) &#123; ret.push(value) &#125; else if (value.title === HOT_NAME) &#123; hot.push(value) &#125; &#125; ret.sort((a, b) =&gt; &#123; return a.title.charCodeAt(0) - b.title.charCodeAt(0) &#125;) return hot.concat(ret)&#125;, 首先定义一个map对象用来储存格式化后的数据，在展示的时候我默认将前10条放到一个热门的分类中，所以在定义map对象时我们先在其中定义一个hot对象，然后取前10条数据，这里我的热门数据的条数专门定义了一个常量来储存，这个是为了更加的语义化，也为了更加方便的维护代码，我们在开发过程中的一些特定的限制数字都可以使用常量来管理。 接着按照首字母的不同来区分歌手，在源数据中每个歌手的Findex保存了歌手的首字母，我们就可以将其取出来，判断如果在map中还没有以这个字母为键的对象的话，就在map对象中新建一个以这个字母为键的对象。如果有了这个属性，那么就通过实例化singer对象将有用信息取出，并添加到对象中。 这样子取出来的数据还是一个无序的对象，我们接着需要将它按照字母顺序排列，在排列之前我们首先需要把无序的对象变成数组，通过遍历map将对象取出储存到数组中，这里为了保证每个对象的title都是字母，需要对数据进行一个简单的判断，由于hot类型的title特殊，所以我们单独处理。 最后使用数组的sort方法将按照字母分类的数组进行排序，然后将排序之后的数组连接到hot数组之中。 歌手列表list-view组件list-view组件是一个用于展示歌手列表的基础组件，所以把list-view组件放到base目录之下。list-view组件主要实现的效果就是歌手姓名的首字母与右边字母列表的一个联动效果，首先按照歌手的姓名首字母分类渲染到页面中，当左边滚动到不同字母的歌手时，右边的字母列表也会跟着实现相应的字母高亮。 主要的实现思路右侧列表 通过监听touchstart和touchmove 事件来实现交互，由于右侧列表中的dom元素比较的多，所以我将事件绑定到导航列表的最外层元素上，给列表中每个元素添加一个自定义属性data-index，在触发事件时通过判断data-index的值来确定事件源。左侧列表的跳转通过better-scroll的api实现。 当touchstart时将手指的位置记录下来，并且跳转到当前手指触摸到的元素上去。 touchmove时，利用touchstart和touchmove时的距离除以每一个字母元素的高度来计算出当前手指处在什么位置上，并跳转到该元素对应的位置。 左侧列表 当左侧列表移动的同时右侧列表的高亮也要同步。 需要先把左侧列表每一个分类的高度储存到一个数组中。 获取到当前滑动的位置，然后和上一步中分类列表的高度数组去比较，计算出当前滑动的位置处于的分类。然后再设置右侧列表相对应的高亮。 歌曲列表组件歌曲列表组件主要的难点在于列表向上滑动时，在开始的时候整个列表都向上滑动，当滑动到接近顶部时，列表背景不再向上滑动，只有歌曲列表进行滑动。这么一个类似原生音乐app的交互效果。 效果实现的主要思路 要实现这个效果首先要做的就是在布局上要有一个合理的设计。这里我将歌曲列表的盒子固定定位到底部，这个盒子限制高度但是不设置溢出隐藏，盒子里面的歌曲列表使用scroll组件实现区域滚动。 在列表向上滚动的时候背景也需要向上滚动，这个背景可以使用一个单独的背景div，背景div的高度和歌曲列表盒子的高度相等，它不是固定定位，而是会随着歌曲列表的上滑一起移动。这样就实现了歌曲上滑时背景也一起上滑的效果。 当滑动到接近顶部的位置的时候就让背景div停止移动，但是这个时候如果再向上滑动的话歌曲列表就会覆盖到专辑图片上。 为了解决背景div停止移动，歌曲列表有个溢出的现象可以提高专辑图片div的层级，让它的层级高于歌曲列表，这样上滑的歌曲列表就不会溢出了，这个时候需要注意如果只是提高专辑图片div的层级，会出现整个和专辑图片接触的歌曲列表都会覆盖。 为了解决上面的问题，可以在设置层级时，同时将专辑图片div的高度变小，这样子就只会覆盖掉溢出的歌曲列表了，最后还要注意，如果专辑图片div高度变小，那么里面的随机播放列表按钮也就会移动上来，所以在改变高度的时候还需要将随机播放按钮隐藏掉。 具体代码实现，这里所有的操作都是在滑动位置变化时进行的，所以下面的函数是在watch中的 123456789101112131415161718192021222324252627282930313233343536373839scrollY(newY) &#123; let minHeight = this.minHeight let zIndex = 0 let scale = 1 let blur = 0 let bgImage = this.$refs.bgImage let bgLayer = this.$refs.bgLayer // 控制bgLayer向上移动的最大距离只能是minHeight let translateY = Math.max(newY, minHeight) // 当向下滑动时图片放大的比例 const percent = Math.abs(newY / this.bgImageHeight) // 控制bgLayer随着list的移动 bgLayer.style[transform] = `translate3d(0, $&#123;translateY&#125;px, 0)` if (newY &lt; minHeight) &#123; // 提高层级用来遮住上滑的列表 zIndex = 10 // 将bgImage高度设为RESERVE_HEIGHT，这样保证bgImage只遮住上滑的列表 bgImage.style.padding = 0 bgImage.style.height = RESERVE_HEIGHT + 'px' // 由于bgImage高度变了，所以需要键play隐藏，要不然play会出现在bgImage中 this.$refs.play.style.display = 'none' &#125; else &#123; // 如果没有达到最大高度则将bgImage的高度变回来 bgImage.style['padding-top'] = '70%' bgImage.style.height = 0 this.$refs.play.style.display = '' &#125; if (newY &gt; 0) &#123; // 如果是向下滑动，则设置bgImage的放大值 zIndex = 10 scale = 1 + percent &#125; else &#123; // 如果是向上滑动，设置bgImage的模糊值 blur = Math.min(20 * percent, 20) &#125; this.$refs.filter.style[backdrop] = `blur($&#123;blur&#125;px)` bgImage.style[transform] = `scale($&#123;scale&#125;)` bgImage.style['z-index'] = zIndex&#125;]]></content>
      <categories>
        <category>vue.js学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[作用域]]></title>
    <url>%2F2018%2F07%2F23%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[作用域编程语言最基本的一个功能就是能够储存变量中的值，并且能够在之后的操作中访问和修改这个值。正是这种储存和访问变量的值的能力将状态带给了程序。而对于变量我们关心的则是它们储存在哪里？程序如何找到它们？也就是每一种编程语言中都有一套良好的规则来储存变量，并且在之后能够方便的找到这些变量，这一套规则就被称为作用域。 编译原理JavaScript本质上是一门编译语言，通过JavaScript引擎进行编译，传统的编译语言流程分为下面三个步骤： 分词/词法分析 这个过程会将字符组成的字符串分解成对编程语言来说有意义的代码块，这些代码块被称为词法单元。例如var a = 2会被分解为var、a、=、2、；。这些词法单元 解析/语法分析 这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。var a = 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下来是一个叫作 Identifier （它的值是 a ）的子节点，以及一个叫作 AssignmentExpression的子节点。 AssignmentExpression 节点有一个叫作 NumericLiteral （它的值是 2 ）的子节点。 代码生成 将AST转换为可执行代码的过程被称为代码生成。var a = 2；的AST转换为一组机器指令，用来创建一个叫做a的变量，并将一个值储存在a中。 理解作用域首先了解一下参与代码处理的几个程序。 引擎 负责JavaScript程序的编译及执行过程 编译器 负责语法分析及代码生成 作用域 负责收集并维护由所有什么的标识符组成的一系列查询、并实施一套非常严格的规则确定当前执行的代码对这些标识符的访问权限。 下面我们通过对var a = 2；这一段代码的分析来理解什么是作用域。 对应var a = 2；这一句声明引擎会认为是两个完全不一样的声明，一个是由编译器在编译时处理的，另一个则是由引擎在运行时处理的。 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在同一个作用域的集合之中。如果已经有了，那么会忽略这个声明，否则就会要求作用域在当前作用域的集合中声明一个变量，并命名为a。 接下来编译器为引擎生成运行时的所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎在运行时会先询问作用域，在当前作用域中是否存在变量a。如果是，引擎会使用这个变量；如果否，引擎会继续查找该变量。如果最终找到了a变量则执行赋值操作，否则会抛出异常。 引擎执行查找的方式分为两种： LHS查询：执行这个查询需要试图找到变量容器本身。 RHS查询：执行这个查询时需要找到某个变量的值。 注意：函数声明与普通的变量声明并不相同，编译器可以在代码生成的同时处理声明和值的定义。 作用域的嵌套当一个块或函数嵌套在另一个块或函数中时，就会发生作用域嵌套。 如果在当前作用域无法找到某个变量，那么引擎就会到外层嵌套作用域中继续查找，直到找到该变量，或者直到抵达到最外层的作用域为止。 异常当变量还没有声明的情况下LHS和RHS这两种查询行为是不相同的。 如果RHS查询在所有嵌套的作用域中都找不到所需要的变量，引擎就会抛出ReferenceError异常。 而当引擎执行LHS查询在全局作用域中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并且将其返回给引擎。这是在非严格模式下会执行的操作。如果是严格模式下那么会抛出ReferenceError异常。 如果RHS查询找到一个变量，但是我们对这个值进行了不合理的操作，如非函数类型进行函数调用，那么就会抛出TypeError异常。 词法作用域作用域共有两种主要的工作模式。第一种是词法作用域，第二种是动态作用域，JavaScript使用的就是词法作用域。 词法阶段大部分标准语言的编译器在第一个工作阶段叫做词法化。 词法作用域就是定义在词法阶段的作用域，也就是说词法作用域是由你写代码是将变量和块作用域写在哪里来决定的。 查找作用域在找到第一个匹配的表示符时就会立即停止查找，所以如果在多层作用域中定义了同名的表示，那么就只会查找到里当做作用域最近的作用域中的标识符，这个叫做遮蔽效应。 全局作用中的变量会自动变成全局对象的属性。因此可以不直接通过全局对象的词法名称，而间接的通过对全局属性的引用来对其访问，这个方法可以访问到被同名变量遮蔽的全局变量。 无论函数在哪里调用，与无论它被谁调用。它的词法作用域都只由函数被声明时所处的位置决定。 欺骗词法JavaScript中有两种方式可以在运行的时候修改(或者说欺骗)词法作用域。但是欺骗词法作用域会导致性能下降。 evaleval()是一个函数，接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置一样。 默认情况下，如果eval()中所执行的代码包含一个或多个声明(无论是变量还是函数)，就会对eval所处的词法作用域进行修改。 在严格模式的程序中，eval()在运行时会有自己的词法作用域，意味着其中的声明无法修改所在的作用域。在使用let或const声明变量的字符串时，eval()也会在运行时产生自己的词法作用域。 setTimeout()和setInterval()的第一个参数可以是字符串，字符串内容可以被解释为一段动态生成的函数代码。当然一般是不使用这种方法的。 withwith可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。 尽管with可以将一个对象处理为词法作用域，但是在这个块中使用var声明并不会限制到这个块作用域中，而是会被添加到with所处的函数作用域中。 eval()函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而with声明实际上是根据你传递给它的对象创建一个新的词法作用域。 在with块中使用变量时，首先会到当前块作用域(也就是传进去的对象)中查找是否存在这个标识符(也就是对象是否有相对应的属性)，如果找不到该变量，就会按照作用域查找规则继续查找。 在实际使用中最好不要使用with和eval！ 函数作用域和块作用域函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用以及复用(在嵌套作用域中也可以使用)。 隐藏内部实现对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但是反过来：我们从所写的代码中挑选一个任意的片段，然后使用函数声明将它包装，实际上就是把这些代码隐藏起来了。 将代码片段包装到一个函数中，实际上就是在这个代码片段周围创建了一个作用域，这段代码中的所有声明都绑定到了这个新创建的包装函数的作用域中，而不是先前的作用域。这样就能把这个代码片段中的变量和函数隐藏到这个作用域中了。 这种隐藏变量和函数的技术，是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。这个原则指的是在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来。 隐藏作用域中的变量和函数所带来的另一个好处就是可以规避同名标识符之间的冲突。 函数作用域从前面我们知道了，函数可以将变量和函数定义隐藏起来，外部作用域无法访问到内部作用域中的任何内容，但是如果我们直接将需要执行的代码放到一个函数中的话，还是会有一些不太好的地方： 我们需要创建一个具名函数，那么意味着这个函数名本身就已污染了所在的作用域中。 我们还需要显示的去调用一下这个函数才能够执行里面的代码。 那么我们现在我们需要的就是一个不需要函数名，并且可以自动运行的函数。这种函数就是叫做自执行函数。 123456var a = 2;(function foo() &#123; console.log(a) var a = 3&#125;)()console.log(2) 在上面的代码中我就实现一个自动执行函数，并且该函数的函数名不会污染它所在的作用域。 这里前面的分号的作用是：如果使用的是无分号的代码风格，那么如果一行代码是以’(‘开始那么需要在前面加上一个分号，防止报错。 观察上面的代码我们可以发现这个函数的声明是以(function...而不是以function...开始，而这个区别就会导致前面的函数会被当做函数表达式而不是一个标准的函数声明来处理。所以foo被绑定在函数表达式自身的函数中而不是所在的作用域中。 区分函数声明和表达式最简单的方法就是看function关键字出现在声明的位置。如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。 块作用域所谓块级作用域就是：在使用{}包裹的代码块中声明的变量只能在这个代码块中使用，无法在代码块之外使用。 在es6之前我们声明变量的方法只能是使用var关键字，而使用var关键字声明的变量时没有块级作用域的概念的。在代码块中声明的变量依然可以在外部访问到。 在es6之前只有只有两个语句可以实现块级作用域： with语句，它从对象中创建出来的作用域，只能够在with声明中的作用域有效。 try/catch语句，catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效。 es6添加了两个新的关键字，可以实现块级作用域： let 关键字，只要在一个代码块中使用let关键字，那么就相当于在这个代码中创建了一个块级作用域。无法在块块级作用域外部访问到块级作用域内部的变量。使用let进行声明不会在块作用域中进行变量声明提升，也就是如果想要在声明前面访问该变量会报错，而使用var关键字声明的变量由于声明提升，在声明前面访问变量会返回undefined。 const关键字，具有let的所有功能，唯一不同的就是使用const声明的变量无法在之后修改该变量的值，任何试图修改其值的行为都会报错。 提升]]></content>
      <categories>
        <category>JavaScript高级</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue饿了么项目]]></title>
    <url>%2F2018%2F07%2F18%2Fvue%E9%A5%BF%E4%BA%86%E4%B9%88%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[说明这个系列主要用来记录在做项目中遇到的坑，以及解决方法。 使用vue-cli搭建一个vue项目 在全局安装vue-clinpm install -g @vue/cli 使用vue-cli创建一个新的项目:vue create 项目名称 使用vue-cli创建的项目中默认是没有下载less的需要在项目中下载less和less-loader，然后在webpack.dev.conf.js中修改配置 123456789// 修改前 module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap, usePostCSS: true &#125;) &#125;, // 将usePostCss这个属性去掉，即可在项目中使用less // 修改后 module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap&#125;) &#125;, 在项目中使用json文件中的假数据模拟后台数据 在webpack.dev.conf.js文件中进行配置 1234567891011121314151617181920212223242526272829303132// 引入express模块const express = require('express')const app = express()// 加载静态的数据var appData = require('../data.json')var seller = appData.sellervar goods = appData.goodsvar ratings = appData.ratingsvar apiRouters = express.Router()app.use('/api', apiRouters)// 在devServer对象中配置路由接口，为devServer添加以下属性before(app) &#123; app.get('/api/seller', (req, res) =&gt; &#123; res.json(&#123; errno: 0, data: seller &#125;) &#125;), app.get('/api/goods', (req, res) =&gt; &#123; res.json(&#123; errno: 0, data: goods &#125;) &#125;), app.get('/api/ratings', (req, res) =&gt; &#123; res.json(&#123; errno: 0, data: ratings &#125;) &#125;) &#125; 移动端1像素边框的实现产生原因：由于手机的Retine屏的分辨率与普通屏幕分辨率不同，所以在设置1px边框时很可能会出现边框大于1px的现象。 解决方案：移动端1px像素解决方法各大主流网站都各有不同，这里我使用伪类来创建1px的线条，然后通过媒体查询，根据不同设备的devicePixelRatio来实现不同比例的缩放，从而使线条接近1px。 12345678910111213141516171819202122232425262728.border-1px(@color) &#123; position: relative; &amp;::after &#123; display: block; position: absolute; left: 0; bottom: 0; width: 100%; border-top: 1px solid @color; content: ''; &#125;&#125;@media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5) &#123; .border-1px &#123; &amp;::after &#123; -webkit-transform: scaleY(0.7); transform: scaleY(0.7); &#125; &#125;&#125;@media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2) &#123; .border-1px &#123; &amp;::after &#123; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); &#125; &#125;&#125; 实现Sticky footersSticky footers是css页面布局十分常见的一个效果，当我们需要在底部固定一个内容，当页面内容不够时，底部内容被固定到底部，而当页面内容比较多超过了整个屏幕的大小时，底部固定内容要跟着往下走，而不遮挡到上面的内容，这个布局使用fixed布局无法做到 具体实现html部分123456789&lt;div class="detail" v-show="detailShow"&gt; &lt;div class="detail-wrapper clearfix"&gt; &lt;div class="detail-main"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="detail-close"&gt; &lt;i class="icon-close"&gt;&lt;/i&gt; &lt;/div&gt;&lt;/div&gt; css部分12345678910111213141516171819202122232425.detail &#123; position: fixed; z-index: 100; top: 0; left: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(7, 17, 27, 0.8); .detail-wrapper &#123; min-height: 100%; .detail-main &#123; margin-top: 64px; padding-bottom: 64px; &#125; &#125; .detail-close &#123; position: relative; width: 32px; height: 32px; margin: -64px auto 0 auto; clear: both; font-size: 32px; &#125;&#125; 首先detail-wrapper盒子是保证盒子最小要能够占满屏幕，这样才能够把detail-close挤到底部去 detail-main中的margin是根据项目实际情况决定的，可以不需要，而padding-bottom则是为了当内容超过一个屏幕的时候，内容不会覆盖到底部内容。 最后为detail-close设置负的margin-top则是将这个盒子定位到detail-wrapper中去，在页面内容不够长的时候，让脚部区域在固定的位置展示。 关于vue中dom以及一些异步操作所带来的问题 这个坑卡了三个小时，产生的原因是没有考虑到多个异步操作所带来的问题 首先组件中所有的数据都是由ajax异步请求过来的，而我将这个操作定义为了一个方法，然后到created中去执行了这个方法，获取数据。 然后我使用请求过来的数据来渲染页面，其中有一个部分是通过v-for渲染的。 在后面操作中发现需要使用到由v-for渲染出来的DOM元素，这个时候我使用ref绑定到这些DOM元素。 然后在mounted中去操作DOM元素，这个时候发现无法从this.$refs中取到使用v-for渲染出来的DOM，然而在this.$refs对象中是保存了这个DOM元素的，但是当访问这些DOM元素时会发现结果是undefined。期间将操作放到$nextTick函数里面回调也无法取得DOM元素，非常的奇怪。 经过三个多小时的谷歌，也无法发现问题出在哪里了，最后我把获取DOM元素的操作放到ajax请求数据的函数中去执行时问题解决了，那么问题可能就出现在当我获取DOM元素时没有考虑到获取数据这个异步操作，导致虽然使用了$nextTick任然无法获取到DOM元素，因为这个时候可能数据还没有取到，所以还没有渲染到页面上，也就无法取得DOM元素了。 问题代码1234567891011// 获取数据的操作created() &#123; this.getGoods()&#125;,// 操作DOM元素的方法mounted() &#123; this.$nextTick(() =&gt; &#123; this._initScroll() this._calculateHeight() &#125;)&#125; 改进之后的代码123456789101112created() &#123; this.$http.get('/api/goods').then(res =&gt; &#123; res = res.body if (res.errno === ERR_OK) &#123; this.goods = res.data this.$nextTick(() =&gt; &#123; this._initScroll() this._calculateHeight() &#125;) &#125; &#125;)&#125; ##元素宽度自适应设备宽度，且宽高相等的布局 移动端在进行图片展示的时候，一般大的图片要求是宽度自适应，而且宽度高度相等布局，而由于图片的宽度是由设备大小所决定，我们就无法将宽度高度固定，而如果不对图片容器固定宽高，当网络速度比较慢时，图片会在页面渲染之后才会请求得到，图片请求到之后插入页面时会改变页面的布局，会导致页面抖动。 解决办法 给图片的容器设置width:100%然后设置padding-top:100%这样就能保证容器在没有图片时会有一个与宽度相等的高度。里面的图片元素设置绝对定位，就能够保证图片脱离文档流，不受容器的padding的影响。 购物车小球动画和添加商品的cartcontrol组件这一个部分是整个项目中最难的一个部分，由于项目比较简单所以没有使用vuex,也就导致了兄弟组件之间通信比较麻烦。 小球动画的原理 首先小球是设计在购物车组件之中的，为了满足点击需求一共设计有5个小球，将5控制5个小球的展示和隐藏以数组的形式存到data当中，然后通过v-for指令生成小球。并且在data中定义一个空数组dropBalls用来存放下落的小球。 当点击添加商品的按钮时，小球就会从添加按钮中运动到购物车中，而由于小球一开始是在购物车中的，那么在点击的时候就需要将小球移动到点击按钮中，然后通过过渡让小球从按钮上移动回到购物车里。 由于每个商品中都有一个添加按钮，那么我们就需要在点击按钮时动态获取当前点击按钮的位置，通过这个位置计算出小球应该移动的距离。 而问题的关键在于按钮组件与购物车组件是兄弟组件，它们的父组件是商品页面的goods组件。我们就需要解决如何将按钮组件中的按钮的位置传递给购物车组件。 将按钮组件的位置传递给购物车组件兄弟组件之间无法直接通信，所以解决办法是，利用一个中间组件——父组件，来间接的实现通信。 从cartcontrol组件中将添加按钮的dom对象传递给父组件。 12345678910111213// 在goods组件中定义方法,并传递给cartcontrol组件，获取点击时cartcontrol中添加按钮的dom对象addFood(target) &#123; this._drop(target)&#125;// 在点击添加按钮时在cartcontrol中执行父组件传递过来的方法，并将事件对象，也就是添加按钮的dom对象传递给父组件addCart(event) &#123; if (!this.food.count) &#123; Vue.set(this.food, 'count', 1) &#125; else &#123; this.food.count++ &#125; this.$emit('add', event.target)&#125; 将获取到的按钮对象传递给shopcart组件 123456789101112131415161718// 这里通过vue的ref属性就可以获取到子组件的对象，也就可以调用子组件中的方法，从而将按钮对象传递给shopcart组件_drop(target) &#123; // 性能优化 this.$nextTick(() =&gt; &#123; this.$refs.shopcart.drop(target) &#125;)&#125;// 购物车中的drop方法接受到按钮对象之后，遍历小球数据，将按钮对象保存到找到的第一个没有运动的小球中，并将这个小球对象添加到正在下落的小球数组dropBalls中。drop(el) &#123; for (let i = 0; i &lt; this.balls.length; i++) &#123; let ball = this.balls[i] if (!ball.show) &#123; ball.show = true ball.el = el this.dropBalls.push(ball) return &#125; &#125; 利用transition来实现小球动画小球的动画我们通过vue提供的transition的钩子函数来控制小球的动画。 123456789101112131415161718192021222324252627282930313233343536373839// 找到显示的小球，然后将这个小球移动到目标位置beforeDrop(el) &#123; let count = this.balls.length while (count--) &#123; let ball = this.balls[count] if (ball.show) &#123; let rect = ball.el.getBoundingClientRect() let x = rect.left - 32 let y = -(window.innerHeight - rect.top - 22) el.style.display = '' el.style.webkitTransform = `translate3d(0,$&#123;y&#125;px,0)` el.style.transform = `translate3d(0,$&#123;y&#125;px,0)` let inner = el.getElementsByClassName('inner-hook')[0] inner.style.webkitTransform = `translate3d($&#123;x&#125;px,0,0)` inner.style.transform = `translate3d($&#123;x&#125;px,0,0)` &#125; &#125;&#125;,// 给小球设置过渡动画dropping(el, done) &#123; /* eslint-disable no-unused-vas */ // 这里是手动触发浏览器的重排，他会强制刷新队列要求样式修改任务立即执行 let rf = el.offsetHeight this.$nextTick(() =&gt; &#123; el.style.webkitTransform = 'translate3d(0,0,0)' el.style.transform = 'translate3d(0,0,0)' let inner = el.getElementsByClassName('inner-hook')[0] inner.style.webkitTransform = 'translate3d(0,0,0)' inner.style.transform = 'translate3d(0,0,0)' el.addEventListener('transitionend', done) &#125;)&#125;,// 手动将执行完动画的小球隐藏，这里注意，由于在取的时候我们是从后往前找显示的小球，而dropBalls是push方法将显示小球添加的，所以执行完动画的小球应该是dropBalls数组中的第一个，使用shift方法把它从dropBalls数组中删除，并隐藏它。afterDrop(el) &#123; let ball = this.dropBalls.shift() if (ball) &#123; ball.show = false el.style.display = 'none' &#125; 商品页面的商品购买价格计算以及购买商品的数量的展示这个部份充分发挥了vue以数据驱动视图的特性，能充分感受到mvvm框架在数据操作上的优势。这里主要涉及到单个商品的数量，以及所有购买商品的数量，还有所有商品的总价，在多个组件之间的联合展示。这里的组件结构是一个父组件goods子组件有cartcontrol shopcart food这三个组件。 整体的业务需求 在商品页面展示所有商品列表，每个商品都有一个添加商品的按钮，当每个商品购买数量多于0个时，就会在添加按钮旁边显示购买数量。 当商品的购买数量不为0是购物车就会显示商品数量的总和，以及商品的总价，当切换到单个商品详情页food组件时，这些状态都不会改变。 实现 添加商品 123456789// 在cartcontrol组件中，点击添加商品按钮的事件，判断商品对象中是否有count属性，如果没有则添加这个属性并将它的值设置为1，如果有则count数量+1addCart(event) &#123; if (!this.food.count) &#123; Vue.set(this.food, 'count', 1) &#125; else &#123; this.food.count++ &#125; this.$emit('add', event.target)&#125;, 计算选中商品的数量 1234567891011// 在goods组件中定义一个计算属性，来储存被选中的商品。selectFoods() &#123; let result = [] this.goods.forEach((good) =&gt; &#123; good.foods.forEach((food) =&gt; &#123; if (food.count &amp;&amp; food.count &gt; 0) &#123; result.push(food) &#125; &#125;) &#125;) return result 然后通过selectFoods中被选中商品的对象就可以计算出被选中商品的数量，以及商品的总价了。]]></content>
      <categories>
        <category>vue.js学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue.js(六)]]></title>
    <url>%2F2018%2F07%2F14%2Fvue.js(%E5%85%AD)%2F</url>
    <content type="text"><![CDATA[vuex的使用为什么要使用vuex？当我们的项目中组件非常多，而在项目中有一部分的数据是多个组件所共同使用的，这个时候在组件之间传递这个共用的数据就会非常的麻烦。那么我们就建立一个专门储存这些共用数据的地方，当有那个组件需要使用到这个数据的时候，直接去这个储存数据的地方取用数据即可，而vuex就是一个可以提供储存公用数据的插件。 起步 安装 1npm i vuex 在项目中引入vuex 12import Vuex from 'vuex' Vue.use(Vuex) 创建一个store，并挂载到vm实例中去 12345678910const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;) 其中第一个对象state用来存放公用数据。 第二个对象mutations用来定义操作数据的方法。 在组件中访问和操作公用数据 我们已经把store对象挂载到了vm实例中，那么我们就可以通过vm实例中的$store去访问到数据，如：this.$store.state.数据对象名称 如果我们要对数据进行操作，那么首先要在mutations去定义操作数据的方法，再到组件中去调用这个方法，因为一旦有多个组件需要对这个数据进行操作，而每个组件操作的方法又不一样，那么一旦数据发生错误，我们就很难定位到时那个组件的方法所导致的错误，所以需要操作数据时先在mutations中定义这个方法，然后再调用。this.$store.commit(&#39;reduce&#39;) mutations中的函数只能接受两个参数，第一个参数默认为state，第二参数是自定义参数，如果有需要就可以传，没有需要就不用传，不能再去定义第三个形参了，函数内部接受不到，如果需要传递多个参数进去，只能通过给第二个参数传递对象。 如果我们需要将数据进行加工之后再返回给组件，那么可以在getters中定义数据加工的函数，这个属性和filter过滤器比较相似，可以对数据进行操作而不改变数据本身，最后通过return返回加工后的数据。在定义函数时接受state作为其第一个参数，]]></content>
      <categories>
        <category>vue.js学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[webpack(一)]]></title>
    <url>%2F2018%2F07%2F08%2Fwebpack%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[webpack起步什么是webpack？webpack是前端的一个项目构建工具，是基于Node.js开发出来的一个前端工具。 webpack的作用借助webpack这个前端自动化构建工具，可以完美的实现资源的合并、打包、混淆等诸多功能。 webpack和Gulp的区别 使用Gulp，是基于task任务的； 使用webpack，是基于整个项目进行构建的； webpack的安装 运行npm i webpack -g全局安装webpack，这样就可以在全局使用webpack命令了。 在项目根目录中运行npm i webpack --save-dev安装到项目依赖中。 在使用webpack4时还需要安装webpack-cli，使用npm安装即可 webpack能做什么？ webpack可以处理JS文件的相互依赖关系。 webpack能够处理JS的兼容问题，把高级的、浏览器无法识别的语法，转为低级的，浏览器可以识别的语法。 webpack配置文件的基本使用webpack是基于Node开发的，所以在webpack配置文件中使用node的语法进行相应的配置。 首先配置文件中可以载入node中的模块，来进行相应的操作，如：可以载入node中的path模块，那么我们就可以使用这个模块中的相应的方法了。 我们的配置全部挂载到module.exports对象中去。通过模块的导出，将配置对象导出。 配置对象中的属性 entry表示使用webpack打包哪一个文件，传入的值是需要打包的文件的路径。 output输出文件的相关配置，是一个对象，传入两个属性： path指定打包之后的文件保存的目录 filename指定打包之后输出文件的名称 初步使用当配置好配置文件之后我们就可以开始打包我们的文件了，在项目的根路径输入webpack命令即可开始打包。在打包过程中webpack做了下面几步： 首先，webpack回去项目的根目录中查找一个叫做webpack.config.js的配置文件 找到配置文件之后，webpack会去解析这个配置文件，当解析完配置文件后，就得到了配置文件中导出的配置对象。 拿到配置对象后，从配置对象中找到指定的入口和出口，然后对文件进行打包构建。 webpack-dev-server的使用在使用webpack时，我们的代码每更新一次就需要重新执行webpack命令打包一次，这样操作非常的繁琐，webpack-dev-server可以解决这个问题，它可以监听代码的变化提供自动打包服务。 安装 在项目根目录下运行npm i webpack-dev-server -D命令，将工具安装到项目的本地开发依赖中。 由于webpack-dev-server是安装在项目中，而没有在全局中安装，所以无法把它当做脚本命令在powershell终端中直接运行(只有那些安装在全局-g的工具，才能够在终端中正常运行) 我们可以借助npm来运行我们的工具，在npm生成的package.json配置文件中的scripts属性中添加我们的工具。添加一个属性&quot;dev&quot;: &quot;webpack-dev-server&quot;,然后我们就可以在命令行中执行npm run dev，这样就可以运行我们的webpack-dev-server了。 webpack-dev-server配置命令 可以直接到package.json文件中的secript中我们自己设置的dev属性的后面添加命令参数。 设置修改完后自动打开浏览器的命令&quot;dev&quot;: &quot;webpack-dev-server --open&quot; 修改服务器占用的端口号命令&quot;dev&quot;: &quot;webpack-dev-server --open --port 3000&quot; 设置打开浏览器是展示的根路径命令&quot;dev&quot;: &quot;webpack-dev-server --open --port 3000 --contentBase src&quot; 启用热重载命令&quot;dev&quot;: &quot;webpack-dev-server --open --port 3000 --contentBase src --hot&quot; 在没有启用热重载时，当我们更新代码时webpack会直接将整个文件全部重新打包一遍，而启用热重载之后每次更新代码之后，将会只更新我们修改过的代码那一部分，而不会将整个文件重新打包。 启用热重载之后当我们更新css样式时，页面不会整体刷新，会进行异步的请求。 可以到webpack.config.js中去进行相应的命令配置 在webpack.config.js中启用热更新，需要在配置文件中引入webpack模块，然后到配置对象中的plugins中加入一个热更新的模块对象，最后才能启用热更新。 12345678910const webpack = require('webpack')devServer: &#123; //这是配置dev-server命令参数的第二种形式 open: true, port: 3000, contentBase: 'src', hot: true &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ] 使用html-webpack-plugin插件配置启动页面使用html-webpack-plugin的作用有： 会自动在内存中根据指定的页面生成一个内存中的页面。 会自动把内存中打包好的bundle.js插入到页面中去，不需要我们手动引入。 配置 下载。 在webpack.config.js文件中引入html-webpack-plugin模块。 在配置对象中的plugins属性中加入一个htmlWebpackPlugin对象实例。 在这个对象实例中传入配置参数 template属性指定模板页面，将来会根据指定的页面路径，生成内存中的页面 filename指定生成页面的名称 123456789const htmlWebpackPlugin = require('html-webpack-plugin')plugins: [ new webpack.HotModuleReplacementPlugin(), new htmlWebpackPlugin(&#123; template: path.join(__dirname, './src/index.html'),//指定模板页面 //将来会根据指定的页面路径，去生成内存中的页面 filename: 'index.html' //指定生成的页面的名称 &#125;) ] 配置处理css样式表的第三方loaderwebpack默认只能打包处理JS类型的文件，无法处理其他非JS类型的文件，如果我们需要在项目中处理其他类型的文件，那么就需要配置处理第三方文件的loader，下面以配置css的loader为例，演示loader的配置。 安装npm i style-loader css-loader -D 打开webpack.config.js这个配置文件，在配置对象里面，新增一个配置属性，叫做module，他是一个对象，在这个对象身上有个rules属性，这个rules属性是个数组；这个数组中存放了所有的第三方文件的匹配处理规则。 每个处理规则以对象的形式存在，有两个属性test匹配文件后缀名的正则表达式，第二个属性use匹配之后处理的loader。 123456module: &#123; rules: [&#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;] &#125; webpack处理第三方文件类型的过程 发现这个要处理的文件不是JS文件，然后就会去配置文件中，查找有没有对应的第三方loader规则。 如果能找到对应的规则，就会调用对应的loader处理这种类型的文件。 在调用loader的时候，是从后往前调用的，后面的loader把文件处理之后再交给前面的loader进行处理，直到调用完所有的loader，然后会把处理结果交给webpack进行打包。 处理常见的第三方文件需要下载的loader 处理less文件时需要下载style-loader、css-loader、less-loader在配置文件use属性中也是按照这个顺序设置，在需要处理less文件时，除了下载和设置loader，还需要在项目中下载less的包才能正常处理。 处理url资源，如：图片、字体文件等资源： 需要按照url-loader和file-loader注意在use中只需要设置url-loader即可，file-loader为内部依赖，不需要配置。 如果需要向loader中传入参数时可以在use中的loader名称之后通过?传参的方式传递。 在处理图片时默认会转换为base64的格式，我们可以通过设置参数来控制，使小图片转换为base64格式，大图片不转换。 limit参数，设置转换为base64格式的最大文件，文件达到设置的限制，就不会被转换。 name参数，设置文件的名字。为了避免名字重复的情况，url-loader会自动将名字转换为一个随机的hash值，我们可以设置name=[name].[ext]这样子文件在展示的时候就会是文件本身的名字。但是注意我们在磁盘中的文件一个文件夹中不会有两个同名文件，但是我们在使用url-loader之后不会再有文件路径了，只会有文件名，所以如果我们使用了不同文件夹中的相同文件名的两个文件，就会出问题，后面文件会覆盖前面的文件。所以如果想显示本身文件名又要避免文件同名的情况，可以这样做：name=[hash:8]-[name].[ext],这样就在原文件名的前面添加了8位的hash值，就不会出现重名的情况了。hash值最多是32位。 babel的配置在webpack中默认只能够处理一部分ES6的新语法，一些更高级的ES6语法或者ES7语法，webpack处理不了，这个时候就需要接触与第三方的loader，来帮助webpack来处理这些高级的语法，当第三方loader把高级语法转为低级语法之后，会把结果交给webpack，打包到bundle.js中。 安装： 第一套包： npm i babel-core babel-loader babel-plugin-transform-runtime -D，这一套包相当于babel的转换工具。 第二套包：npm i babel-preset-env babel-preset-stage-0 -D，这一套包中有高级语法到低级语法的对应关系。这里present翻译为语法 打开webpack的配置文件，在module节点的rules数组中，添加一个新的匹配规则： { test: test: /\.js$/, use: &#39;babel-loader&#39;, exclude:/node_modules/} 我们在配置babel的loader规则时，必须把node_modules目录通过exclude选项排除掉。原因有两个： 如果不排除node_modules，那么babel会把node_modules中所有的第三方JS文件，都打包编译，这样会非常消耗CPU，打包速度也非常慢。 如果最终node_modules中的JS被转换完毕了，我们的项目也是无法运行的。 在项目的根目录中新建一个叫做.babelrc的Babel配置文件，这个配置文件，属于JSON格式，所以在写.babelrc配置的时候，必须符合JSON语法的规范。 在.babelrc中写如下配置: 1234&#123; "presets": ["env", "stage-0"], "plugins": ["transform-runtime"]&#125;]]></content>
      <categories>
        <category>webpack学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue.js(四)]]></title>
    <url>%2F2018%2F07%2F07%2Fvue(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[组件之间的传值父组件向子组件传值 父组件可以在使用子组件的时候把值通过属性绑定的形式传递给子组件，如：&lt;son :parentmes=&quot;mes&quot;&gt;&lt;/son&gt; 子组件在使用之前需要在子组件的props这个属性中先定义一下传递过来的值，props属性是一个数组，将传递过来的值的名称以字符串形式放到props里面即可，如：props: [&#39;parentmes&#39;] 使用props中的值和使用data中的值的方法一样。 注意：由父组件传递过来的props中的值是只读的，不能够在子组件中修改。 12345678910111213141516171819202122232425262728&lt;div id="app"&gt; &lt;son :parentmes="mes"&gt;&lt;/son&gt; &lt;/div&gt; &lt;template id="son"&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;sonMes&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;parentmes&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; mes: '父组件的值' &#125;, components: &#123; son: &#123; template: '#son', props: ['parentmes'], data() &#123; return &#123; sonMes: '我是子组件的的mes' &#125; &#125; &#125; &#125; &#125;) &lt;/script&gt; 父组件向子组件传递方法 父组件可以在在使用子组件的时候利用v-bind:绑定把父组件中的方法传递给子组件，如：&lt;son :parentmes=&quot;mes&quot; @parent-method=&quot;parentMethod&quot;&gt;&lt;/son&gt; 在需要调用父组件传递过来的方法的时候可以使用this.$emit(&#39;parent-method&#39;)来直接调用。如果需要传递参数那么直接在方法名字符串后面传递，如：this.$emit(&#39;parent-method,参数1，参数2&#39;) 通过这个也可以实现子组件向父组件传值。 123456789101112131415161718192021222324252627282930var vm = new Vue(&#123; el: '#app', data: &#123; mes: '父组件的值', sonData: '' &#125;, methods: &#123; parentMethod (mes) &#123; console.log('我是父组件的方法打印的方法') this.sonData = mes &#125; &#125;, components: &#123; son: &#123; template: '#son', props: ['parentmes'], data() &#123; return &#123; sonMes: '我是子组件的的mes' &#125; &#125;, methods: &#123; sonMethod () &#123; this.$emit('parent-method',this.sonMes) &#125; &#125; &#125; &#125; &#125;) &lt;/script&gt; 使用ref获取DOM元素和组件的引用在Vue中不提倡直接操作DOM元素，我们需要对DOM进行操作的时候可以使用Vue中提供的ref来实现 为需要操作的DOM元素绑定ref=“名称”属性，绑定之后再Vue实例中的$refs属性中就会以对象的形式保存这个DOM元素的引用,属性的名称就是将来访问属性时的key。如：&lt;h1 ref=&quot;domH1&quot;&gt;你好我是h1DOM&lt;/h1&gt; 使用时只需要通过Vue的实例对象来访问$refs属性就可以了，在Vue实例对象内部通过this.$refs.名称即可访问到相应的DOM元素。 当然通过这种方法我们也可以直接获取到组件的引用，从而在父组件中访问到子组件中所有的data和methods等。 路由什么是路由？ 后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 前端路由：对应单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要使用hash来实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由 vue-router的基本使用 当导入了vue-router包之后在window全局对象中，就有了一个路由的构造函数，叫做VueRouter，我们就可以创建一个VueRouter的实例,并且进行相应的配置 设置VueRouter实例中的routes属性，这个属性就是路由的匹配规则，它是一个数组，数组中每个路由匹配规则以对象的形式存在。每个规则对象有两个属性： 属性1：path表示监听那个路由链接地址 属性2：component表示当路由地址匹配时所展示的相应的组件，这里传入组件对象 把VueRouter实例挂载到vue实例对象的router属性中即可。 1234567891011121314151617181920212223242526var login = &#123; template: '#login' &#125; var register = &#123; template: '#register' &#125; var routerObj = new VueRouter(&#123; routes: [&#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ] &#125;) var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router: routerObj &#125;) ruter-link的使用 vue-router中提供了一个专门用于路由链接的元素&lt;router-link&gt;，在这个元素中的to属性中设置跳转的路由，前面可以不用加#。 &lt;router-link&gt;默认渲染为一个a链接，当然也可以通过元素的tag属性修改渲染之后的元素 12&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;router-link to="/register" tag="span"&gt;注册&lt;/router-link&gt; 路由redirect重定向的使用使用redirect使路由满足条件时不是切换组件而是重定向到某个路由中去。如：{path: &#39;/&#39;, redirect: &#39;/login&#39;},在访问首页时，就会自动切换到login路由加载login的组件 设置选中路由的样式 使用&lt;router-link&gt;来控制路由跳转时，被选中的路由会自动添加一个router-link-active的类名，我们就可以利用这个类名来设置选中路由的样式。 当然我们也可以自定义选中路由的类名，可以在VueRouter实例中设置linkActiveClass属性，来修改默认的选中类名。 路由传参 使用query方式传递参数 可以直接通过修改路由链接，在路由链接后面使用?传参，不用去修改路由规则 参数保存在Vue实例中的$route.query属性中，以对象的形式存在，需要使用时以对象的方式访问即可,如：$route.query.id即可访问到?后面的id的值。 使用params方式传递参数 这个方法需要改变路由的匹配规则，在路由匹配规则中设置需要传的值，然后在vue-router内部会通过正则表达式来匹配，如果没有格式没有匹配正确，那么就无法显示组件。匹配规则如：path: &#39;/register/:id/:name&#39; 参数保存在Vue实例中的$route.params属性中，以对象的形式存在，需要使用时以对象的方式访问即可,如：$route.params.id即可访问到id的值。 路由嵌套 如果想在一个路由的下面加入子路由，那么可以使用路由规则对象的children属性，这个属性是一个数组，里面放入子路由的路由规则对象。 子路由的路由规则对象需要注意path属性前面不能带/否则就会以根路径开始请求。 父路由加载子路由时的跳转链接应该是/父路由/子路由,如：&lt;router-link to=&quot;/account/login&quot;&gt;登录&lt;/router-link&gt; 123456789101112131415var routerObj = new VueRouter(&#123; routes: [&#123; path: '/account', component: account, children: [&#123; path: 'login', component: login &#125;, &#123; path: 'register', component: register &#125; ] &#125;]&#125;)]]></content>
      <categories>
        <category>vue.js学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue.js(三)]]></title>
    <url>%2F2018%2F07%2F05%2Fvue(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[Vue组件化什么是组件？组件的出现就是为了拆分Vue实例的代码量，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可。 组件化和模块化的区别： 模块化：是从代码逻辑的角度进行划分的；方便代码的分层开发，保证每个功能模块的职能单一； 组件化：是从UI界面的角度进行划分，前端组件化的目的是方便UI组件的重复使用 创建组件的方式 使用Vue.extend来创建组件模板对象。在template属性中传入组件的模板字符串也就是组件的HTML结构 使用Vue.component(&#39;组件名称&#39;,创建出来的组件模板对象) 使用组件时只需要把组件名称以HTML标签的形式放到指定的Vue实例的节点里面去 在设置组件名称时注意如果组件名称以驼峰命名如myCom1那么在使用组件时的标签应该是my-com1 如果没有使用驼峰命名，那么标签名就是组件名 1234567891011&lt;div id="app"&gt; &lt;my-com1&gt;&lt;/my-com1&gt; &lt;/div&gt; &lt;script&gt; Vue.component('myCom1', Vue.extend(&#123; template: '&lt;h1&gt;这个是使用extend创建的组件&lt;/h1&gt;' &#125;)) var vm = new Vue(&#123; el: '#app', &#125;) &lt;/script&gt; 在设置模板时要注意，模板有且只能有一个根元素，否则会报错。 模板对象也可以直接传入一个对象如下所示： 123Vue.component('myCom1', &#123; template: '&lt;h1&gt;这个是使用extend创建的组件&lt;/h1&gt;'&#125;) 当需要设置复杂的模板时我们也可以在vue实例标签外利用&lt;tempalte&gt;标签来设置 1234567891011121314151617&lt;div id="app"&gt; &lt;my-com1&gt;&lt;/my-com1&gt; &lt;/div&gt; &lt;template id="tmp1"&gt; &lt;div&gt; &lt;h1&gt;我是由template标签创造出来的模板&lt;/h1&gt; &lt;h2&gt;哈哈哈哈&lt;/h2&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; Vue.component('myCom1',&#123; template: '#tmp1' &#125;) var vm = new Vue(&#123; el: '#app' &#125;) &lt;/script&gt; 定义私有组件在Vue实例中的components属性中定义私有组件 12345678var vm2 = new Vue(&#123; el: '#app2', components: &#123; private: &#123; template: '#tmp2' &#125; &#125; &#125;) 组件中data在每个组件中也是有data和methods等属性的，但是注意组件中的data应该是一个函数，函数返回一个对象，在返回的这个对象中存数据。 这么做的原因是：如果data是以对象形式存在，那么所有组件的data都是指向同一个data，这样子只要改变一个组件的data所有组件的data就都会改变，而如果是通过函数返回data的话每次新建出来的组件的data就是一个重新创建的data了，各组件之间互不影响。 123456789101112131415Vue.component('myCom1', &#123; template: '#tmp1', data: function () &#123; return &#123; hello: 'hello 组件', say: '' &#125; &#125;, methods: &#123; change () &#123; this.hello = this.say this.say = '' &#125; &#125; &#125;) 组件的切换使用v-if和v-else结合flag进行组件切换12345678910111213141516171819202122232425262728293031&lt;div id="app"&gt; &lt;a href="" @click.prevent="flag = false"&gt;注册&lt;/a&gt; &lt;a href="" @click.prevent="flag = true"&gt;登录&lt;/a&gt; &lt;log-in v-if="flag"&gt;&lt;/log-in&gt; &lt;register v-else="flag"&gt;&lt;/register&gt; &lt;/div&gt; &lt;template id="login"&gt; &lt;h1&gt;这是登录页面&lt;/h1&gt; &lt;/template&gt; &lt;template id="register"&gt; &lt;h1&gt;这是注册页面&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; flag: true &#125;, methods: &#123; &#125;, components: &#123; logIn: &#123; template: '#login' &#125;, register: &#123; template: '#register' &#125; &#125; &#125;) &lt;/script&gt; 使用vue提供的component元素实现组件的切换123456789101112131415161718192021222324252627282930&lt;div id="app"&gt; &lt;a href="" @click.prevent="tempName = 'register'"&gt;注册&lt;/a&gt; &lt;a href="" @click.prevent="tempName = 'logIn'"&gt;登录&lt;/a&gt; &lt;component :is="tempName"&gt;&lt;/component&gt; &lt;/div&gt; &lt;template id="login"&gt; &lt;h1&gt;这是登录页面&lt;/h1&gt; &lt;/template&gt; &lt;template id="register"&gt; &lt;h1&gt;这是注册页面&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; tempName: 'logIn' &#125;, methods: &#123; &#125;, components: &#123; logIn: &#123; template: '#login' &#125;, register: &#123; template: '#register' &#125; &#125; &#125;) &lt;/script&gt; 在组件切换时应用动画123&lt;transition name="tmp" mode="out-in"&gt; &lt;component :is="tempName"&gt;&lt;/component&gt;&lt;/transition&gt; 然后使用css设置动画即可，其中mode=&quot;out-in&quot;的作用是设置切换的方式，这里是先消失再出现]]></content>
      <categories>
        <category>vue.js学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue.js(二)]]></title>
    <url>%2F2018%2F07%2F03%2Fvue(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[过滤器概念： Vue.js允许自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：差值表达式和v-bind表达式，过滤器应该被添加在JavaScript表达式的尾部，由“管道符‘’|指示。 全局过滤器在全局条件下创建过滤器就是全局过滤器，所有的Vue实例都可以使用这个过滤器。 创建： 12345678910Vue.filter('dateFormat', function (dateStr) &#123; var now = new Date(dateStr), year = now.getFullYear(), month = (now.getMonth() + 1).toString().padStart(2,fillString='0'), date = now.getDate().toString().padStart(2,fillString='0'), hour = now.getHours().toString().padStart(2,fillString='0'), minutes = now.getMinutes().toString().padStart(2,fillString='0'), time = `$&#123;year&#125;-$&#123;month&#125;-$&#123;date&#125; $&#123;hour&#125;:$&#123;minutes&#125;` return time &#125;) 上面使用了一个es6的字符串方法，String.prototype.padStart(maxLength,fillString=&#39; XX&#39;)第一个参数是字符串的最大长度，如果没有达到最大长度则从字符串头部开始添加第二个参数，直到满足长度。类似的还有String.prototype.padStart(maxLength,fillString=&#39; XX&#39;)这个是添加到尾部 使用 1&lt;td&gt;&#123;&#123;item.time | dateFormat &#125;&#125;&lt;/td&gt; 私有过滤器如果想定义一个只有某一个Vue实例才能访问的私有过滤器，需要在Vue实例里面的filters属性中添加过滤方法。 123456789101112131415161718192021var vm = new Vue(&#123; el: '.app', data: &#123; &#125;, methods: &#123; &#125;, filters: &#123; dateFormat: function (dateStr) &#123; var now = new Date(dateStr), year = now.getFullYear(), month = (now.getMonth() + 1).toString().padStart(2, fillString = '0'), date = now.getDate().toString().padStart(2, fillString = '0'), hour = now.getHours().toString().padStart(2, fillString = '0'), minutes = now.getMinutes().toString().padStart(2, fillString = '0'), time = `$&#123;year&#125;-$&#123;month&#125;-$&#123;date&#125; $&#123;hour&#125;:$&#123;minutes&#125;` return time &#125; &#125; &#125;) 自定义按键修饰符按键修饰符可以控制键盘事件中只有触发特定的键才执行这个事件，比如：当内容输入完成点击回车提交表单。 框架内置的按键修饰符： .enter .tab .delete .space .esc .up .dowm .left .right 其他按键需要使用每个键的keyCode来访问，也可以通过全局config.keyCodes对象自定义按键修饰符别名： 1234//自定义按键修饰符Vue.config.keyCodes.f1 = 112//使用按键修饰符来控制事件&lt;input type="text" @keyup.enter="add"&gt; 自定义指令在需要对普通DOM元素进行底层操作时，可以使用自定义指令，自定义指令的名称不需要带v-，在Vue的底层会自动加上这个前缀，所以在使用的时候v-指令名称。 全局指令 自定义全局指令使用Vue对象的directive()方法，第一个参数是指令名称，第二个参数是一个对象，里面是指令的钩子函数 1234567891011Vue.directive('foucs', &#123; bind: function (el) &#123; //当指令绑定到元素上时，会立即执行bind函数，只执行一次 el.style.color = 'red' &#125;, inserted: function (el) &#123; //当元素插入到DOM中的时候，会执行inserted函数只触发一次 el.focus() &#125;, update: function (el) &#123; //所在组件的VNode更新时调用，也可能发生在其子VNode更新之前 &#125; &#125;) 私有指令 可以在Vue实例内部的directives属性内添加私有指令。 12345678910111213141516171819var vm = new Vue(&#123; el: '.app', data: &#123; &#125;, directives: &#123; focus: &#123; bind: function (el) &#123; //当指令绑定到元素上时，会立即执行bind函数，只执行一次 el.style.color = 'red' &#125;, inserted: function (el) &#123; //当元素插入到DOM中的时候，会执行inserted函数只触发一次 el.focus() &#125;, update: function (el) &#123; //所在组件的VNode更新时调用，也可能发生在其子VNode更新之前 &#125; &#125; &#125; &#125;) 钩子函数 bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 钩子函数的参数 el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括v-前缀。 value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot;中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode: Vue 编译生成的虚拟节点。 oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated钩子中可用。 简写形式：指令函数中使用比较多的就是bind和update，如果我们只关心这两个状态时触发的行为那么就可以简写： 123Vue.directive('color-swatch', function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;) 对象字面量如果指令需要接受多个值，那么可以传入一个JavaScript对象字面量。指令函数能够接受所有合法的JavaScript表达式。 1&lt;div v-demo="&#123; color: 'white', text: 'hello!' &#125;"&gt;&lt;/div&gt; 1234Vue.directive('demo', function (el, binding) &#123; console.log(binding.value.color) // =&gt; "white" console.log(binding.value.text) // =&gt; "hello!"&#125;) Vue实例的生命周期 生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 声明周期钩子：就是生命周期事件的别名 主要生命周期函数分类： 创建时期的生命周期函数： beforeCreate：实例刚在内存中创建出来，还没有初始化好data和methods属性 created：实例已经在内存中创建出来，此时data和methods已经被创建出来，但是还没有开始编译模板。 beforeMount：此时已经完成模板的编译，但是还没有挂载到页面中。 mounted：此时已经编译好了模板，挂载到页面的指定容器中显示了。 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数，此时data中的状态值是最新的，但是界面上显示的数据还是旧的，因为此时还没有开始渲染DOM节点。 updated：实例更新完毕之后调用此函数，此时data中的状态值和界面上显示的数据，都已经完成了更新，界面被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用，在这一步实例任然可以使用。 destroyed：Vue实例销毁后调用，调用后，Vue实例指示的所有东西都会解绑，所有的事件监听器会被移除，所有的子实例也会被销毁。 使用vue-resource发送ajax请求vue中可以发送ajax请求的第三方包有vue-resource和axios 使用vue-resource发送请求： 1234567// 在全局中使用Vue.http.get('/someUrl', [config]).then(successCallback, errorCallback);Vue.http.post('/someUrl', [body], [config]).then(successCallback, errorCallback);// 在vue实例中使用this.$http.get('/someUrl', [config]).then(successCallback, errorCallback);this.$http.post('/someUrl', [body], [config]).then(successCallback, errorCallback); 全局配置数据接口的根域名 1Vue.http.options.root = '/root' 注意：如果在全局配置了数据接口的根域名，那么每次单独发送http请求的时候，请求的url路径时，应该以相对路径开头，前面不能带/，否则不会启用根路径做拼接 全局启用emulateJSON选项 1Vue.http.options.emulateJSON = true 这个配置的作用是，在手动发送ajax请求时修改为表单的形式发送请求。]]></content>
      <categories>
        <category>vue.js学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue.js(五)]]></title>
    <url>%2F2018%2F07%2F03%2Fvue(%E4%BA%94)%2F</url>
    <content type="text"><![CDATA[在vue中监听数据变化的方法 watch属性。 这个属性可以监视实例对象中指定数据的变化，然后触发watch中对应的处理函数 这个属性是一个对象，里面的每个属性的key为实例对象中需要监视的数据的名称，值为数据改变时调用的处理函数。这个处理函数有两个参数第一个是newVal，第二个是oldVal可以在函数中使用这两个值 123456789101112 watch: &#123; 'firstName': function (newVal, oldVal) &#123; this.fullName = newVal + '-' + this.lastName &#125;, 'lastName': function (newVal, oldVal) &#123; this.fullName = this.firstName + '-' + this.lastName &#125;, '$route.path': function (newVal, oldVal) &#123; console.log(newVal + '=======' + oldVal) console.log(this) &#125;&#125; computed计算属性 在computed中，可以定义一些属性，这些属性叫做计算属性，计算属性的本质是一个方法，但是在vue的底层会执行这个方法，然后得到方法的返回值，然后这个属性就会被挂载到vue实例中去，我们就可以直接通过vm.计算属性名来访问这个计算属性的计算后的返回值了。 12345computed: &#123; 'fullName': function () &#123; return this.firstName + '-' + this.lastName &#125;&#125; 使用vue实例的render方法渲染组件 render属性是一个方法，这个方法有一个参数createElements，这个参数是一个方法，调用它能够把指定的组件模板渲染为html结构。 在render的函数中return createElements(模板对象)那么这个组件会替换页面中el指定的那个容器。 123render: function (createElements) &#123; return createElements(login)&#125; 在webpack构建的项目中使用vuewebpack中导入vue和普通网页中使用script导入vue的区别 在webpack中通过import Vue from &#39;vue&#39;导入的vue文件是vue.runtime.common.js而我们使用script导入的vue是vue.js文件。 这个包中的vue模式为runtime-only的形式构建出来的包。 我们在webpack中导入的vue文件是功能不全的文件，所以有些功能是无法使用的。如果想使用vue.js文件，可以做通过以下操作来实现： 通过路径来导入vue文件import Vue from &#39;../node_modules/vue/dist/vue.js&#39; 直接修改vue包中package.json中的main属性，让main属性中的路径指向vue.js 在webpack的配置文件中添加以下属性： 12345resolve: &#123; alias: &#123; // 修改vue导入的时候包的路径 "vue$": "vue/dist/vue.js" &#125;&#125; 在vue中结合render函数渲染指定的组件到容器中在runtime-only的条件下我们无法使用components去渲染组件，在这种模式下需要使用一种新的方法来渲染组件。 首先我们需要为组件单独创建文件，文件的后缀名为.vue，文件的内容： &lt;template&gt;&lt;/template&gt;这里添加html结构。 &lt;script&gt;&lt;/script&gt;这里添加js代码 &lt;style&gt;&lt;/style&gt;这里添加css代码 如果要使用.vue类型的文件，我们还需要安装第三方loader。npm i vue-loader vue-template-compiler -D,这里的vue-loader内部依赖于vue-template-compiler,所以在设置rules时只需要use:&#39;vue-loader&#39;即可。 要想使用vue-loader还需要在配置文件中引入插件，这个插件就在vue-loader里面，需要加载到配置文件中：const VueLoaderPlugin = require(&#39;vue-loader/lib/plugin&#39;),然后再new一个VueLoaderPlugin的对象实例，放到plugins中去。 将我们创建的.vue结尾的组件文件使用import导入到入口文件中。 使用render函数渲染组件。 导入与导出成员在ES6中为我们提供了导入与导出成员的方法。 导入成员使用import 名称 form 文件地址，当在我们的入口文件中碰到这一行代码时，会自动加载并且执行文件地址所指向的文件中的代码，如果我们需要在代码执行完毕之后接受这个文件导出的成员，那么就可以在import后面带上一个任意变量名称，这个变量名称就会接受文件导出的成员，如果不需要接受文件导出的成员，那么可以不加变量名称。这样就只是单纯的执行文件中的代码。 导出成员有两种方式： export default 导出成员 使用这种方法导出的成员可以使用任意变量来接受。 在一个模块中export default 只允许向外暴露一次。 export导出成员 使用这种方式暴露的成员，只能够使用{ }的形式来接受，这种形式，叫做按需导出。 这种方式可以导出多个成员，在接受的时候我们想接受那个成员就在{}中添加这个成员导出时的变量名即可。 在接受成员时必须严格按照导出的时候的名称来接受。 如果想要更换变量名称那么可以使用as来起别名import preson, {title as header, content} from &#39;./test.js&#39; 在webpack中使用vue-router 下载并引入。 通过Vue.use(VueRouter)手动安装。 构建组件文件，并引入到页面中。 创建路由实例，设置路由规则，并挂载到vm实例上去。 组件中style标签的lang属性和scoped属性 默认条件下在组件中style标签中设置的是应用于全局的样式。 给style加上scoped属性之后，就会变成私有样式，只应用于自己这个组件。 组件中style标签中默认只能写css，如果想使用less或sass需要设置标签的lang属性。]]></content>
      <categories>
        <category>vue.js学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[es6(一)]]></title>
    <url>%2F2018%2F07%2F02%2Fes6(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[let命令let与var的区别 let所声明的变量只在let命令所在的代码块内有效(for循环的计数器适合使用let声明) 使用let所声明的变量不存在变量提升，在声明之前使用变量会报错 let不能重复声明同一个变量，也不能在函数内部重新声明变量，这样会报错。 暂时性死区 在块级作用域中使用let声明一个变量，那么在执行代码时这个变量就被绑定到了这个块级作用域而不会受外部作用域的影响。 12345var tmp = 12if (true) &#123; console.log(tmp)//ReferenceError: tmp is not defined let tmp&#125; 上面的代码在块级作用域中使用let声明了tmp那么在操作tmp时就不会去块级作用域外部寻找了，而变量声明又在使用之后那么就会报错。 如果变量使用let声明那么typeof就不再安全，因为如果在变量声明之前使用typeof 变量那么也会产生语法错误，而没有声明的变量反而不会报错，会返回undefined 块级作用域ES6新增的块级作用域的特点是：外层作用域无法读取内层作用域的变量。内层作用域可以定义外层作用域的同名变量而不会覆盖外层作用域的变量。]]></content>
      <categories>
        <category>es6入门读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue.js(一)]]></title>
    <url>%2F2018%2F07%2F01%2Fvue(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[基本指令数据渲染 起步 创建一个vue的实例 通过el属性来绑定要操作的元素。 在data中存元素需要使用的数据。 1234567891011&lt;div id="vue"&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; mes: 'hello world' &#125; &#125;)&lt;/script&gt; 渲染与方法： 直接使用模板语法渲染： 优点：灵活，它只是简单的替换模板语法所在的位置，元素中的其他字符串不受影响 缺点： 先加载html后加载vue.js文件网速较慢时页面会出现闪烁问题，因为在加载html时模板字符串被当做普通字符串解析，而加载完vue.js文件后模板字符串会被替换成相应的数据，页面会闪烁。 1234567891011&lt;div id="vue"&gt; &lt;p&gt;&#123;&#123; mes + 'world' &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; mes: 'hello ' &#125; &#125;)&lt;/script&gt; v-loack指令 给需要渲染数据的元素添加v-cloak属性 然后通过属性选择器来设置v-cloak属性的元素隐藏 这样可以解决低网速下闪烁问题 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; [v-cloak] &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="vue"&gt; &lt;p v-cloak&gt;&#123;&#123; mes &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src="vue.js"&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; mes: 'hello ' &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-text指令 v-text指令作用是使用数据替换掉元素内的所有内容 优点：这样不会引起闪烁问题 缺点： 元素内所有内容都被替换掉了，处理不够灵活 123456789101112&lt;div id="vue"&gt; &lt;p v-cloak&gt;&#123;&#123; mes &#125;&#125;&lt;/p&gt; &lt;h1 v-text="mes"&gt;&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; mes: 'hello ' &#125; &#125;)&lt;/script&gt; v-html指令 上面的指令都是插入字符串，就算是有HTML标签的字符串也会被转义直接当做字符串来输出 如果想插入HTML需要使用v-html 1234567891011121314&lt;div id="vue"&gt; &lt;p v-cloak&gt;&#123;&#123; mes &#125;&#125;&lt;/p&gt; &lt;h1 v-text="mes"&gt;&lt;/h1&gt; &lt;div v-html="mes2"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; mes: 'hello ', mes2: '&lt;h2&gt;hello world&lt;/h2&gt;' &#125; &#125;)&lt;/script&gt; v-bind:指令 v-bind:是用来绑定数据的指令 可以简写为:要绑定的属性 v-bind中可以写合法的JS表达式 1234567891011121314151617&lt;div id="vue"&gt; &lt;p v-cloak&gt;&#123;&#123; mes &#125;&#125;&lt;/p&gt; &lt;h1 v-text="mes"&gt;&lt;/h1&gt; &lt;div v-html="mes2"&gt;&lt;/div&gt; &lt;button v-bind:title="myTitle"&gt;点击&lt;/button&gt; &lt;button :title="myTitle + ' enen'"&gt;点击&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#vue', data: &#123; mes: 'hello ', mes2: '&lt;h2&gt;hello world&lt;/h2&gt;', myTitle: 'hello world' &#125; &#125;)&lt;/script&gt; vue实例内部的this 在vue实例的内部的this都是指向vue实例本身。 可以直接通过this来访问实例本身的属性或方法。 在data里面的属性和methods里面的方法是直接挂载在vue实例本身，可以直接通过this.属性来直接访问。 事件修饰符 .stop阻止冒泡 .prevent阻止默认事件 .capture添加事件监听器时使用事件捕获模式 .self只当事件在该元素本身(比如不是子元素)触发回调 .once事件只触发一次 v-model指令 使用v-model指令可以实现数据的双向绑定 之前的v-text和模板语法等只能实现数据单向绑定，即M层—&gt;V层，M层数据改变时V层数据会改变，V层数据改变时M层数据不会改变 而数据双向绑定则是任何一个层的数据改变都会对方层的数据 通过class控制样式 数组 使用v-bind:指令，class中传入类名数组 1&lt;h1 :class="['red','thin','italic']"&gt;这是一个h1标签啦啦啦&lt;/h1&gt; 三元表达式 在数组中可以使用三元表达式来控制样式的变化 1&lt;h1 :class="['red','thin',flag ? 'italic':'']"&gt;这是一个h1标签啦啦啦&lt;/h1&gt; 数组中嵌套对象 1&lt;h1 :class=&quot;[&apos;red&apos;,&apos;thin&apos;,&#123;&apos;italic&apos;: flag&#125;]&quot;&gt;这是一个h1标签啦啦啦&lt;/h1&gt; 直接传入一个对象 1&lt;h1 :class=&quot;&#123;red: true,thin: false,italic: true&#125;&quot;&gt;这是一个h1标签啦啦啦&lt;/h1&gt; 传入data中的对象 1&lt;h1 :class=&quot;classObj&quot;&gt;这是一个h1标签啦啦啦&lt;/h1&gt; 使用内联样式 直接传入一个data中定义好的对象 1&lt;h1 :style=&quot;styleObj1&quot;&gt;这是一个h1标签啦啦啦&lt;/h1&gt; 如果想使用多个样式对象传入一个数组就可以了 1&lt;h1 :style=&quot;[styleObj1,styleObj2]&quot;&gt;这是一个h1标签啦啦啦&lt;/h1&gt; v-for指令 可以遍历数组 1&lt;p v-for=&quot;(item, i) in arr&quot;&gt;爱好=====&#123;&#123;item&#125;&#125;=====索引=====&#123;&#123;i&#125;&#125;&lt;/p&gt; 可以遍历对象 1&lt;p v-for=&quot;(val, key) in obj&quot;&gt;爱好=====&#123;&#123;val&#125;&#125;=====索引=====&#123;&#123;key&#125;&#125;&lt;/p&gt; 循环对象数组 1&lt;p v-for=&quot;(user, i) in arrObj&quot;&gt;姓名=====&#123;&#123;user.name&#125;&#125;=====年龄=====&#123;&#123;user.age&#125;&#125;=====索引=====&#123;&#123;i&#125;&#125;&lt;/p&gt; 迭代数字 这里数字的迭代是从1开始的 1&lt;p v-for=&quot;(count, i) in 10&quot;&gt;&#123;&#123;count&#125;&#125;======&#123;&#123;i&#125;&#125;&lt;/p&gt; 使用v-for时的注意 当v-for正在更新渲染过的元素列表时，默认使用“就地复用”策略。如果数据项的顺序改变时，Vue将不是移动DOM元素来匹配数据项的顺序，而是简单复用此处每个元素，并保证它在特定索引下已被渲染过的每个元素。 为了给Vue一个提示，以便它可以跟踪每个节点的身份，从而重用和重新拍序现有元素，所以需要为每项提供一个唯一的key属性 条件指令 v-if 这个指令如果不满足条件那么就会移除元素 适用于那些切换操作少，并且一般情况下不出现在页面中的元素，这样能节省渲染成本 但是如果是需要频繁切换的元素就不适用，因为这样频繁的移除和创建元素对性能消耗大 v-show 这个指令如果不满足条件就隐藏元素 适用于那些切换操作频繁的元素。]]></content>
      <categories>
        <category>vue.js学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node.js(六)]]></title>
    <url>%2F2018%2F06%2F26%2Fnode.js(%E5%85%AD)%2F</url>
    <content type="text"><![CDATA[Path模块 path.basename(path[,ext]) 第一个参数时文件路径，当只有一个参数时返回带有扩展名的文件名 第二个参数和文件的扩展名相同的时候，返回不带扩展名的文件名 path.dirname(path) 获取文件的目录 path.extname(path) 获取文件的扩展名 path.isAbsolute(path) 检验路径是否为绝对路径，返回布尔值 path.join([…paths]) 可以自动拼接路径，返回拼接后的路径 path.normalize(path) 可以将路径转换为标准的路径 path.parse(path) 把一个路径转为对象 root根路径 dir目录 base包含后缀名的文件名 ext后缀名 name不包含后缀名的文件名 path.format(pathObject) 把一个对象转为路径 Node中的其他成员在每个模块中，处理require、exports等模块相关API之外，还有两个特殊成员： _dirname可以用来动态获取当前文件模块所属目录的绝对路径 _filename可以用来动态获取当前文件夹的绝对路径 文件操作中的路径问题在Node中文件操作的路径被设计为相对于执行node命令所处的路径，所以在node中的文件操作中，相对路径是不靠谱的。 所以在Node中文件操作统一都使用动态绝对路径来处理，利用_dirname和_filename可以动态获取路径，再加以处理 在路径拼接过程中最好不要手动拼接，使用path.join()来辅助拼接 注意：模块中的路径标识和这里的路径没有关系，不受影响的(依然是正常的相对路径) art-template中的子模版与模板继承子模板art-template可以支持在一个模板中插入另一个模板。 12&lt;% include(&apos;./header.art&apos;) %&gt;&lt;% include(&apos;./header.art&apos;, data) %&gt; 模板继承利用模板继承可以构建一个包含站点共同元素的基本模板骨架 123456789101112131415&lt;!--layout.html--&gt;&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&#123;&#123;block 'title'&#125;&#125;My Site&#123;&#123;/block&#125;&#125;&lt;/title&gt; &#123;&#123;block 'head'&#125;&#125; &lt;link rel="stylesheet" href="main.css"&gt; &#123;&#123;/block&#125;&#125;&lt;/head&gt;&lt;body&gt; &#123;&#123;block 'content'&#125;&#125;&#123;&#123;/block&#125;&#125;&lt;/body&gt;&lt;/html&gt; 123456789101112&lt;!--index.html--&gt;&#123;&#123;extend './layout.art'&#125;&#125;&#123;&#123;block 'title'&#125;&#125;&#123;&#123;title&#125;&#125;&#123;&#123;/block&#125;&#125;&#123;&#123;block 'head'&#125;&#125; &lt;link rel="stylesheet" href="custom.css"&gt;&#123;&#123;/block&#125;&#125;&#123;&#123;block 'content'&#125;&#125;&lt;p&gt;This is just an awesome page.&lt;/p&gt;&#123;&#123;/block&#125;&#125; 在渲染index.html时，会自动应用布局骨架]]></content>
      <categories>
        <category>node.js学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node.js(五)]]></title>
    <url>%2F2018%2F06%2F25%2Fnode.js(%E4%BA%94)%2F</url>
    <content type="text"><![CDATA[MongoDB关系型数据库和非关系型数据库 关系型数据库 所有的关系型数据库都需要通过sql语言来进行操作 所有的关系型数据库在操作之前都需要设计表的结构 数据表还支持约束 非关系型数据库 非关系型数据库非常灵活 有的非关系型数据库就是key-value对 MongoDB是最像关系型数据库的非关系型数据库 数据库——&gt;数据库 数据表——&gt;集合（数组） 表记录——&gt;文档对象 MongoDB不需要设计表结构 可以往里面存任意数据，没有结构性 启动和关闭数据库启动： 123# MongoDB默认使用执行mongod命令所在的盘符根目录下的/data/db作为自己的数据库存储目录# 所以在第一次执行命令之前要先手动创建一个/data/dbmongod 修改默认数据存储目录： 1mongod --dbpath=数据存储目录路径 停止：直接在开启服务的控制台Ctrl+C即停止 连接和退出数据库连接： 12# 在数据库开启状态下该命令默认连接本机的MongoDB服务mongo 退出： 1# 在连接状态下输入exit退出连接 基本命令 show dbs 查看显示所有数据库 db 查看当前操作的数据库 use 数据库名称 切换到指定的数据(如果没有会自动新建) 插入数据 通过db像JS操作对象一样操作数据 在Node中使用MongoDB 使用官方的mongodb包来操作 网址：https://github.com/mongodb/node-mongodb-native 使用第三方mongoose来操作MongoDB数据库 第三方包：mongoose基于MongoDB官方的mongodb包再一次做了封装 官网：http://mongoosejs.com/官方指南：http://mongoosejs.com/docs/guide.html官方api：http://mongoosejs.com/docs/api.html 使用Mongoose操作数据库引入模块在需要使用的js文件中引入模块 1var mongoose = require('mongoose') 连接数据库1mongoose.connect('mongodb://localhost/student') 设计表的结构12345678910111213141516171819var Schema = mongoose.Schemavar StudentSchema = new Schema(&#123; name: &#123; type: String, required: true &#125;, gender: &#123; type: Number, enum: [0,1], default:0 &#125;, age: &#123; type: Number, required: true &#125;, hobbies: &#123; type: String &#125;&#125;) 增删改查CRUD新增： 123456789101112var admin = new User(&#123; username: 'admin', password: '12542', email: 'admin@123456.com'&#125;)admin.save(function (err, ret) &#123; if (err) &#123; return console.log('保存失败') &#125; console.log('保存成功') console.log(ret)&#125;) 查询： 123456789101112131415161718192021222324252627//查询所有，返回的是一个数组User.find(function (err, ret) &#123; if (err) &#123; return console.log(err) &#125; console.log(ret)&#125;)// 按条件查询所有,第一个参数是查询的限制条件，返回的是一个数组User.find(&#123; username: 'zs'&#125;, function (err, ret) &#123; if (err) &#123; return console.log(err) &#125; console.log(ret)&#125;)// 按条件查询单个，第一个参数是查询的限制条件，如果查询到多个则返回第一个，返回的是一个对象User.findOne(&#123; username: 'zs'&#125;, function (err, ret) &#123; if (err) &#123; return console.log(err) &#125; console.log(ret)&#125;) 删除： 123456789User.remove(&#123; username: 'zs'&#125;, function (err, ret) &#123; if (err) &#123; return console.log('删除失败') &#125; console.log(ret) console.log('删除成功')&#125;) 更新： 12345678910111213141516//根据条件查询并更新多条数据，第一个参数是条件，第二个参数是更新后的数据User.updateOne(&#123;username: 'admin'&#125;, &#123;password: '123'&#125;, function (err, ret) &#123; if (err) &#123; return console.log('更新失败') &#125; console.log('更新成功') console.log(ret)&#125;)//根据id查询并更新一条数据，第二个参数是id，第二个是更新的数据User.findByIdAndUpdate('5b311f421d97022a180aa763',&#123;password: '123456'&#125;, function (err, ret) &#123; if (err) &#123; return console.log('更新失败') &#125; console.log(ret)&#125;)]]></content>
      <categories>
        <category>node.js学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node.js(四)]]></title>
    <url>%2F2018%2F06%2F24%2Fnode.js(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[文件操作路径和模块标识路径 在文件操作中使用相对路径时可以省略./。 在模块加载中相对路径不能省略./。 对于这两个操作以/开头都是表示绝对路径，从当前文件模块所处的磁盘根目录开始寻找文件。 开放公共资源 第一个参数为公共开放资源的文件名称，第二个参数为公共资源文件夹相对路径，用户可以通过文件的路径访问文件 12//通过http://localhost:3000/public/img/ab3.jpg访问app.use('/public/',express.static('./public/')) 省略第一个参数，用户可以省略/public/来访问 12//通过http://localhost:3000/img/ab3.jpg访问app.use(express.static('./public/')) 第一个参数也可自定义，这样访问时只需要把/public/换成自定义的字符串即可 12//通过http://localhost:3000/aaa/img/ab3.jpg访问app.use('/aaa/',express.static('./public/')) 在express中使用art-template 配置express： 1app.engine('html', require('express-art-template')) 利用express使用art-template Express为Response对应的对象提供了一个方法:render 通过配置之后才可以使用render方法 1res.render('html模板名', &#123;模板数据&#125;) 这里第一个参数不能写路径。直接写模板的文件名，Express默认约定开发人员把所有的视图文件都放到views目录中。 如果想要修改默认的views目录，可以app.set(&#39;views&#39;, render函数的默认路径) 配置express解析表单POST请求体的中间件express中没有解析请求体的方法，需要下载body-parser中间件才能够处理请求体 下载： 1$ npm install body-parser 载入模块： 1var bodyParser = require('body-parser') 配置： 12app.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.use(bodyParser.json()) 使用：直接通过req.body来获取请求体中的信息，以json格式存在 路由设计 编写说明文档，文档中规定好路由和请求方法参数等 单独提取路由模块，把路由模块放到一个单独文件单独处理 通过Express提供的api来让路由模块中的方法可以到入口模块中使用 创建一个路由容器 1var router = express.Router() 然后把所有的路由操作函数都挂载到router上 最后通过module.exports = router导出router 在使用的时候加载路由这个文件并且执行相应的配置 12var router = require('./router')app.use(router) 模块的设计 模块化编程的目的是增强代码的可维护性，提高开发的效率 每个模块的职责要单一，不能够混乱操作 每个项目最好只有一个入口 es6的新增数组方法find和findindex find方法可以根据条件查找数组中满足条件的指定项，返回该项。 findindex方法可以根据条件查找数组中满足条件的指定项的索引，返回索引 这两个方法由数组调用，参数为一个函数。原理是相同的 底层实现：1234567Array.prototype.find = function (callback) &#123; for (var i = 0 ; i &lt;= this.length ; i++) &#123; if (callback(this[i],i)) &#123; return this[i] &#125; &#125;&#125;]]></content>
      <categories>
        <category>node.js学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node.js(三)]]></title>
    <url>%2F2018%2F06%2F23%2Fnode.js(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[node中的模块系统 模块系统包括： 核心模块 第三方模块 自己写的模块 加载规则以及加载机制 模块的使用 node中通过require方法来载入模块。 node中具有模块作用域，加载模块只是执行模块的代码，而无法再一个模块外部直接访问被加载的模块里面的成员。 要想访问加载模块里面的成员，我们可以接受require方法的返回值，这个方法返回的是一个对象。 如果被加载的模块想把成员传递到外部模块去，可以将成员挂载到exports这个对象上去，但是注意一定时通过对象的方法挂载，而不能直接给exports赋值。 如果想把一个成员直接传递给外部模块那么可以直接给module.exports赋值，这样载入模块的返回值就是这个成员。 在模块执行的最后，默认返回module.exports，那么挂载在module.exports上面的成员也就在返回值里面了。 模块原理 在node中每个模块内部都有一个自己的module对象，在该module对象中，有一个成员exports也是一个对象。 当我们需要对外导出成员时，只需要把导出成员挂载到module.exports中，但是如果每次导出接口成员时都通过module.exports.xxx=xxx的方式就很麻烦 为了解决上一个问题，node在模块内部默认做了一个这样的操作：var exports = module.exports，所以exports与module.exports共同指向同一个对象，我们在exports上挂载成员时，module.exports也会改变，因为他们本质上指向的是同一个对象。 当我们给exports赋值后，exports的指向就改变了,不再和module.exports指向同一个对象，而最后返回的是module.exports，所以给exports赋值无法导出成员。 当我们给module.exports赋值后，module.exports的指向也就改变了，不再和exports指向同一个对象，那么之后如果再对exports进操作就无法影响module.exports，除非通过代码改变exports的指向：exports = module.exports再次建立它们的关系 require方法与加载规则 优先从缓存加载 在执行代码时，如果已经加载过一个模块了，之后再次require这个模块就不会重复加载了。 再次require这个模块会返回接口对象，但是不会重复执行里面的代码，这样能避免重复加载，提高模块加载效率 核心模块的加载 核心模块本质上也是文件，核心模块的文件已经被编译到了二进制数据中了，只需要按照名字来加载就可以了。 路径模块（自定义模块） 自定义模块要以路径形式来加载 ./当前目录 ../上一级目录 /xxx这里的/表示的是当前文件模块所属磁盘根路径 在加载自定义模块时，一定不能省略上面的路径标识，可以省略后缀名.js 第三方模块的加载 凡是第三方模块都必须通过npm来下载 使用的时候可以通过require(&#39;包名&#39;)的方式来进行加载才可以使用 任何一个第三方的包名都不会和核心模块的名字一样 第三方模块查找顺序 ( 以art-template为例 ) 判断是否是核心模块，或者是路径模块，如果都不是那就按第三方模块规则来查找 首先查找当前文件所处目录中的node_modules目录 找到node_modules/art-template 找到node_modules/art-template/package.json文件 找到node_modules/art-template/package.json文件中的main属性 main属性中记录了art-template的入口模块。 加载使用这个第三方包，这里本质上加载的还是文件。 异常情况 如果package.json文件不存在或者main指定的入口模块没有，那么node会自动寻找该目录下的index.js,index.js会作为默认备选项。 如果上面的条件有一个不成立，那么会进入上一级目录中的node_modules目录中查找，重复2-7的操作，如果有异常自动到上上级查找，重复操作， 如果最后到磁盘根目录还是没有找到最后就会报错can not find module xxx 在查找时只会在上级目录根目录下查找是否有node_modules文件，而不会到根目录下的子目录里面去查找。（这一点和js的作用域链很相似） npm node package manager npm 网站 npmjs.com npm命令行工具查看npm版本的命令：1npm --version 升级npm：1npm install --global npm 常用命令 npm init 生成包描述文件 npm init -y 跳过向导快速生成 npm install 一次性把dependencies选项中的依赖全部下载下来 npm i npm install 包名 只下载一个包 npm i 包名 npm install –save 包名 下载并保存依赖项 npm i –S 包名 npm uninstall 包名 只删除指定的包，但是如果这个包有依赖项，依赖项不会被删除 npm uninstall – save 包名 删除的同时也会把依赖信息也清除 npm un -S 包名 npm –help 查看帮助 npm 命令 –help 查看指定命令的帮助 package.json（包描述文件） 建议在每个项目的根目录下都有一个package.js文件 这个文件可以通过npm init的方式自动初始化出来。 文件里面的dependencies选项中可以保存第三方包的依赖信息。 建议在执行npm install 包名的时候都加上--sava这个选项，目的是用来保存依赖信息 如果文件中的node_modules被删除了也不用担心，我们只需要：npm install就会自动把dependencies里面所有的包下载下来。]]></content>
      <categories>
        <category>node.js学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node.js(二)]]></title>
    <url>%2F2018%2F06%2F20%2Fnode.js(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[node中模板引擎的使用准备工作 安装npm install art-template 在需要使用的文件模块加载art-template 只需要使用require方法加载就可以了：require（‘art-template’） 查文档，使用模板引擎API 使用 创建一个HTML模板文件 通过fs模块的readFile方法加载模板文件 默认读取到的是二进制数据，而模板引擎中接受的应该是字符串，所以需要通过toString方法把二进制数据转换成字符串 通过模板引擎的render方法进行模板的渲染 123456789101112131415161718192021222324var template = require('art-template')var fs = require('fs')fs.readFile('./tpl.html', function (err, data) &#123; if (err) &#123; return console.log('读取文件失败了') &#125; // 默认读取到的 data 是二进制数据 // 而模板引擎的 render 方法需要接收的是字符串 // 所以我们在这里需要把 data 二进制数据转为 字符串 才可以给模板引擎使用 var ret = template.render(data.toString(), &#123; name: 'Jack', age: 18, province: '北京市', hobbies: [ '写代码', '唱歌', '打游戏' ], title: '个人信息' &#125;) console.log(ret)&#125;) 留言本案例 路径问题 在服务端中，文件的路径不要使用相对路径，因为在这个时候所有的资源都是通过url标识符来获取的，比如说我的服务器开放了/public/目录，那么请求路径就都写成/public/xxx这里/是url根路径的意思。 文件结构问题 把当前模块所有的依赖项都声明在文件模块最上面 为了让目录结构清晰统一，我们约定，把所有HTML文件都放在views(视图)目录中 为了方便统一处理静态资源，我们约定把所有的静态资源都存放在public目录中 我们可以通过代码控制那些资源可以被用户访问，那些资源不能被用户访问，这里我们开放整个public目录 处理客户端发送的请求 我们可以根据客户端的请求路径来进行相应的操作，但是当涉及到客户端在url中传递参数时，路径就不一致了，所以我们要通过?前面的请求路径来判断客户端需要请求的操作。 使用url.parse方法可以将请求路径解析为方便操作的对象，第二个参数true表示直接将查询字符串转换为对象var parseObj = url.parse(req.url, true) 获取不包含参数的请求路径var pathname = parseObj.pathname 根据pathname来进行相应的操作 当用户请求路径为/时，服务端到数据库中查询数据，通过模板引擎渲染，然后把渲染过后的字符串发送给客户端。 当用户请求路径为/addComments?xxx时 获取表单提交的数据var comment = parseObj.query 将当前的时间日期添加到数据对象中comment.dateTime = &#39;2017-11-2 17:11:22&#39; 将新的数据对象添加到数据库中 让用户重定向到首页，这个时候数据库中的数据已经发生变化，用户看到的页面也发生了变化 如何通过服务器让客户端重定向？ 设置响应状态码res.statusCode= 302状态码302为临时重定向 在响应头中通过Location告诉客户端重定向去哪里res.setHeader(&#39;Location&#39;, &#39;/&#39;) 状态码302与301的区别 301是永久重定向，当设置状态码为301时，浏览器会把它储存到缓存中，当下次再次请求这个地址时，在浏览器端就会直接阻止这个请求，而是去请求之前重定向的页面。 302是临时重定向，浏览器不会储存，当下次再次请求这个地址时，依然会把这个请求发送到服务端。]]></content>
      <categories>
        <category>node.js学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node.js(一)]]></title>
    <url>%2F2018%2F06%2F04%2Fnode.js(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Node.js是什么 Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js不是一门语言 Node.js不是库、不是框架 Node.js是一个JavaScript运行环境 Node.js可以解析和执行JavaScript代码 Node.js可以让JavaScript代码完全脱离浏览器运行 浏览器中的JavaScript ECMAScript 基本语法 语句 函数 对象 BOM DOM Node.js中的JavaScript 没有BOM、DOM ECMAScript 在Node这个JavaScript执行环境中为JavaScript提供了一些服务器级别的操作API 例如文件的读写 网络服务的构建 网络通信 http服务器 等处理。。。 构建在Chrome的V8引擎之上 代码只是具有特定格式的字符串 引擎可以认识它，引擎可以去解析和执行代码 Node.js的作者把Google Chrome中的V8引擎移植出来，开发了一个独立的JavaScript运行环境 Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. event-driven事件驱动 non-blocking I/O model 非阻塞模型（异步） lightweight and efficient 轻量和高效 Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. npm 是世界上最大的开源库生态系统 绝大多数JavaScript相关的包都存放在npm上，可以更方便的去下载使用 npm install jQuery Node.js一些资源 《深入浅出Node.js》 《Node.js权威指南》 JavaScript标准参考教程（alpha）：http://javascript.ruanyifeng.com/nodejs/basic.html Node入门：http://www.nodebeginner.org/index-zh-cn.html 官方API文档：http://node.js.org/dist/latest-v6.x/docs/api 中文文档：http://www.nodeclass.com/api/node.html CNODE社区：http://cnode.js.org CNODE-新手入门：http://cnodejs.org/getstart 学习node的目的 B/S编程模型 Browser-Server back-end 任何服务器技术这种BS编程模型都一样，和语言无关 node只是学习BS编程模型的一个工具 模块化编程 RequireJS SeaJS 在Node中可以引用加载JavaScript脚本文件 Node常用API 异步编程 回调函数 promise async generator Express web开发框架 ECMAScript6 初步体验node.js Hello World 解析执行JavaScript 使用node运行js文件的步骤 创建编写JavaScript脚本文件 打开终端，定位到脚本文件所属目录 输入node 文件名执行对应的文件注意：文件名不用使用node.js来命名，最好不要使用中文名。 读写文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*fs是filesystem的简写，就是文件系统的意思 在node中如果想要进行文件操作，就必须引入fs这个核心模块 在fs这个核心模块中提供了所有的文件操作相关的API 例如：fs.redFile就是用来读取文件 *///1.使用require方法加载fs核心模块var fs = require('fs');/* 2.读取文件 第一个参数是读取文件的路径 第二个参数是一个回调函数 参数：data error 读取成功 data 是数据 error null 读取失败 data 是undefined error是错误对象 */fs.readFile('./data/hello.txt', function (error,data) &#123; //&lt;Buffer 68 65 6c 6c 6f 20 6e 6f 64 65 6a 73&gt; //文件中储存的是二级制数据 0 1 //这里把二进制数据转换为了16机制 //我们可以通过toString方法把其转为我能认识的字符 if(error) &#123; console.log('文件读取失败'); &#125; else &#123; console.log(data.toString()); &#125;&#125;);//写文件var fs = require('fs');//第一个参数：文件路径//第二个参数：文件内容//第三个参数：回调函数//接受一个参数 error//写入成功error是null 写入失败error是错误对象fs.writeFile('./data/你好.md','大家好，我是nodejs',function (error) &#123; if(error) &#123; console.log('文件写入失败') &#125; else &#123; console.log('文件写入成功'); &#125;&#125;); http 最简单的http服务： 12345678910111213141516171819202122//node中专门提供了一个核心模块：http//http 这个模块的职责就是帮你创建编写服务器// 1. 加载http核心模块var http = require('http');// 2. 使用http.createServer()方法创建一个web服务器// 返回一个Server 实例var server = http.createServer();// 3. 使用服务器// 服务器是提供对数据的服务的// 发请求——&gt;接受请求——&gt;处理请求——&gt;发送响应// 注册request请求事件，当客户端请求过来，就会自动触发服务器的request请求事件，然后执行第二个参数：回调处理函数server.on('request', function () &#123; console.log('收到客户端的请求了');&#125;);// 4. 绑定端口号，启动服务器server.listen(3000, function () &#123; console.log('服务器启动成功。');&#125;); node中的JS模块系统 require的作用 require是一个方法，它的作用是用来加载模块的 代码执行时碰到这个方法会去执行模块文件中的代码，然后再执行之后的代码。 require方法还有另一个作用，可以实现模块之间的通信。 node中，模块有三种： 具名的核心模块。例如：fs、http 用户自己编写的文件模块。加载自己的文件模块时注意： 相对路径必须加./ 可以省略后缀名 相对路径中./不能省略，否则会报错 在node中，没有全局作用域，只有模块作用域 模块内部和外部不能互相访问，默认都是封闭的。 不同模块之间无法访问到对方的方法和变量，只是简单执行了模块里面的代码 模块之间的通信： require方法还能够拿到被加载文件模块导出的接口对象 在每个文件模块都提供一个对象：exports exports默认是一个空对象 我们只需要把需要被外部访问的成员挂载在exports对象中，就可以了 require对象的返回值就是被加载模块的exports对象 content-type 在服务端发送给客户端的数据默认是utf8编码的，但是浏览器不知道内容是utf8编码的内容。 浏览器在不知道服务器响应内容的编码的情况下会按照当前操作系统默认编码去解析。中文操作系统默认是gbk，所以在设置编码格式的情况下中文会乱码 解决办法就是正确的告诉浏览器服务器发送给你的数据是什么编码的。 在http协议中，Content-type就是用来告诉浏览器我发送的数据是什么类型 res.setHeader(&quot;Content-Type&quot;,&#39;text/plain: charset=utf-8&#39;)可以设置响应体的数据类型。]]></content>
      <categories>
        <category>node.js学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ajax异步上传文件]]></title>
    <url>%2F2018%2F06%2F02%2Fajax%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[准备： 首先上传图片需要在html中准备一个能够上传文件的表单&lt;input id=&quot;avatar&quot; type=&quot;file&quot; multiple&gt; 由于html中一些特殊的表单元素的外表无法修改，当html中的表单的样式无法满足我们的需求的时候，我们就需要自定义表单的样式。下面介绍一下自定义表单如何完成 自定义表单 自定义表单的原理： 首先我们是无法修改表单的样式的，但是我们可以通过在委托的方式来实现表单的自定义，将我们自定义的一个元素与这个表单关联起来，当我们的表单发生改变时，也让我们自定义的元素状态发生改变，然后再把之前的表单元素隐藏起来，当点击我们自定义元素时，也触发表单的点击事件，改变表单的状态，就能完成自定义。 将表单与自定义元素的点击事件关联的方法有很多： 把表单元素隐藏，然后通过定位将表单元素平铺在自定义元素之上，那么用户在点击自定义元素的时候其实是点击表单元素，然后表单元素状态改变时，改变我们自定义元素的状态就可以了。 将表单元素和自定义元素一起放在&lt;label&gt;标签里面，在label标签中点击一个元素也会触发另一个元素的点击事件，利用这一点可以在点击自定义元素的时触发表单元素的点击，然后把表单元素隐藏。 通过js也可以做到这一点，为自定元素绑定click事件，在事件内触发表单的点击事件即可。 如下面的代码即可做到上传图片时自定义file表单,同时预览图像 1234567&lt;label class=&quot;col-sm-3 control-label&quot;&gt;头像&lt;/label&gt;&lt;div class=&quot;col-sm-6&quot;&gt; &lt;label class=&quot;form-image&quot;&gt; &lt;input id=&quot;avatar&quot; type=&quot;file&quot; multiple&gt; &lt;img src=&quot;/static/assets/img/default.png&quot;&gt; &lt;i class=&quot;mask fa fa-upload&quot;&gt;&lt;/i&gt;&lt;/label&gt; 上传图片 首先为input元素绑定状态改变的change事件。 选中的图片保存在表单元素对应的DOM对象的files属性中，可以通过jQuery的prop方法获取var files = $(this).prop(&#39;files&#39;) files属性中保存了一个FileList的对象，我们选中的图片信息就保存在这个对象里面。 {0: File(58880), 1: File(64696), length: 2}选中的图片的key就是从0开始的序号，然后这个对象中还有一个length属性，我们可以通过这个属性来判断是否选择图片。 判断是否选择图片，如果没有就退出函数if(!files.length) return 把图片信息取出来var file = file[0];（这里只取一张图片，多张图片同理） 校验文件是否符合格式要求。 在上传图片时我们使用FormData，FormData是HTML5新增的一个成员，专门配合ajax操作，用于客户端与服务端之间二进制数据的传递 12var data = new FormData();data.append(&apos;avatar&apos;,file); 然后发送ajax请求 1234567var xhr = new XMLHttpRequest(); xhr.open(&apos;POST&apos;,&apos;/admin/api/uploads.php&apos;); xhr.send(data); xhr.onload = function () &#123; var imgSrc = this.responseText; $this.siblings(&apos;img&apos;).attr(&apos;src&apos;,imgSrc).siblings(&apos;[type=&quot;hidden&quot;]&apos;).val(imgSrc); &#125;]]></content>
      <categories>
        <category>ajax</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[乐淘项目(二)]]></title>
    <url>%2F2018%2F05%2F26%2F%E4%B9%90%E6%B7%98%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[乐淘项目后台介绍： 乐淘项目后台使用boostrap搭建 使用echarts完成数据可视化 前后端分离的开发模式 学习目标： 能够更加熟悉boostrap开发。 能够完成数据可视化的操作。 进一步熟悉前后端分离的开发模式。 开发过程中知识点：login页面 bootstrap-validator插件在客户端验证表单配置nprogress插件 bootstrap-validator的使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//初始化校验插件 //1.必须是form表单结构，并且有一个提交按钮 //2.这个插件就是一个jQuery插件 样式基于boostrap $(&apos;#login&apos;).bootstrapValidator(&#123; //配置校验的不同状态下显示的图标，一般情况下使用默认的就可以了 feedbackIcons: &#123; valid: &apos;glyphicon glyphicon-ok&apos;, invalid: &apos;glyphicon glyphicon-remove&apos;, validating: &apos;glyphicon glyphicon-refresh&apos; &#125;, //需要校验的表单元素 通过名字name来选择 fields: &#123; //表单元素对应的name username: &#123; //校验规则 validators: &#123; notEmpty: &#123; message:&apos;请输入用户名&apos; &#125;, //为后台校验失败配置一个校验规则 callback: &#123; message:&apos;用户名错误&apos; &#125; &#125; &#125;, password: &#123; validators: &#123; notEmpty: &#123; message:&apos;密码不能为空&apos; &#125;, stringLength: &#123; min: 6, max: 18, message: &apos;密码长度6-18位之间&apos; &#125;, callback: &#123; message:&apos;密码错误&apos; &#125; &#125; &#125; &#125; &#125;).on(&apos;success.form.bv&apos;, function (e) &#123; //只有校验成功时才会触发 //阻止表单默认的提交事件,需要使用ajax提交 e.preventDefault(); var $form = $(e.target); //发送ajax请求给后台 $.ajax(&#123; url:&apos;/employee/employeeLogin&apos;, type:&apos;post&apos;, data:$form.serialize(), dataType:&apos;json&apos;, success: function (data) &#123; if(data.success === true) &#123; //校验成功 location.href = &apos;/a/index.html&apos;; &#125; else &#123; if(data.error === 1000) &#123; //用户名错误,需要设置用户名这个表单的校验状态为失败 //校验状态：NOT_VALIDATED 还没有校验,VALIDATING 校验中，INVALID 失败 ，VALID成功 /*sf 1.获取校验组件 2.使用更改校验状态的函数 3.这个函数的参数：校验的表单，更改为什么状态，使用哪个规则 */ $form.data(&apos;bootstrapValidator&apos;).updateStatus(&apos;username&apos;,&apos;INVALID&apos;,&apos;callback&apos;); &#125; else if (data.error === 1001) &#123; $form.data(&apos;bootstrapValidator&apos;).updateStatus(&apos;password&apos;,&apos;INVALID&apos;,&apos;callback&apos;); &#125; &#125; &#125; &#125;) &#125;) nprogress插件的使用 NProgress.set()设置进度 NProgress.start()进度条开始 NProgress.done()进度条结束,必须在start之后 NProgress.configure()初始化配置，具体参数这里就不列出来了 12345678910111213/*1.进度显示，所有页面在发送ajax时需要显示进度条2.当ajax正在请求时显示进度加载3.当ajax请求结束时 进度条走完 隐藏 *///相关的配置,隐藏右边的圈NProgress.configure(&#123;showSpinner: false&#125;);$(window).ajaxStart(function () &#123; NProgress.start();&#125;);$(window).ajaxComplete(function () &#123; NProgress.done();&#125;); index页面 使用Echarts插件实现数据可视化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var pieCharts = function () &#123; /*1.引入echarts.min.js文件*/ /*2.找到画图的容器*/ var box = document.querySelector(&apos;.picTable:last-child&apos;); /*3.初始化插件*/ var myChart = echarts.init(box); /*4.配置参数*/ var options = &#123; title : &#123; text: &apos;品牌销售占比&apos;, subtext: &apos;2017年10月&apos;, x:&apos;center&apos; &#125;, tooltip : &#123; trigger: &apos;item&apos;, /*series.name a */ /*data.name b */ /*data.value c */ /*占比 d */ formatter: &quot;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&quot; &#125;, legend: &#123; orient: &apos;vertical&apos;, left: &apos;left&apos;, data: [&apos;李宁&apos;,&apos;耐克&apos;,&apos;阿迪&apos;,&apos;匡威&apos;,&apos;回力&apos;] &#125;, series : [ &#123; name: &apos;销售情况&apos;, type: &apos;pie&apos;, radius : &apos;55%&apos;, center: [&apos;50%&apos;, &apos;60%&apos;], data:[ &#123;value:335, name:&apos;李宁&apos;&#125;, &#123;value:310, name:&apos;耐克&apos;&#125;, &#123;value:234, name:&apos;阿迪&apos;&#125;, &#123;value:135, name:&apos;匡威&apos;&#125;, &#123;value:1548, name:&apos;回力&apos;&#125; ], itemStyle: &#123; emphasis: &#123; shadowBlur: 10, shadowOffsetX: 0, shadowColor: &apos;rgba(0, 0, 0, 0.5)&apos; &#125; &#125; &#125; ] &#125; /*5.设置参数*/ myChart.setOption(options);&#125;; categorySecond页面 模板引擎使用外部变量的方法： 可以将外部变量当成参数传到模板引擎中 使用辅助方法，定义一个在模板引擎中能够使用的函数 123template.helper(&apos;getJquery&apos;,function () &#123; return jQuery; &#125;); 使用bootstrapPaginator插件完成分页功能 1234567891011121314151617181920212223242526/*初始化分页组件 根据数据*//*2.分页展示*/$(&apos;.pagination&apos;).bootstrapPaginator(&#123; /*对应的bootstrap版本*/ bootstrapMajorVersion:3, /*分页按钮的大小*/ size:&apos;small&apos;, /*当前页码*/ currentPage:data.page, /*一共多少页*/ totalPages:Math.ceil(data.total/data.size), /*页码按钮的数量 默认是5*/ numberOfPages:3, /*点击页码渲染*/ /*监听按钮的点击事件 获取点击的时候的页码*/ onPageClicked:function (event, originalEvent, type,page) &#123; /*1. event jquery的事件對象*/ /*2. originalEvent 原生dom的事件對象*/ /*3. type 按鈕的類型 */ /*4. 按鈕對應的頁碼*/ //console.log(page); window.page = page; render(); &#125;&#125;);]]></content>
      <categories>
        <category>乐淘项目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[乐淘项目(一)]]></title>
    <url>%2F2018%2F05%2F26%2F%E4%B9%90%E6%B7%98%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[乐淘项目 包含主流电商业务逻辑的移动端项目 学习的主要目标是掌握移动端应用开发 项目准备项目介绍网站是中国主要的运动鞋、皮鞋网络零售网站，聚焦在垂直的鞋及其相关商品领域深耕。凭借雄厚的资金实力和在电子商务业界的诚信积累，与Nike、Adidas、Converse、NewBalance等国际大牌深度合作。保证了产品与专卖店同步更新，让您不出家门能最快速度买到当季新款名牌鞋。 功能介绍 平台 模块 功能 移动端web端 首页 静态展示页面模块 移动端web端 分类 一级分类、二级分类 移动端web端 商品 搜索中心、商品列表、商品详情 移动端web端 购物车 购物车管理 移动端web端 用户 登录、注册、账户管理 移动端web端 收货地址 展示、添加、编辑、删除 - - - pc端后台管理 登录 管理员登录 pc端后台管理 用户管理 用户权限管理 pc端后台管理 分类管理 一级分类、二级分类管理 pc端后台管理 商品管理 商品录入、删除、修改、展示 项目架构 系统分层 使用技术 数据层： MYSQL 服务层： NodeJs(express) 前端展示： mobile web application,pc management system 开发模式 本次开发采用的是前后端分离的模式，通过ajax调用后台提供的接口完成业务逻辑，也就是接口化开发 移动端MUI框架本项目移动端采用MUI框架 Mui 是一个ui框架 针对移动端开发的ui框架 只能适配移动端（流式布局） 学习官网 http://dev.dcloud.net.cn/mui/ 官方文档 http://dev.dcloud.net.cn/mui/ui/ 组件展示 http://dcloud.io/hellomui/ 首页模块 搭建页面骨架 利用MUI的轮播组件实现轮播功能 导航栏 商品区 学习目的：搭建页面骨架，使用mui的轮播插件 分类浏览 搭建分类页面 菜单区域滚动 一级菜单渲染 二级分类联动渲染 学习目的：全屏页面，使用mui区域滚动组件，ajax异步数据交互，模板引擎动态渲染数据 搜索中心 搜索中心页面 搜索查询功能 搜索记录管理 学习目的：本地储存，模板引擎动态渲染，关键字搜索]]></content>
      <categories>
        <category>乐淘项目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动web(六)]]></title>
    <url>%2F2018%2F05%2F25%2Fmobile%20web%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[less使用的一些补充知识 浏览器无法识别less代码，必修通过编译生成css代码才能在浏览器端使用，我们也可以通过less解析插件直接在我们的页面中使用less文件 在使用less插件时我们需要在html的头部引入less.js的文件，这样可以在文档解析之前就生成css样式。 使用&lt;link&gt;标签引入less文件需要设置type=&quot;text/less&quot; 在js中使用less.watch();方法可以无需刷新就预览样式，当然会有一定的延迟。 使用这个插件预览样式时需要以http形式打开。因为其本质是通过ajax到服务端取到less文件中的数据，然后通过js中的程序动态编译成css代码，最后把css代码追加到&lt;head&gt;标签中 移动端的rem的适配方案 rem的认识。首先rem和之前接触过的em会有一点像，那么我们通过比较rem和em来认识一下rem。 rem和em都是相对单位。 em大小是基于父元素的字体大小。 rem中r是代表root的意思，也就是根元素，html标签。 所以rem的大小是基于html元素的字体大小。 rem适配 首先回顾以前的移动端适配方案： 伸缩布局 flex 流式布局 百分比 响应式布局 媒体查询 这些布局都有一个共同点：元素只能做宽度的适配（排除图片。而我们的rem适配可以实现宽度和高度同时适配，做到等比例缩放。 rem布局我们通过控制html上字体大小就可以去控制页面上所有以rem为单位的基准值控制尺寸。使用rem布局的步骤： 把页面上px单位转换成rem单位 页面制作的时候的psd上的量取的px转换成rem使用 在适配的时候设置一个基准值 换算公式：当前rem基准值 = 预设的基准值 / 设计稿宽度 * 当前设备的宽度 如何动态设置基准值？可以通过js去换算（但是js在执行时会有延迟，不推荐）。通过媒体查询也可以实现。1234567891011//通过循环设置媒体查询//less没有循环语法//使用函数的迭代，根据数组的长度去停止当前循环.adapterMixin(@index) when ( @index &gt; 0)&#123; @media (min-width: extract(@adapterDeviceList,@index))&#123; html&#123; font-size: @baseFontSize / @psdWidth * extract(@adapterDeviceList,@index); &#125; &#125; .adapterMixin( @index - 1);&#125;]]></content>
      <categories>
        <category>移动web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动web（五）]]></title>
    <url>%2F2018%2F05%2F24%2F%E7%A7%BB%E5%8A%A8web%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今日css部分的一些不熟练的知识点： 两栏自适应时要注意浮动元素优先。 box-shadow的参数问题： 参数1：x轴的偏移 参数2：y轴的偏移 参数3：阴影的模糊度 参数4：阴影的延伸 参数5：阴影的颜色 参数6：设置为inset时为内阴影 -of-type选择器和-child选择器 如p:first-of-type：找到p元素，通过p找到父元素，通过父元素找子元素中所有类型为p的元素，然后再去找到第一个p 如p:first-child：找到p元素，通过p元素找到所有的子元素，找到第一个子元素，匹配判断类型（如果不是p那么就是无效选择器） 微金所项目总结： 这次通过三天时间完成微金所项目，主要学习boostrap的基本使用方法，同时通过这个项目了解到了响应式开发原理和过程，掌握了插件使用的方法，复习了模板引擎artTemplate的使用，轮播图部分使用ajax完成了一个简单的交互功能。对boostrap中轮播图的改造使其满足我们的业务需求。 本次项目中不足的地方： css代码的质量还不是特别好，应该学习boostrap中模块化开发的思维，提高代码的复用率。 需要提高开发的效率。 Less的基本语法： 变量Less的自定义变量可以在全局样式中使用，变量使得样式的修改更加的简单 123456789101112131415161718/*注释：在css当中可以使用这种形式的注释，所以这种注释会出现在编译过后的css文件当中*///注释：这种注释css不支持，所以不会编译在css文件中/*变量*///1.必须有@前缀，@前缀相当于声明变量，：相当于等于，必须以分号结束；//2.不能以数字开头，不能包含特殊字符，变量名区分大小写@mainColor:#e92323;@className:box;div &#123; background-color: @mainColor;&#125;a:hover &#123; color: @mainColor;&#125;//变量用于字符串拼接时需要用&#123;&#125;把变量名包住.@&#123;className&#125; &#123; color: @mainColor;&#125; Mixin混入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@charset &quot;UTF-8&quot;;/*mixin是混入的意思*//*mixin的作用是混合组合样式*///.w50 &#123;// width: 50%;//&#125;//.f_left &#123;// float: left;//&#125;//.f_right &#123;// float: right;//&#125;///*1.类混入*///.w50-f_left &#123;// .w50();// .f_left();//&#125;/*2.函数的混入*//*首先定义函数在less中定义的函数不会出现在css当中*/.w50() &#123; width: 50%;&#125;//.f_left() &#123;// float: left;//&#125;//.f_right() &#123;// float: right;//&#125;//.w50-f_left &#123;// .w50();// .f_left();//&#125;/*less中的函数也是可以传参数的。1.如果定义了参数（没有设置默认值），调用的时候必须传参2.定义默认值的方法和定义变量值是一样的3.定义了参数（有默认值），参数可传可不传*/.f(@direction:left) &#123; float:@direction;&#125;/*另外对于兼容浏览器利用less的函数也非常方便*/.borderRadius(@width:100px) &#123; border-radius:@width; -webkit-border-radius: @width; -moz-border-radius: @width; -o-border-radius: @width; -ms-border-radius: @width;&#125;.w50-f_right &#123; .w50(); .borderRadius(200px); .f(right);&#125; 嵌套 12345678910111213141516171819202122232425@charset &quot;UTF-8&quot;;.wjs_app &#123;/*利用less的嵌套可以编写高内聚的组件*/ display: block; img &#123; display: none; &#125; /*需要连接的情况使用&amp;符号*/ &amp;:hover &#123; img &#123; display: block; position: absolute; left: 50%; margin-left:-60px; border: 1px solid #ccc; border-top: none; top:40px; z-index: 100000; &#125; &#125; /*子代选择器直接使用&gt;*/ &gt;div &#123; display: block; &#125;&#125; import导入使用import可以载入其他的css文件，以此来完成模块化开发 1234567@import &quot;variables&quot;;@import &quot;mixin&quot;;@import &quot;topBar&quot;;@import &quot;banner&quot;; 运算less中支持运算符，这样可以简化我们在css中对数值的控制 12345678@num:5;ul &#123; width: 100%*@num; li &#123; width: 100%/@num; color: red+yellow+blue; background: gray*3;&#125; 函数less中同样有着许多内置函数，地址：http://www.1024i.com/demo/less/reference.html]]></content>
      <categories>
        <category>移动web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第十一章DOM扩展]]></title>
    <url>%2F2018%2F05%2F22%2F%E7%AC%AC11%E7%AB%A0DOM%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[选择符API querySelector()。接受一个css选择符，返回与该模式匹配的第一个元素，如果没有匹配的元素，返回null。 querySelectorAll()。接受一个css选择符，返回的是所有匹配元素而不仅仅是一个元素，这个方法返回的是一个NodeList的实例。 这个方法返回值实际上是带有所有属性和方法的NodeList，而其底层实现则类似一组元素的快照，不会不断的对文档进行搜索动态查询。 只要传入的css选择符有效，该方法就会返回一个NodeList对象。如果没有找到匹配元素，NodeList就是空的。 如果传入浏览器不支持的选择符或者选择符有语法错误，那么会抛出错误 matchesSelector()方法 这个方法接受一个参数，即css选择符，如果调用元素与该选择符匹配，返回true；否则返回false。 HTML5 classList属性 这个classList属性是新集合类型DOMTokenList的实例。这个新类型定义了如下方法： add（value）：将给定字符串添加到列表中。如果值已经存在，就不添加了。 contains（value）：表示列表中是否存在给定的值，如果存在侧返回true，否则返会false。 remove（value）：从列表删除给定字符串。 toggle（value）：如果列表存在给定的值，删除它，如果不存在就添加它。 scrollIntoView（）方法 这个方法可以控制页面滚动，可以在所有的HTML元素上调用。 如果传入true作为参数或者不传入任何参数，窗口滚动后会让调用元素的顶部与视口顶部尽可能平齐。 如果传入false作为参数，调用元素会尽可能全部出现在视口中，顶部不一定平齐。]]></content>
      <categories>
        <category>JavaScript高级程序设计读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动web（四）使用boostrap组件构建页面]]></title>
    <url>%2F2018%2F05%2F22%2F%E7%A7%BB%E5%8A%A8web%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[如何使用boostrap组件？ 我们这里以导航条为例，分析boostrap组件的使用方法 查找boostrap组件库中是否有我们需要的组件，如果有那就复制下来。 分析组件的基本模板，了解模板的使用大体结构： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 &lt;!--h5文档申明--&gt;&lt;!DOCTYPE html&gt;&lt;!--文档语言申明 en zh-CN zh-tw --&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;!--文档编码申明--&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--要求当前网页使用浏览器最高版本的内核来渲染--&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;!--视口的设置：视口的宽度和设备一致，默认的缩放比例和PC端一致，用户不能自行缩放--&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=0&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;!-- 优先加载和浏览器解释 --&gt; &lt;title&gt;title&lt;/title&gt; &lt;!-- Bootstrap 核心样式--&gt; &lt;link href=&quot;../lib/bootstrap/css/bootstrap.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- html5shiv 和 respond 分别用来解决IE8版本浏览器不支持 H5标签和媒体查询的 不兼容问题--&gt; &lt;!-- HTML5 shiv and Respond.js for IE8 support of HTML5 elements and media queries --&gt; &lt;!-- 警告：不能以file形式打开，本地打开。最好http://打开 --&gt; &lt;!-- WARNING: Respond.js doesn&apos;t work if you view the page via file:// --&gt; &lt;!-- 在 IE 9 一下引入--&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/respond/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- navbar 导航模块 navbar-default 默认样式 --&gt;&lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;!-- 导航的内容容器 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 包含 商标区域 和 切换按钮（在移动端显示） --&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;!--切换按钮--&gt; &lt;!-- 类名：collapsed 样式 属性： data-toggle=&quot;collapse&quot; 申明是什么组件=折叠组件 data-target=&quot;#bs-example-navbar-collapse-1&quot; 控制的目标元素=选择器 其他： aria-expanded=&quot;false&quot; aria-* 代表提供给屏幕阅读器使用的（盲人阅读器） class=&quot;sr-only&quot; screen read only 代表提供给屏幕阅读器使用的（盲人阅读器） --&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot;&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;!--商标区域--&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;!-- 导航连接 表单 其他内容 被切换 --&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt; &lt;!--默认的导航--&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!--右对齐的导航--&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt;&lt;!-- bootstrap依赖jquery--&gt;&lt;!-- jQuery (necessary for Bootstrap&apos;s JavaScript plugins) --&gt;&lt;script src=&quot;../lib/jquery/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!-- bootstrap js 核心文件--&gt;&lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt;&lt;script src=&quot;../lib/bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 根据实际需求更改模板。 根据源码选择器来覆盖boostrap之前的样式，以便于修改成我们自己的样式: 拷贝源码的模块样式：准确定位到所有元素的选择器并且能够保证优先级比源码要高 针对功能进行覆盖：更改模块的名字 但是这样子做会有一些没有用到的选择器，造成代码冗余 ，可以根据实际情况选择如何应对： 删除：可以降低代码量， 保留：利于维护，方便产品的更新。 利用boostrap轮播组件制作响应式轮图 分析需求： pc端：图片高度固定，图片居中，容器铺满 移动端：宽度自适应，高度自动变化 解决方案一： 我们可以利用boostrap提供的响应式工具来控制显示方式，代码如下： 1234&lt;div class=&quot;item active&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;pc_imgBox hidden-xs&quot; style=&quot;background-image: url(../images/slide_01_2000x410.jpg)&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;m_imgBox hidden-lg hidden-md hidden-sm&quot;&gt;&lt;img src=&quot;../images/slide_01_640x340.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;/div&gt; 但是这个方案会导致在移动端虽然不会显示pc端的图片，但是还是会去请求pc端的图片，这样子去做非常的不合理。 解决方案二： 使用模板引擎，根据用户设备动态渲染轮播图图片。 解决思路： 利用ajax获取到轮播图数据 根据数据动态渲染，根据当前设备屏幕宽度的判断用户设备 利用模板引擎把数据转换成html格式字符串（模板引擎使用artTemplate） 把字符渲染到页面中 移动端的手势切换功能 轮播图代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 function banner() &#123; function render() &#123; getData(function (data) &#123; var isMob = $(window).width() &lt; 768; var pointerHtml = template(&apos;pointerTemplate&apos;, &#123;list: data&#125;); var imageHtml = template(&apos;imageTemplate&apos;, &#123;list: data, isMob: isMob&#125;); $(&apos;.carousel-indicators&apos;).html(pointerHtml); $(&apos;.carousel-inner&apos;).html(imageHtml); &#125;) &#125; function getData(callback) &#123; if (window.data) &#123; callback &amp;&amp; callback(window.data); &#125; else &#123; $.ajax(&#123; type: &apos;get&apos;, url: &apos;js/data.json&apos;, //设置dataType的作用是强制转换后台返回的数据为json对象， // 如果后台返回的不是json格式的字符串，那么就不会执行success执行error回调 dataType: &apos;json&apos;, success: function (data) &#123; window.data = data; callback &amp;&amp; callback(window.data); &#125; &#125;); &#125; &#125; //测试 $(window).on(&apos;resize&apos;, function () &#123; render(); //jQuery里面通过js主动触发某个事件使用trigger()方法 &#125;).trigger(&apos;resize&apos;); //手势操作控制轮播图 var start = 0; var isMove = false; var distance = 0; $(&apos;.wjs_banner&apos;).on(&apos;touchstart&apos;, function (e) &#123; start = e.originalEvent.touches[0].clientX; &#125;).on(&apos;touchmove&apos;, function (e) &#123; var move = e.originalEvent.touches[0].clientX; distance = move - start; isMove = true; &#125;).on(&apos;touchend&apos;, function (e) &#123; if(isMove &amp;&amp; Math.abs(distance) &gt; 50) &#123; if(distance &gt; 0) &#123; $(&apos;.carousel&apos;).carousel(&apos;prev&apos;); &#125;else &#123; $(&apos;.carousel&apos;).carousel(&apos;next&apos;); &#125; start = 0; isMove = false; distance = 0; &#125; &#125;)&#125;]]></content>
      <categories>
        <category>移动web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第十一章DOM扩展]]></title>
    <url>%2F2018%2F05%2F22%2F%E7%AC%AC12%E7%AB%A0DOM2%E5%92%8CDOM3%2F</url>
    <content type="text"></content>
      <categories>
        <category>JavaScript高级程序设计读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动web（三）响应式布局]]></title>
    <url>%2F2018%2F05%2F20%2F%E7%A7%BB%E5%8A%A8web%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[响应式布局基本知识： 媒体查询：响应式布局的基本原理就是使用媒体查询来针对不同的屏幕区间设置不同的布局和样式。下面是一个简单的媒体查询的例子：12345678910111213141516171819202122232425262728@media screen and (max-width: 768px) &#123; /*1.在超小屏设备的时候 768px以下 当前容器的宽度为100% 背景为蓝色*/ .container &#123; width: 100%; background-color: blue; &#125; &#125; @media screen and (min-width: 768px) and (max-width: 992px) &#123; /*2.在小屏设备的时候 768px—992px 当前容器的宽度750px 背景为绿色*/ .container &#123; width: 750px; background: green; &#125; &#125; @media screen and (min-width: 992px) and (max-width: 1200px) &#123; /*3.在中屏设备的时候 992px-1200px 当前容器的宽度为970px 背景为红色*/ .container &#123; width: 970px; background: red; &#125; &#125; @media screen and (min-width: 1200px) &#123; /*4.在大屏设备的时候 1200px以上 当前容器宽度1170px 背景为黄色*/ .container &#123; width: 1170px; background: yellow; &#125; &#125; 当屏幕满足条件时，@media内的样式就会覆盖之前的样式。 Boostrap的基本知识： 基本模板：要使用boostrap那么就必须要使用boostrap的基本模板，下面的代码介绍了boostrap基本模板各个语句的作用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!--h5文档申明--&gt;&lt;!DOCTYPE html&gt;&lt;!--文档语言申明 en zh-CN zh-tw --&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;!--文档编码申明--&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--要求当前网页使用浏览器最高版本的内核来渲染--&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;!--视口的设置：视口的宽度和设备一致，默认的缩放比例和PC端一致，用户不能自行缩放--&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=0&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;!-- 作用：优先加载和浏览器解释 --&gt; &lt;title&gt;title&lt;/title&gt; &lt;!-- Bootstrap 核心样式--&gt; &lt;link href=&quot;../lib/bootstrap/css/bootstrap.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- html5shiv 和 respond 分别用来解决IE8版本浏览器不支持 H5标签和媒体查询的 不兼容问题--&gt; &lt;!-- HTML5 shiv and Respond.js for IE8 support of HTML5 elements and media queries --&gt; &lt;!-- 警告：不能以file形式打开，本地打开。最好http://打开 --&gt; &lt;!-- WARNING: Respond.js doesn&apos;t work if you view the page via file:// --&gt; &lt;!-- 在 IE 9 一下引入--&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;../lib/html5shiv/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/respond/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt;&lt;!--TODO--&gt;&lt;!-- Button trigger modal --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-lg&quot; data-toggle=&quot;modal&quot; data-target=&quot;#myModal&quot;&gt; Launch demo modal&lt;/button&gt;&lt;!-- Modal --&gt;&lt;div class=&quot;modal fade&quot; id=&quot;myModal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot;&gt; &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class=&quot;modal-title&quot; id=&quot;myModalLabel&quot;&gt;Modal title&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; ... &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;Close&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;Save changes&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- bootstrap依赖jquery--&gt;&lt;!-- jQuery (necessary for Bootstrap&apos;s JavaScript plugins) --&gt;&lt;script src=&quot;../lib/jquery/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!-- bootstrap js 核心文件--&gt;&lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt;&lt;script src=&quot;../lib/bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; normalize&amp;reset的区别： 在写页面之前我们都会去重置一些浏览器本身的样式，那么boostrap使用的normalize和我们自己写的reset.ss有什么区别呢？ 共同点：normalize和reset都是为了重置样式库，来增强浏览器的表现一致性 不同点 ：我们在写样式时reset.css中通常都会设置list-style:none，因为很多时候我们并不需要无序列表的初始样式。但是normalize.css不会去重置这个样式，原因是这个样式本身已经是在每个浏览器都表现一致的样式了。总结：这两者都是为了增强浏览器的表现一致性，但是normalize不会重置已经一致的元素。 boostrap的基本样式——container： boostrap中提供的响应式布局的容器就是container，只要给容器加上container的类名那么这个容器就是响应式容器。 boostrap中流式容器的类名为：container-fluid 栅格系统： 栅格系统其实就是行和列的布局，网格状布局 行：row，必须放在.container或者.container-fluid容器内，.container默认会有15px的左右间距，.row可以填充父容器的15px的左右间距，.row默认有margin-left,margin-right -15px的拉伸。 列：col-*-* 这里*为不确定参数： 第一个*：屏幕的大小 大屏设备：lg ——大屏设备以上生效包括本身 中屏设备：md——中屏设备以上生效包含本身 小屏设备：sm——小屏设备以上生效包含本身 超小型设备：xs——超小型设备以上生效包含本身 第二个*：每一行的等份数，默认分成12等份，数字代表的是占多少份。 栅格系统支持栅格嵌套，也就是说在一行中的一个列里面可以嵌套行，嵌套的行和外面的行遵循的规则是一样的，它里面的宽度是基于父容器的。 列偏移：使用col-xs-offset-1可以使列进行偏移，里面也可以设置响应的屏幕，还有偏移的数量，这里数量是基于被分割的12等份。 列排序：push往后推，pull是往前拉，例如col-xs-push-9就是往后推9个单位 响应式工具：使用hidden-*可以设置容器在什么时候隐藏，visible-*设置容器在什么时候显示，而在其他时候都隐藏。推荐使用第一种。 自定义字体图标： 12345678910111213141516171819202122/*自定义字体图标*//*1.通过@font-face定义自己的字体*/@font-face &#123; /*2.申明自己的字体名称*/ font-family: &apos;wjs&apos;; /*3.引入字体文件（约束某一段字符代码什么图案）*/ src: url(../fonts/MiFie-Web-Font.svg) format(&apos;svg&apos;), url(../fonts/MiFie-Web-Font.eot) format(&apos;embedded-opentype&apos;), url(../fonts/MiFie-Web-Font.ttf) format(&apos;truetype&apos;), url(../fonts/MiFie-Web-Font.woff) format(&apos;woff&apos;);&#125;/*4.使用类名和伪类让字体图标更好维护*/.wjs_icon&#123; font-family: wjs;&#125;.wjs_icon_phone::before&#123; content: &quot;\e908&quot;;&#125;.wjs_icon_tel::before&#123; content: &quot;\e909&quot;;&#125;]]></content>
      <categories>
        <category>移动web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动web（二）]]></title>
    <url>%2F2018%2F05%2F19%2F%E7%A7%BB%E5%8A%A8web%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[移动端的Js事件，移动端常用的JS特效 常用的JS事件： touch事件：touch事件是移动端的触摸事件，而且是一组事件: touchstart ：指触摸屏幕的时候触发touchmove：手指在屏幕来回滑动时触发touchend：当手指离开屏幕时触发touchcancel：当别迫终止滑动的时候触发（来电，弹出消息） 使用touch： 绑定事件：由于移动端不用考虑兼容IE，所以使用addEventListener来绑定事件。 事件对象：TouchList——是触摸点的集合（一个手指触摸就是一个触摸点，也就是和屏幕接触的点的个数） changeTouches——改变后的触摸点的集合targetTouches——当前元素的触摸点的集合touches——页面上所有触摸点的集合 changeTouches只要触发这个触摸事件它就会改变 targetTouches和touches在离开屏幕的时候无法记录触摸点 常用的移动端特效： 移动端轮播图： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394 function banner() &#123; /* * 1.自动轮播且无缝 利用定时器加过渡 * 2.点要随着图片的轮播改变 根据索引去切换 * 3.滑动效果 利用touch事件完成 * 4.滑动结束的时候 如果滑动的距离不超过屏幕的1/3 会吸附回去 利用过渡 * 5.滑动结束的时候 如果滑动的距离超过屏幕的1/3切换（上一张，下一张）根据滑动的方向 过渡 * */ var banner = document.querySelector(&apos;.jd_banner&apos;); var width = banner.offsetWidth; var imageBox = banner.querySelector(&apos;ul:first-child&apos;); var pointBox = banner.querySelector(&apos;ul:last-child&apos;); var points = pointBox.querySelectorAll(&apos;li&apos;); var index = 1; function addTransition() &#123; imageBox.style.transition = &apos;all 0.2s&apos;; imageBox.style.webkitTransition = &apos;all 0.2s&apos;; &#125; function removeTransition() &#123; imageBox.style.transition = &apos;none&apos;; imageBox.style.webkitTransition = &apos;none&apos;; &#125; function setTranslate(step) &#123; imageBox.style.transform = &apos;translateX(&apos; + (step) + &apos;px)&apos;; imageBox.style.webkitTransform = &apos;translateX(&apos; + (step) + &apos;px)&apos;; &#125; var timer = null; function selfMotion() &#123; timer = setInterval(function () &#123; index++; addTransition(); setTranslate(-index * width); &#125;, 3000); &#125; selfMotion(); imageBox.addEventListener(&apos;transitionend&apos;, function () &#123; if (index &gt; 8) &#123; index = 1; removeTransition(); setTranslate(-index * width); &#125; else if (index &lt; 1) &#123; index = 8; removeTransition(); setTranslate(-index * width); &#125; setPoints(); &#125;); function setPoints() &#123; pointBox.querySelector(&apos;.now&apos;).classList.remove(&apos;now&apos;); points[index - 1].classList.add(&apos;now&apos;); &#125; var starX = 0; var distance = 0; var isMove = false; imageBox.addEventListener(&apos;touchstart&apos;, function (e) &#123; clearInterval(timer); starX = e.touches[0].clientX; &#125;); imageBox.addEventListener(&apos;touchmove&apos;, function (e) &#123; var moveX = e.touches[0].clientX; distance = moveX - starX; var translateX = -index * width + distance; removeTransition(); setTranslate(translateX); isMove = true; &#125;); imageBox.addEventListener(&apos;touchend&apos;, function (e) &#123; if (!isMove) return false; if (Math.abs(distance) &lt; width / 3) &#123; addTransition(); setTranslate(-index * width); &#125; else if (distance &gt; width / 3) &#123; index--; addTransition(); setTranslate(-index * width); &#125; else if (distance &lt; -width / 3) &#123; index++; addTransition(); setTranslate(-index * width); &#125; starX = 0; distance = 0; clearInterval(timer); selfMotion(); &#125;)&#125; 利用touch事件封装一个手势事件函数： 1234567891011121314151617181920212223242526function bandSwipeEvent(dom,leftCallback,rightCallback) &#123; var starX = 0; var distanceX = 0; var isMove = false; dom.addEventListener(&apos;touchstart&apos;, function (e) &#123; starX = e.touches[0].clientX; &#125;); dom.addEventListener(&apos;touchmove&apos;, function (e) &#123; var moveX = e.touches[0].clientX; distanceX = moveX - starX; isMove = true; &#125;); dom.addEventListener(&apos;touchend&apos;, function (e) &#123; if(!isMove || Math.abs(distanceX) &lt; 50) return false; if(distanceX &gt; 0) &#123; rightCallback &amp;&amp; rightCallback.call(this,e); &#125; else &#123; leftCallback &amp;&amp; leftCallback.call(this,e); &#125; starX = 0; distanceX = 0; isMove = false; &#125;) &#125; tap轻击事件： 移动端也有click事件（但是为了区分是滑动还是点击，click点击的延时300ms）这样影响用户体验，我们可以利用touch事件封装一个tap轻击事件。 当然也可以引入fastclick.js库来提高click响应的速度。 123456789101112131415161718192021222324function bindTapEvent(dom,callback)&#123; var startTime = 0; var isMove = false; dom.addEventListener(&apos;touchstart&apos;, function (e) &#123; startTime = Date.now(); &#125;); dom.addEventListener(&apos;touchmove&apos;, function (e) &#123; isMove = true; &#125;); dom.addEventListener(&apos;touchend&apos;, function (e) &#123; var endTime = Date.now(); var time = endTime - startTime; if(time &lt; 150 &amp;&amp; !isMove) &#123; callback &amp;&amp; callback.call(this,e); &#125; startTime = 0; isMove = false; &#125;); &#125; bindTapEvent(document.querySelector(&apos;.box&apos;), function (e) &#123; console.log(this); console.log(e); console.log(&apos;tap&apos;); &#125;) 今天做的小demo，两个移动端jd页面： https://953950350.github.io/mobile-JD/]]></content>
      <categories>
        <category>移动web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动web(一)]]></title>
    <url>%2F2018%2F05%2F18%2Fmobile%20web%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[刚刚开通博客，这是我的第一篇博客，关于我的移动web的学习的一些笔记。 移动web的布局： 流式布局： 由于移动端设备大小差异较大，所以在布局时不能把内容大小写死，大部分都是采用流式。 所谓流式布局就是百分比布局，非固定像素，内容向两侧填充，理解成流动的布局，称为流式布局 viewport： 这是移动端特有的，它是用来承载网页的。在默认情况下viewport会根据用户设备的大小对网页的大小进行一定的缩放。但是这样的缩放会导致在不同设备下我们的网页样式不同，所以需要我们手动设置viewport的一些属性。 pc端网页承载关系：浏览器—&gt;网页 移动端网页承载关系：浏览器—&gt;viewport—&gt;网页 适配方案： 适配要求： 网页宽度必须和浏览器保持一致。 默认显示的缩放比例和PC端保持一致（缩放比例1.0） 不允许用户自行缩放网页 适配设置： 如果任何设置都没有，默认走的就是viewport的默认设置，所以需要更改viewport设置达到适配要求。 &lt;meta name=&quot;viewport&quot;&gt;设置视口的标签,这个标签应该放在编码标签的后面 viewport的功能： width ——可以设置网页宽度（device-width为当前设备的宽度） height——可以设置网页高度 initial-scale——设置默认的缩放比例 user-scale——可以设置是否允许用户自行缩放 maximum-scale——设置最大缩放比例 maximum-scale——设置最小缩放比例 在viewport的标签中的content=” “属性中使用以上参数 标准的适配方案：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,user-scalable=0&quot;&gt; 非主流的适配方案： 页面的真实尺寸会比在移动设备的尺寸大几倍 根据设备的大小和分辨率进行不同的缩放操作 在实际开发中使用标准适配方案较多，非主流的适配方案成本高，但是能够提高网页的清晰度。 移动端的一些特殊的设置： 关于插件的使用： 可以使用jQuery，但是实际工作中并不会用到jQuery，因为jQuery主要是做了许多桌面浏览器的兼容问题，特别是兼容IE，但是移动端没有IE。 移动端的主流浏览器的内核：基本上都是webkit 或者 blink 兼容 -webkit- 在移动端主要使用H5的api或者使用zepto.js的库（这个库是基于高版本浏览器开发的） css的一些特殊设置： 由于移动端使用的是百分比布局，那么盒子的大小就无法确定，所以需要设置box-sizing : border-box,这样能够防止内容溢出浏览器。 有一些移动端浏览器会有点击高亮的设置-webkit-tap-heightlight-color: red可以设置不同的颜色，如果设置为transparent那是清除点击高亮效果。 移动页面css的样式初始化：1234567891011121314151617181920212223242526272829303132*::before,*::after&#123; /*所有的标签，和伪元素都选中*/ margin: 0; padding: 0; /*移动端常用布局是非固定像素*/ box-sizing: border-box; -webkit-box-sizing: border-box; /*点击高亮效果的清除*/ tap-highlight-color: transparent; -webkit-tap-highlight-color: transparent;&#125;body&#123; font-size: 14px; font-family: &quot;Microsoft YaHei&quot;,sans-serif; color: #333;&#125;ul,ol&#123; list-style: none;&#125;a&#123; text-decoration: none; color: #333;&#125;input,textarea&#123; border: none; outline: none; /*不允许改变尺寸*/ resize: none; /*元素的外观 none没有任何样式*/ -webkit-appearance: none;&#125;]]></content>
      <categories>
        <category>移动web</category>
      </categories>
  </entry>
</search>
